{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Strutex","text":"<p>Python AI PDF Utilities \u2014 Extract structured JSON from documents using LLMs.</p>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>from strutex import DocumentProcessor, GeminiProvider\nfrom pydantic import BaseModel\n\nclass Invoice(BaseModel):\n    invoice_number: str\n    vendor: str\n    total: float\n\nprocessor = DocumentProcessor(provider=GeminiProvider())\nresult = processor.process(\"invoice.pdf\", \"Extract invoice data\", model=Invoice)\n\nprint(result.invoice_number)  # Validated Pydantic model\n</code></pre>"},{"location":"#documentation-map","title":"Documentation Map","text":""},{"location":"#tutorial-start-here","title":"\ud83d\udcda Tutorial (Start Here)","text":"<p>Progressive learning path from basics to advanced:</p> # Page Description 1 Quickstart First extraction in 5 minutes 2 Your First Schema Define custom schemas (Pydantic &amp; native) 3 Switching Providers Configure GeminiProvider, OpenAIProvider, etc. 4 Adding Validation Validators and verification loop 5 Caching MemoryCache, SQLiteCache, FileCache 6 Processing Hooks Pre/post processing hooks 7 Input Sanitization Input cleaning, PII redaction 8 Batch &amp; Async process_batch, aprocess 9 Streaming Real-time extraction feedback 10 Error Handling Errors, retries, debugging 11 File Uploads BytesIO, Flask, FastAPI 12 Integrations LangChain, LlamaIndex (Experimental) 13 Custom Plugins Create Provider, Extractor, SecurityPlugin 14 Use Cases Invoice, Receipt, Resume examples 15 Prompt Engineering StructuredPrompt builder"},{"location":"#user-guide","title":"\ud83d\udcd6 User Guide","text":"<p>Reference documentation for core features:</p> Section Pages Schemas Schema Types \u00b7 Built-in Schemas \u00b7 Pydantic Support Prompts Prompt Builder \u00b7 Verification"},{"location":"#providers","title":"\u26a1 Providers","text":"<p>LLM provider configuration and optimization:</p> Page Description Overview All supported providers Provider Chains Fallback and cost optimization Caching Reference Detailed cache API"},{"location":"#integrations","title":"\ud83d\udd0c Integrations","text":"<p>Use with popular AI frameworks:</p> Page Description Integrations LangChain, LlamaIndex, Haystack, Unstructured"},{"location":"#advanced","title":"\ud83d\udd27 Advanced","text":"<p>For power users and contributors:</p> Page Description Plugin System Full plugin API reference Hooks Reference Hook specifications Processing Context BatchContext, ProcessingContext Streaming Streaming API reference CLI Commands Command-line interface"},{"location":"#architecture","title":"\ud83c\udfd7\ufe0f Architecture","text":"<p>Internal design and extension points:</p> Page Description Extractors PDF, Excel, Image extractors Validators Schema, Sum, Date validators Input Sanitization Sanitization API"},{"location":"#reference","title":"\ud83d\udccb Reference","text":"Page Description API Reference Full API documentation Changelog Version history"},{"location":"#architecture-overview","title":"Architecture Overview","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     DocumentProcessor                        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502 Security \u2502\u2192 \u2502 Extractor\u2502\u2192 \u2502 Provider \u2502\u2192 \u2502Validator \u2502    \u2502\n\u2502  \u2502  Chain   \u2502  \u2502  Plugin  \u2502  \u2502  Plugin  \u2502  \u2502  Plugin  \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502         \u2193            \u2193            \u2193            \u2193            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n\u2502  \u2502                   Plugin Registry                       \u2502 \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"Feature Description 15 Tutorials Progressive learning path 6 Providers Gemini, OpenAI, Anthropic, Ollama, Groq, Langdock Plugin System Extend with custom providers, validators Pydantic Support Type-safe extractions Caching Reduce API costs Framework Integrations LangChain, LlamaIndex, Haystack Security Layer Injection detection, PII redaction CLI Tools <code>strutex run</code>, <code>strutex prompt build</code>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install strutex\n\n# With integrations\npip install strutex[langchain]\npip install strutex[all]\n</code></pre> <p>\u2192 Getting Started</p>"},{"location":"api-reference/","title":"API Reference","text":"<p>Complete reference for all public APIs.</p>"},{"location":"api-reference/#documentprocessor","title":"DocumentProcessor","text":"<p>options: show_root_heading: true members: - init - process</p>"},{"location":"api-reference/#strutex.processor.DocumentProcessor","title":"<code>DocumentProcessor(provider: Union[str, Provider] = 'gemini', model_name: str = 'gemini-2.5-flash', api_key: Optional[str] = None, security: Optional[SecurityPlugin] = None, cache: Optional[Any] = None, on_pre_process: Optional[PreProcessCallback] = None, on_post_process: Optional[PostProcessCallback] = None, on_error: Optional[ErrorCallback] = None)</code>","text":"<p>Main document processing class for extracting structured data from documents.</p> <p>The <code>DocumentProcessor</code> orchestrates document extraction using pluggable providers, with optional security layer and Pydantic model support. It automatically detects file types, applies security checks, and validates output against schemas.</p> ATTRIBUTE DESCRIPTION <code>security</code> <p>Optional security plugin/chain for input/output validation.</p> <p> </p> Example <p>Basic usage with schema:</p> <pre><code>from strutex import DocumentProcessor, Object, String, Number\n\nschema = Object(properties={\n    \"invoice_number\": String(),\n    \"total\": Number()\n})\n\nprocessor = DocumentProcessor(provider=\"gemini\")\nresult = processor.process(\"invoice.pdf\", \"Extract data\", schema)\nprint(result[\"invoice_number\"])\n</code></pre> <p>With callbacks:</p> <pre><code>processor = DocumentProcessor(\n    provider=\"gemini\",\n    on_post_process=lambda result, ctx: {**result, \"processed\": True}\n)\n</code></pre> <p>With decorator:</p> <pre><code>processor = DocumentProcessor()\n\n@processor.on_post_process\ndef add_timestamp(result, context):\n    result[\"timestamp\"] = datetime.now().isoformat()\n    return result\n</code></pre> <p>Initialize the document processor.</p> PARAMETER DESCRIPTION <code>provider</code> <p>Provider name (e.g., \"gemini\", \"openai\") or a <code>Provider</code> instance.</p> <p> TYPE: <code>Union[str, Provider]</code> DEFAULT: <code>'gemini'</code> </p> <code>model_name</code> <p>LLM model name to use (only when provider is a string).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'gemini-2.5-flash'</code> </p> <code>api_key</code> <p>API key for the provider. Falls back to environment variables (e.g., <code>GOOGLE_API_KEY</code> for Gemini).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>security</code> <p>Optional <code>SecurityPlugin</code> or <code>SecurityChain</code> for input/output validation. Security is opt-in.</p> <p> TYPE: <code>Optional[SecurityPlugin]</code> DEFAULT: <code>None</code> </p> <code>cache</code> <p>Optional cache instance (MemoryCache, SQLiteCache, etc.) for caching extraction results to avoid redundant API calls.</p> <p> TYPE: <code>Optional[Any]</code> DEFAULT: <code>None</code> </p> <code>on_pre_process</code> <p>Callback called before processing. Receives (file_path, prompt, schema, mime_type, context) and can return a dict with modified values.</p> <p> TYPE: <code>Optional[PreProcessCallback]</code> DEFAULT: <code>None</code> </p> <code>on_post_process</code> <p>Callback called after processing. Receives (result, context) and can return a modified result dict.</p> <p> TYPE: <code>Optional[PostProcessCallback]</code> DEFAULT: <code>None</code> </p> <code>on_error</code> <p>Callback called on error. Receives (error, file_path, context) and can return a fallback result or None to propagate the error.</p> <p> TYPE: <code>Optional[ErrorCallback]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the specified provider is not found in the registry.</p> Example <pre><code># Using callbacks\nprocessor = DocumentProcessor(\n    provider=\"gemini\",\n    on_post_process=lambda result, ctx: normalize_dates(result)\n)\n\n# With caching\nfrom strutex import MemoryCache\nprocessor = DocumentProcessor(\n    provider=\"gemini\",\n    cache=MemoryCache()\n)\n</code></pre> Source code in <code>strutex/processor.py</code> <pre><code>def __init__(\n    self,\n    provider: Union[str, Provider] = \"gemini\",\n    model_name: str = \"gemini-2.5-flash\",\n    api_key: Optional[str] = None,\n    security: Optional[SecurityPlugin] = None,\n    cache: Optional[Any] = None,\n    on_pre_process: Optional[PreProcessCallback] = None,\n    on_post_process: Optional[PostProcessCallback] = None,\n    on_error: Optional[ErrorCallback] = None,\n):\n    \"\"\"\n    Initialize the document processor.\n\n    Args:\n        provider: Provider name (e.g., \"gemini\", \"openai\") or a\n            [`Provider`][strutex.plugins.base.Provider] instance.\n        model_name: LLM model name to use (only when provider is a string).\n        api_key: API key for the provider. Falls back to environment variables\n            (e.g., `GOOGLE_API_KEY` for Gemini).\n        security: Optional [`SecurityPlugin`][strutex.plugins.base.SecurityPlugin]\n            or [`SecurityChain`][strutex.security.chain.SecurityChain] for\n            input/output validation. Security is opt-in.\n        cache: Optional cache instance (MemoryCache, SQLiteCache, etc.) for\n            caching extraction results to avoid redundant API calls.\n        on_pre_process: Callback called before processing. Receives\n            (file_path, prompt, schema, mime_type, context) and can return\n            a dict with modified values.\n        on_post_process: Callback called after processing. Receives\n            (result, context) and can return a modified result dict.\n        on_error: Callback called on error. Receives (error, file_path, context)\n            and can return a fallback result or None to propagate the error.\n\n    Raises:\n        ValueError: If the specified provider is not found in the registry.\n\n    Example:\n        ```python\n        # Using callbacks\n        processor = DocumentProcessor(\n            provider=\"gemini\",\n            on_post_process=lambda result, ctx: normalize_dates(result)\n        )\n\n        # With caching\n        from strutex import MemoryCache\n        processor = DocumentProcessor(\n            provider=\"gemini\",\n            cache=MemoryCache()\n        )\n        ```\n    \"\"\"\n    self.security = security\n    self.cache = cache\n\n    # Hook storage: callbacks first, then decorated hooks\n    self._pre_process_hooks: List[PreProcessCallback] = []\n    self._post_process_hooks: List[PostProcessCallback] = []\n    self._error_hooks: List[ErrorCallback] = []\n\n    # Pluggy integration\n    self._hook_plugin: Optional[_CallbackHookPlugin] = None\n    self._hook_plugin_registered = False\n\n    # Add initial callbacks if provided\n    if on_pre_process:\n        self._pre_process_hooks.append(on_pre_process)\n    if on_post_process:\n        self._post_process_hooks.append(on_post_process)\n    if on_error:\n        self._error_hooks.append(on_error)\n\n    # Resolve provider\n    if isinstance(provider, str):\n        self.provider_name = provider.lower()\n\n        # Try to get from registry\n        provider_cls = PluginRegistry.get(\"provider\", self.provider_name)\n\n        if provider_cls:\n            self._provider = provider_cls(api_key=api_key, model=model_name)\n        else:\n            # Fallback for backward compatibility\n            if self.provider_name in (\"google\", \"gemini\"):\n                from .providers.gemini import GeminiProvider\n                self._provider = GeminiProvider(api_key=api_key, model=model_name)\n            else:\n                raise ValueError(f\"Unknown provider: {provider}. Available: {list(PluginRegistry.list('provider').keys())}\")\n    else:\n        # Provider instance passed directly\n        self._provider = provider\n        # Try to get name from provider instance\n        self.provider_name = getattr(provider, 'name', type(provider).__name__)\n</code></pre>"},{"location":"api-reference/#strutex.processor.DocumentProcessor.__del__","title":"<code>__del__()</code>","text":"<p>Unregister hooks when processor is garbage collected.</p> Source code in <code>strutex/processor.py</code> <pre><code>def __del__(self):\n    \"\"\"Unregister hooks when processor is garbage collected.\"\"\"\n    if self._hook_plugin_registered and self._hook_plugin:\n        try:\n            from .plugins.hooks import get_plugin_manager\n            pm = get_plugin_manager()\n            if pm:\n                pm.unregister(self._hook_plugin)\n        except Exception:\n            pass  # Ignore errors during cleanup\n</code></pre>"},{"location":"api-reference/#strutex.processor.DocumentProcessor.aprocess","title":"<code>aprocess(file_path: str, prompt: str, schema: Optional[Schema] = None, model: Optional[Type] = None, security: Optional[Union[SecurityPlugin, bool]] = None, verify: bool = False, **kwargs) -&gt; Any</code>  <code>async</code>","text":"<p>Async version of <code>process</code>.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>Absolute path to the source file</p> <p> TYPE: <code>str</code> </p> <code>prompt</code> <p>Extraction instruction</p> <p> TYPE: <code>str</code> </p> <code>schema</code> <p>Schema definition</p> <p> TYPE: <code>Optional[Schema]</code> DEFAULT: <code>None</code> </p> <code>model</code> <p>Pydantic model</p> <p> TYPE: <code>Optional[Type]</code> DEFAULT: <code>None</code> </p> <code>security</code> <p>Security configuration</p> <p> TYPE: <code>Optional[Union[SecurityPlugin, bool]]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Provider options</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>Extracted data or Pydantic instance</p> Source code in <code>strutex/processor.py</code> <pre><code>async def aprocess(\n    self,\n    file_path: str,\n    prompt: str,\n    schema: Optional[Schema] = None,\n    model: Optional[Type] = None,\n    security: Optional[Union[SecurityPlugin, bool]] = None,\n    verify: bool = False,\n    **kwargs\n) -&gt; Any:\n    \"\"\"\n    Async version of `process`.\n\n    Args:\n        file_path: Absolute path to the source file\n        prompt: Extraction instruction\n        schema: Schema definition\n        model: Pydantic model\n        security: Security configuration\n        **kwargs: Provider options\n\n    Returns:\n        Extracted data or Pydantic instance\n    \"\"\"\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"File not found: {file_path}\")\n\n    # Hooks currently run synchronously - in future we may add async hooks\n    self._ensure_hooks_registered()\n\n    # Handle Pydantic model\n    pydantic_model = None\n    if model is not None:\n        from .pydantic_support import pydantic_to_schema\n        schema = pydantic_to_schema(model)\n        pydantic_model = model\n\n    if schema is None:\n        raise ValueError(\"Either 'schema' or 'model' must be provided\")\n\n    mime_type = get_mime_type(file_path)\n\n    mime_type = get_mime_type(file_path)\n\n    # Create context for hooks\n    context: Dict[str, Any] = {\n        \"file_path\": file_path,\n        \"mime_type\": mime_type,\n        \"kwargs\": kwargs,\n    }\n\n    # Run pre-process hooks (sync)\n    from .plugins.hooks import call_hook\n    pre_results = call_hook(\n        \"pre_process\",\n        file_path=file_path,\n        prompt=prompt,\n        schema=schema,\n        mime_type=mime_type,\n        context=context\n    )\n    for hook_result in pre_results:\n        if hook_result and isinstance(hook_result, dict) and \"prompt\" in hook_result:\n            prompt = hook_result[\"prompt\"]\n\n    # Security\n    effective_security = self._resolve_security(security)\n    if effective_security:\n        input_result = effective_security.validate_input(prompt)\n        if not input_result.valid:\n            raise SecurityError(f\"Input rejected: {input_result.reason}\")\n        prompt = input_result.text or prompt\n\n    # Async Processing\n    try:\n        result = await self._provider.aprocess(\n            file_path=file_path,\n            prompt=prompt,\n            schema=schema,\n            mime_type=mime_type,\n            **kwargs\n        )\n    except Exception as e:\n        # Run error hooks (sync)\n        error_results = call_hook(\n            \"on_error\",\n            error=e,\n            file_path=file_path,\n            context=context\n        )\n        fallback = None\n        for hook_result in error_results:\n            if hook_result is not None:\n                fallback = hook_result\n                break\n\n        if fallback is not None:\n            result = fallback\n        else:\n            raise\n\n    # Security output\n    if effective_security and isinstance(result, dict):\n        output_result = effective_security.validate_output(result)\n        if not output_result.valid:\n            raise SecurityError(f\"Output rejected: {output_result.reason}\")\n        result = output_result.data or result\n\n    # Post-process (sync)\n    if isinstance(result, dict):\n        post_results = call_hook(\n            \"post_process\",\n            result=result,\n            context=context\n        )\n        for hook_result in post_results:\n            if hook_result is not None and isinstance(hook_result, dict):\n                result = hook_result\n\n    # Validation\n    if pydantic_model is not None:\n        from .pydantic_support import validate_with_pydantic\n        result = validate_with_pydantic(result, pydantic_model)\n\n    if verify:\n        result = await self.averify(file_path, result, schema=schema, model=model, **kwargs)\n\n    return result\n</code></pre>"},{"location":"api-reference/#strutex.processor.DocumentProcessor.aprocess_batch","title":"<code>aprocess_batch(file_paths: List[str], prompt: str, schema: Optional[Schema] = None, model: Optional[Type] = None, max_concurrency: int = 4, **kwargs) -&gt; BatchContext</code>  <code>async</code>","text":"<p>Async process multiple documents in parallel.</p> PARAMETER DESCRIPTION <code>file_paths</code> <p>List of file paths</p> <p> TYPE: <code>List[str]</code> </p> <code>prompt</code> <p>Extraction prompt</p> <p> TYPE: <code>str</code> </p> <code>schema</code> <p>Output schema</p> <p> TYPE: <code>Optional[Schema]</code> DEFAULT: <code>None</code> </p> <code>model</code> <p>Pydantic model</p> <p> TYPE: <code>Optional[Type]</code> DEFAULT: <code>None</code> </p> <code>max_concurrency</code> <p>Max concurrent async tasks</p> <p> TYPE: <code>int</code> DEFAULT: <code>4</code> </p> <code>**kwargs</code> <p>Provider options</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>BatchContext</code> <p>BatchContext containing results and stats</p> Source code in <code>strutex/processor.py</code> <pre><code>async def aprocess_batch(\n    self,\n    file_paths: List[str],\n    prompt: str,\n    schema: Optional[Schema] = None,\n    model: Optional[Type] = None,\n    max_concurrency: int = 4,\n    **kwargs\n) -&gt; BatchContext:\n    \"\"\"\n    Async process multiple documents in parallel.\n\n    Args:\n        file_paths: List of file paths\n        prompt: Extraction prompt\n        schema: Output schema\n        model: Pydantic model\n        max_concurrency: Max concurrent async tasks\n        **kwargs: Provider options\n\n    Returns:\n        BatchContext containing results and stats\n    \"\"\"\n    import asyncio\n    from .context import BatchContext\n\n    batch_ctx = BatchContext(total_documents=len(file_paths))\n    semaphore = asyncio.Semaphore(max_concurrency)\n\n    async def _aprocess_one(path: str):\n        async with semaphore:\n            try:\n                result = await self.aprocess(path, prompt, schema, model, **kwargs)\n                batch_ctx.add_result(path, result)\n            except Exception as e:\n                batch_ctx.add_error(path, e)\n\n    tasks = [_aprocess_one(path) for path in file_paths]\n    await asyncio.gather(*tasks)\n\n    return batch_ctx\n</code></pre>"},{"location":"api-reference/#strutex.processor.DocumentProcessor.averify","title":"<code>averify(file_path: str, result: Any, schema: Optional[Schema] = None, model: Optional[Type] = None, verify_prompt: Optional[str] = None, **kwargs) -&gt; Any</code>  <code>async</code>","text":"<p>Async version of verify.</p> Source code in <code>strutex/processor.py</code> <pre><code>async def averify(\n    self,\n    file_path: str,\n    result: Any,\n    schema: Optional[Schema] = None,\n    model: Optional[Type] = None,\n    verify_prompt: Optional[str] = None,\n    **kwargs\n) -&gt; Any:\n    \"\"\"Async version of verify.\"\"\"\n    import json\n\n    if verify_prompt is None:\n        verify_prompt = (\n            \"You are a strict data auditor. Your task is to verify the extracted data \"\n            \"against the document provided. \\n\"\n            \"Review the data below. If it contains errors or missing fields that exist \"\n            \"in the document, CORRECT them. If the data is correct, return it as is.\\n\"\n            \"Return the final validated JSON strictly adhering to the schema.\"\n        )\n\n    if hasattr(result, \"model_dump_json\"):\n        result_str = result.model_dump_json()\n    elif isinstance(result, dict):\n        result_str = json.dumps(result, default=str)\n    else:\n        result_str = str(result)\n\n    full_prompt = f\"{verify_prompt}\\n\\n[EXTRACTED DATA TO VERIFY]:\\n{result_str}\"\n\n    return await self.aprocess(\n        file_path=file_path,\n        prompt=full_prompt,\n        schema=schema,\n        model=model,\n        verify=False,\n        **kwargs\n    )\n</code></pre>"},{"location":"api-reference/#strutex.processor.DocumentProcessor.on_error","title":"<code>on_error(func: ErrorCallback) -&gt; ErrorCallback</code>","text":"<p>Decorator to register an error hook.</p> <p>The hook receives (error, file_path, context) and can return a fallback result dict. Return None to propagate the original error.</p> Example <pre><code>@processor.on_error\ndef handle_rate_limit(error, file_path, context):\n    if \"rate limit\" in str(error).lower():\n        return {\"error\": \"Rate limited, please retry\"}\n    return None  # Propagate other errors\n</code></pre> Source code in <code>strutex/processor.py</code> <pre><code>def on_error(self, func: ErrorCallback) -&gt; ErrorCallback:\n    \"\"\"\n    Decorator to register an error hook.\n\n    The hook receives (error, file_path, context) and can return a fallback\n    result dict. Return None to propagate the original error.\n\n    Example:\n        ```python\n        @processor.on_error\n        def handle_rate_limit(error, file_path, context):\n            if \"rate limit\" in str(error).lower():\n                return {\"error\": \"Rate limited, please retry\"}\n            return None  # Propagate other errors\n        ```\n    \"\"\"\n    self._error_hooks.append(func)\n    self._hook_plugin_registered = False  # Force re-registration\n    return func\n</code></pre>"},{"location":"api-reference/#strutex.processor.DocumentProcessor.on_post_process","title":"<code>on_post_process(func: PostProcessCallback) -&gt; PostProcessCallback</code>","text":"<p>Decorator to register a post-process hook.</p> <p>The hook receives (result, context) and can return a modified result dict.</p> Example <pre><code>@processor.on_post_process\ndef normalize_dates(result, context):\n    result[\"date\"] = parse_date(result.get(\"date\"))\n    return result\n</code></pre> Source code in <code>strutex/processor.py</code> <pre><code>def on_post_process(self, func: PostProcessCallback) -&gt; PostProcessCallback:\n    \"\"\"\n    Decorator to register a post-process hook.\n\n    The hook receives (result, context) and can return a modified result dict.\n\n    Example:\n        ```python\n        @processor.on_post_process\n        def normalize_dates(result, context):\n            result[\"date\"] = parse_date(result.get(\"date\"))\n            return result\n        ```\n    \"\"\"\n    self._post_process_hooks.append(func)\n    self._hook_plugin_registered = False  # Force re-registration\n    return func\n</code></pre>"},{"location":"api-reference/#strutex.processor.DocumentProcessor.on_pre_process","title":"<code>on_pre_process(func: PreProcessCallback) -&gt; PreProcessCallback</code>","text":"<p>Decorator to register a pre-process hook.</p> <p>The hook receives (file_path, prompt, schema, mime_type, context) and can return a dict with modified values for 'prompt' or other parameters.</p> Example <pre><code>@processor.on_pre_process\ndef add_instructions(file_path, prompt, schema, mime_type, context):\n    return {\"prompt\": prompt + \"\\nBe precise.\"}\n</code></pre> Source code in <code>strutex/processor.py</code> <pre><code>def on_pre_process(self, func: PreProcessCallback) -&gt; PreProcessCallback:\n    \"\"\"\n    Decorator to register a pre-process hook.\n\n    The hook receives (file_path, prompt, schema, mime_type, context) and\n    can return a dict with modified values for 'prompt' or other parameters.\n\n    Example:\n        ```python\n        @processor.on_pre_process\n        def add_instructions(file_path, prompt, schema, mime_type, context):\n            return {\"prompt\": prompt + \"\\\\nBe precise.\"}\n        ```\n    \"\"\"\n    self._pre_process_hooks.append(func)\n    self._hook_plugin_registered = False  # Force re-registration\n    return func\n</code></pre>"},{"location":"api-reference/#strutex.processor.DocumentProcessor.process","title":"<code>process(file_path: str, prompt: str, schema: Optional[Schema] = None, model: Optional[Type] = None, security: Optional[Union[SecurityPlugin, bool]] = None, verify: bool = False, **kwargs) -&gt; Any</code>","text":"<p>Process a document and extract structured data.</p> <p>This method automatically detects the file type, applies security validation (if enabled), sends the document to the LLM provider, and validates the output.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>Absolute path to the source file (PDF, Excel, or Image).</p> <p> TYPE: <code>str</code> </p> <code>prompt</code> <p>Natural language instruction for extraction.</p> <p> TYPE: <code>str</code> </p> <code>schema</code> <p>A [<code>Schema</code>][strutex.Schema] definition. Mutually exclusive with <code>model</code>.</p> <p> TYPE: <code>Optional[Schema]</code> DEFAULT: <code>None</code> </p> <code>model</code> <p>A Pydantic <code>BaseModel</code> class. Mutually exclusive with <code>schema</code>. If provided, returns a validated Pydantic instance.</p> <p> TYPE: <code>Optional[Type]</code> DEFAULT: <code>None</code> </p> <code>security</code> <p>Override security setting for this request. - <code>True</code>: Use default security chain - <code>False</code>: Disable security - <code>SecurityPlugin</code>: Use custom security instance</p> <p> TYPE: <code>Optional[Union[SecurityPlugin, bool]]</code> DEFAULT: <code>None</code> </p> <code>verify</code> <p>If <code>True</code>, enables self-correction loop where the LLM audits its own result.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p>Additional arguments passed to the provider (e.g. <code>temperature</code>).</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>Extracted data as a dict (if <code>schema</code> used) or Pydantic model (if <code>model</code> used). - <code>SecurityPlugin</code>: Use specific plugin - <code>None</code>: Use processor default</p> <code>verify</code> <p>If True, performs a second pass to verify and correct the result.</p> <p> TYPE: <code>Any</code> </p> <code>context</code> <p>Optional ProcessingContext for state tracking.</p> <p> TYPE: <code>Any</code> </p> <code>Any</code> <p>**kwargs: Additional provider-specific options.</p> RETURNS DESCRIPTION <code>Any</code> <p>Extracted data as a dictionary, or a Pydantic model instance if <code>model</code></p> <code>Any</code> <p>was provided.</p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If <code>file_path</code> does not exist.</p> <code>ValueError</code> <p>If neither <code>schema</code> nor <code>model</code> is provided.</p> <code>SecurityError</code> <p>If security validation fails (input or output rejected).</p> Example <pre><code>result = processor.process(\n    file_path=\"invoice.pdf\",\n    prompt=\"Extract invoice number and total amount\",\n    schema=invoice_schema\n)\nprint(result[\"total\"])\n</code></pre> Source code in <code>strutex/processor.py</code> <pre><code>def process(\n    self,\n    file_path: str,\n    prompt: str,\n    schema: Optional[Schema] = None,\n    model: Optional[Type] = None,\n    security: Optional[Union[SecurityPlugin, bool]] = None,\n    verify: bool = False,\n    **kwargs\n) -&gt; Any:\n    \"\"\"\n    Process a document and extract structured data.\n\n    This method automatically detects the file type, applies security validation\n    (if enabled), sends the document to the LLM provider, and validates the output.\n\n    Args:\n        file_path: Absolute path to the source file (PDF, Excel, or Image).\n        prompt: Natural language instruction for extraction.\n        schema: A [`Schema`][strutex.Schema] definition. Mutually exclusive\n            with `model`.\n        model: A Pydantic `BaseModel` class. Mutually exclusive with `schema`.\n            If provided, returns a validated Pydantic instance.\n        security: Override security setting for this request.\n            - `True`: Use default security chain\n            - `False`: Disable security\n            - `SecurityPlugin`: Use custom security instance\n        verify: If `True`, enables self-correction loop where the LLM audits its own\n            result.\n        **kwargs: Additional arguments passed to the provider (e.g. `temperature`).\n\n    Returns:\n        Extracted data as a dict (if `schema` used) or Pydantic model (if `model` used).\n            - `SecurityPlugin`: Use specific plugin\n            - `None`: Use processor default\n        verify: If True, performs a second pass to verify and correct the result.\n        context: Optional ProcessingContext for state tracking.\n        **kwargs: Additional provider-specific options.\n\n    Returns:\n        Extracted data as a dictionary, or a Pydantic model instance if `model`\n        was provided.\n\n    Raises:\n        FileNotFoundError: If `file_path` does not exist.\n        ValueError: If neither `schema` nor `model` is provided.\n        SecurityError: If security validation fails (input or output rejected).\n\n    Example:\n        ```python\n        result = processor.process(\n            file_path=\"invoice.pdf\",\n            prompt=\"Extract invoice number and total amount\",\n            schema=invoice_schema\n        )\n        print(result[\"total\"])\n        ```\n    \"\"\"\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"File not found: {file_path}\")\n\n    # Ensure hooks are registered with pluggy\n    self._ensure_hooks_registered()\n\n    # Handle Pydantic model\n    pydantic_model = None\n    if model is not None:\n        from .pydantic_support import pydantic_to_schema\n        schema = pydantic_to_schema(model)\n        pydantic_model = model\n\n    if schema is None:\n        raise ValueError(\"Either 'schema' or 'model' must be provided\")\n\n    # Detect MIME type\n    mime_type = get_mime_type(file_path)\n\n    # Create context for hooks\n    context: Dict[str, Any] = {\n        \"file_path\": file_path,\n        \"mime_type\": mime_type,\n        \"kwargs\": kwargs,\n    }\n\n    # Run pre-process hooks via pluggy\n    from .plugins.hooks import call_hook\n    pre_results = call_hook(\n        \"pre_process\",\n        file_path=file_path,\n        prompt=prompt,\n        schema=schema,\n        mime_type=mime_type,\n        context=context\n    )\n    # Apply any prompt modifications from hooks\n    for hook_result in pre_results:\n        if hook_result and isinstance(hook_result, dict) and \"prompt\" in hook_result:\n            prompt = hook_result[\"prompt\"]\n\n    # Handle security\n    effective_security = self._resolve_security(security)\n\n    # Apply input security if enabled\n    if effective_security:\n        input_result = effective_security.validate_input(prompt)\n        if not input_result.valid:\n            raise SecurityError(f\"Input rejected: {input_result.reason}\")\n        prompt = input_result.text or prompt\n\n    # Check cache if enabled\n    cache_key = None\n    if self.cache is not None:\n        from .cache import CacheKey\n        cache_key = CacheKey.create(\n            file_path=file_path,\n            prompt=prompt,\n            schema=schema,\n            provider=self.provider_name,\n            model=getattr(self._provider, 'model', None),\n        )\n        cached_result = self.cache.get(cache_key)\n        if cached_result is not None:\n            logger.debug(f\"Cache hit for {file_path}\")\n            # Still run post-process hooks on cached results\n            if isinstance(cached_result, dict):\n                post_results = call_hook(\n                    \"post_process\",\n                    result=cached_result,\n                    context=context\n                )\n                for hook_result in post_results:\n                    if hook_result is not None and isinstance(hook_result, dict):\n                        cached_result = hook_result\n            # Validate with Pydantic if needed\n            if pydantic_model is not None:\n                from .pydantic_support import validate_with_pydantic\n                cached_result = validate_with_pydantic(cached_result, pydantic_model)\n            return cached_result\n\n    # Process with provider (with error handling)\n    try:\n        result = self._provider.process(\n            file_path=file_path,\n            prompt=prompt,\n            schema=schema,\n            mime_type=mime_type,\n            **kwargs\n        )\n\n        # Store in cache if enabled\n        if self.cache is not None and cache_key is not None:\n            self.cache.set(cache_key, result)\n            logger.debug(f\"Cached result for {file_path}\")\n\n    except Exception as e:\n        # Run error hooks via pluggy\n        error_results = call_hook(\n            \"on_error\",\n            error=e,\n            file_path=file_path,\n            context=context\n        )\n        # Use first non-None fallback\n        fallback = None\n        for hook_result in error_results:\n            if hook_result is not None:\n                fallback = hook_result\n                break\n\n        if fallback is not None:\n            result = fallback\n        else:\n            raise  # Re-raise if no hook handled it\n\n    # Apply output security if enabled\n    if effective_security and isinstance(result, dict):\n        output_result = effective_security.validate_output(result)\n        if not output_result.valid:\n            raise SecurityError(f\"Output rejected: {output_result.reason}\")\n        result = output_result.data or result\n\n    # Run post-process hooks via pluggy\n    if isinstance(result, dict):\n        post_results = call_hook(\n            \"post_process\",\n            result=result,\n            context=context\n        )\n        # Apply modifications from hooks\n        for hook_result in post_results:\n            if hook_result is not None and isinstance(hook_result, dict):\n                result = hook_result\n\n    # Validate with Pydantic if model was provided\n    if pydantic_model is not None:\n        from .pydantic_support import validate_with_pydantic\n        result = validate_with_pydantic(result, pydantic_model)\n\n    # Optional Verification Step\n    if verify:\n        result = self.verify(file_path, result, schema=schema, model=model, **kwargs)\n\n    return result\n</code></pre>"},{"location":"api-reference/#strutex.processor.DocumentProcessor.process_batch","title":"<code>process_batch(file_paths: List[str], prompt: str, schema: Optional[Schema] = None, model: Optional[Type] = None, max_workers: int = 4, **kwargs) -&gt; BatchContext</code>","text":"<p>Process multiple documents in parallel using threads.</p> PARAMETER DESCRIPTION <code>file_paths</code> <p>List of file paths to process</p> <p> TYPE: <code>List[str]</code> </p> <code>prompt</code> <p>Extraction prompt</p> <p> TYPE: <code>str</code> </p> <code>schema</code> <p>Output schema</p> <p> TYPE: <code>Optional[Schema]</code> DEFAULT: <code>None</code> </p> <code>model</code> <p>Pydantic model</p> <p> TYPE: <code>Optional[Type]</code> DEFAULT: <code>None</code> </p> <code>max_workers</code> <p>Number of concurrent threads</p> <p> TYPE: <code>int</code> DEFAULT: <code>4</code> </p> <code>**kwargs</code> <p>Provider options</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>BatchContext</code> <p>BatchContext containing results and stats</p> Source code in <code>strutex/processor.py</code> <pre><code>def process_batch(\n    self,\n    file_paths: List[str],\n    prompt: str,\n    schema: Optional[Schema] = None,\n    model: Optional[Type] = None,\n    max_workers: int = 4,\n    **kwargs\n) -&gt; BatchContext:\n    \"\"\"\n    Process multiple documents in parallel using threads.\n\n    Args:\n        file_paths: List of file paths to process\n        prompt: Extraction prompt\n        schema: Output schema\n        model: Pydantic model\n        max_workers: Number of concurrent threads\n        **kwargs: Provider options\n\n    Returns:\n        BatchContext containing results and stats\n    \"\"\"\n    import concurrent.futures\n    from .context import BatchContext\n\n    batch_ctx = BatchContext(total_documents=len(file_paths))\n\n    def _process_one(path: str):\n        try:\n            result = self.process(path, prompt, schema, model, **kwargs)\n            batch_ctx.add_result(path, result)\n        except Exception as e:\n            batch_ctx.add_error(path, e)\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:\n        executor.map(_process_one, file_paths)\n\n    return batch_ctx\n</code></pre>"},{"location":"api-reference/#strutex.processor.DocumentProcessor.verify","title":"<code>verify(file_path: str, result: Any, schema: Optional[Schema] = None, model: Optional[Type] = None, verify_prompt: Optional[str] = None, **kwargs) -&gt; Any</code>","text":"<p>Verify the extracted result against the document.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>Path to the source document</p> <p> TYPE: <code>str</code> </p> <code>result</code> <p>The result to verify (dict or Pydantic model)</p> <p> TYPE: <code>Any</code> </p> <code>schema</code> <p>The schema used for extraction</p> <p> TYPE: <code>Optional[Schema]</code> DEFAULT: <code>None</code> </p> <code>model</code> <p>The Pydantic model used for extraction</p> <p> TYPE: <code>Optional[Type]</code> DEFAULT: <code>None</code> </p> <code>verify_prompt</code> <p>Optional custom verification prompt</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Provider options</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>Verified (and potentially corrected) result</p> Source code in <code>strutex/processor.py</code> <pre><code>def verify(\n    self,\n    file_path: str,\n    result: Any,\n    schema: Optional[Schema] = None,\n    model: Optional[Type] = None,\n    verify_prompt: Optional[str] = None,\n    **kwargs\n) -&gt; Any:\n    \"\"\"\n    Verify the extracted result against the document.\n\n    Args:\n        file_path: Path to the source document\n        result: The result to verify (dict or Pydantic model)\n        schema: The schema used for extraction\n        model: The Pydantic model used for extraction\n        verify_prompt: Optional custom verification prompt\n        **kwargs: Provider options\n\n    Returns:\n        Verified (and potentially corrected) result\n    \"\"\"\n    import json\n\n    # Prepare verification prompt\n    if verify_prompt is None:\n        verify_prompt = (\n            \"You are a strict data auditor. Your task is to verify the extracted data \"\n            \"against the document provided. \\n\"\n            \"Review the data below. If it contains errors or missing fields that exist \"\n            \"in the document, CORRECT them. If the data is correct, return it as is.\\n\"\n            \"Return the final validated JSON strictly adhering to the schema.\"\n        )\n\n    # Serialize result for prompt\n    if hasattr(result, \"model_dump_json\"):\n        result_str = result.model_dump_json()\n    elif isinstance(result, dict):\n        result_str = json.dumps(result, default=str)\n    else:\n        result_str = str(result)\n\n    full_prompt = f\"{verify_prompt}\\n\\n[EXTRACTED DATA TO VERIFY]:\\n{result_str}\"\n\n    # Call process recursively but disable verification to avoid loop\n    return self.process(\n        file_path=file_path,\n        prompt=full_prompt,\n        schema=schema,\n        model=model,\n        verify=False,\n        **kwargs\n    )\n</code></pre>"},{"location":"api-reference/#schema-types","title":"Schema Types","text":"<p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p>"},{"location":"api-reference/#strutex.types.String","title":"<code>String(description: str = None, nullable: bool = False)</code>","text":"<p>               Bases: <code>Schema</code></p> Source code in <code>strutex/types.py</code> <pre><code>def __init__(self, description: str = None, nullable: bool = False):\n    super().__init__(Type.STRING, description=description, nullable=nullable)\n</code></pre>"},{"location":"api-reference/#strutex.types.Number","title":"<code>Number(description: str = None, nullable: bool = False)</code>","text":"<p>               Bases: <code>Schema</code></p> Source code in <code>strutex/types.py</code> <pre><code>def __init__(self, description: str = None, nullable: bool = False):\n    super().__init__(Type.NUMBER, description=description, nullable=nullable)\n</code></pre>"},{"location":"api-reference/#strutex.types.Integer","title":"<code>Integer(description: str = None, nullable: bool = False)</code>","text":"<p>               Bases: <code>Schema</code></p> Source code in <code>strutex/types.py</code> <pre><code>def __init__(self, description: str = None, nullable: bool = False):\n    super().__init__(Type.INTEGER, description=description, nullable=nullable)\n</code></pre>"},{"location":"api-reference/#strutex.types.Boolean","title":"<code>Boolean(description: str = None, nullable: bool = False)</code>","text":"<p>               Bases: <code>Schema</code></p> Source code in <code>strutex/types.py</code> <pre><code>def __init__(self, description: str = None, nullable: bool = False):\n    super().__init__(Type.BOOLEAN, description=description, nullable=nullable)\n</code></pre>"},{"location":"api-reference/#strutex.types.Array","title":"<code>Array(items: Schema, description: str = None, nullable: bool = False)</code>","text":"<p>               Bases: <code>Schema</code></p> <p>Represents a list of items. :param items: The Schema definition for the items inside the array.</p> Source code in <code>strutex/types.py</code> <pre><code>def __init__(self, items: Schema, description: str = None, nullable: bool = False):\n    \"\"\"\n    Represents a list of items.\n    :param items: The Schema definition for the items inside the array.\n    \"\"\"\n    super().__init__(Type.ARRAY, items=items, description=description, nullable=nullable)\n</code></pre>"},{"location":"api-reference/#strutex.types.Object","title":"<code>Object(properties: Dict[str, Schema], description: str = None, required: Optional[List[str]] = None, nullable: bool = False)</code>","text":"<p>               Bases: <code>Schema</code></p> <p>Represents a nested object (dictionary).</p> <p>:param properties: Dictionary mapping field names to Schema objects. :param required: List of keys that are mandatory.                  If None, ALL properties are assumed required.                  Pass [] explicitly if no fields are required.</p> Source code in <code>strutex/types.py</code> <pre><code>def __init__(\n        self,\n        properties: Dict[str, Schema],\n        description: str = None,\n        required: Optional[List[str]] = None,\n        nullable: bool = False\n):\n    \"\"\"\n    Represents a nested object (dictionary).\n\n    :param properties: Dictionary mapping field names to Schema objects.\n    :param required: List of keys that are mandatory.\n                     If None, ALL properties are assumed required.\n                     Pass [] explicitly if no fields are required.\n    \"\"\"\n    # Smart Default: If 'required' is missing, assume strict mode (all fields required)\n    if required is None:\n        calculated_required = list(properties.keys())\n    else:\n        calculated_required = required\n\n    super().__init__(\n        Type.OBJECT,\n        properties=properties,\n        description=description,\n        required=calculated_required,\n        nullable=nullable\n    )\n</code></pre>"},{"location":"api-reference/#plugin-system","title":"Plugin System","text":"<p>options: show_root_heading: true members: - register - get - list - discover</p> <p>options: show_root_heading: true</p>"},{"location":"api-reference/#strutex.plugins.registry.PluginRegistry","title":"<code>PluginRegistry</code>","text":"<p>Central registry for all plugin types with lazy loading.</p> <p>Plugins are stored as EntryPoint objects and only loaded when first accessed via get(). This improves startup time and avoids importing unused dependencies.</p> Usage"},{"location":"api-reference/#strutex.plugins.registry.PluginRegistry--get-a-plugin-loads-on-first-access","title":"Get a plugin (loads on first access)","text":"<p>cls = PluginRegistry.get(\"provider\", \"gemini\")</p>"},{"location":"api-reference/#strutex.plugins.registry.PluginRegistry--list-all-plugins-does-not-load-them","title":"List all plugins (does not load them)","text":"<p>all_providers = PluginRegistry.list(\"provider\")</p>"},{"location":"api-reference/#strutex.plugins.registry.PluginRegistry--force-discovery-from-entry-points","title":"Force discovery from entry points","text":"<p>count = PluginRegistry.discover()</p>"},{"location":"api-reference/#strutex.plugins.registry.PluginRegistry.clear","title":"<code>clear(plugin_type: Optional[str] = None) -&gt; None</code>  <code>classmethod</code>","text":"<p>Clear registered plugins.</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>If provided, only clear this type. Otherwise clear all.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef clear(cls, plugin_type: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Clear registered plugins.\n\n    Args:\n        plugin_type: If provided, only clear this type. Otherwise clear all.\n    \"\"\"\n    if plugin_type:\n        cls._entry_points.pop(plugin_type, None)\n        cls._loaded.pop(plugin_type, None)\n        cls._manual.pop(plugin_type, None)\n    else:\n        cls._entry_points.clear()\n        cls._loaded.clear()\n        cls._manual.clear()\n        cls._discovered = False\n</code></pre>"},{"location":"api-reference/#strutex.plugins.registry.PluginRegistry.discover","title":"<code>discover(group_prefix: str = 'strutex', force: bool = False) -&gt; int</code>  <code>classmethod</code>","text":"<p>Discover and register plugins from entry points.</p> <p>Scans for entry points matching the pattern: - strutex.providers - strutex.validators - strutex.postprocessors - strutex.security - etc.</p> <p>Entry points are stored for lazy loading - they are not imported until first use via get().</p> PARAMETER DESCRIPTION <code>group_prefix</code> <p>Entry point group prefix (default: \"strutex\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'strutex'</code> </p> <code>force</code> <p>Force re-discovery even if already discovered</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>int</code> <p>Number of entry points discovered</p> <p>Example pyproject.toml:     [project.entry-points.\"strutex.providers\"]     my_provider = \"my_package:MyProvider\"</p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef discover(cls, group_prefix: str = \"strutex\", force: bool = False) -&gt; int:\n    \"\"\"\n    Discover and register plugins from entry points.\n\n    Scans for entry points matching the pattern:\n    - strutex.providers\n    - strutex.validators\n    - strutex.postprocessors\n    - strutex.security\n    - etc.\n\n    Entry points are stored for lazy loading - they are not imported\n    until first use via get().\n\n    Args:\n        group_prefix: Entry point group prefix (default: \"strutex\")\n        force: Force re-discovery even if already discovered\n\n    Returns:\n        Number of entry points discovered\n\n    Example pyproject.toml:\n        [project.entry-points.\"strutex.providers\"]\n        my_provider = \"my_package:MyProvider\"\n    \"\"\"\n    if cls._discovered and not force:\n        return sum(len(eps) for eps in cls._entry_points.values())\n\n    discovered = 0\n\n    # Get entry_points function\n    if sys.version_info &gt;= (3, 10):\n        from importlib.metadata import entry_points\n    else:\n        try:\n            from importlib_metadata import entry_points\n        except ImportError:\n            cls._discovered = True\n            return 0\n\n    # Get all entry point groups\n    try:\n        all_eps = entry_points()\n\n        # Get group names that match our prefix\n        if hasattr(all_eps, 'groups'):\n            # Python 3.12+ style\n            groups = [g for g in all_eps.groups if g.startswith(f\"{group_prefix}.\")]\n        elif hasattr(all_eps, 'keys'):\n            # Python 3.9-3.11 style (dict-like)\n            groups = [g for g in all_eps.keys() if g.startswith(f\"{group_prefix}.\")]\n        else:\n            groups = []\n    except Exception:\n        cls._discovered = True\n        return 0\n\n    for group in groups:\n        # Extract plugin type from group name\n        # e.g., \"strutex.providers\" -&gt; \"provider\"\n        plugin_type = group.replace(f\"{group_prefix}.\", \"\").rstrip(\"s\")\n\n        if plugin_type not in cls._entry_points:\n            cls._entry_points[plugin_type] = {}\n\n        try:\n            # Get entry points for this group\n            if hasattr(all_eps, 'select'):\n                eps = all_eps.select(group=group)\n            else:\n                eps = all_eps.get(group, [])\n\n            for ep in eps:\n                # Store entry point for lazy loading\n                cls._entry_points[plugin_type][ep.name.lower()] = ep\n                discovered += 1\n\n        except Exception:\n            pass\n\n    cls._discovered = True\n    return discovered\n</code></pre>"},{"location":"api-reference/#strutex.plugins.registry.PluginRegistry.get","title":"<code>get(plugin_type: str, name: str) -&gt; Optional[Type]</code>  <code>classmethod</code>","text":"<p>Get a registered plugin class by type and name.</p> <p>If the plugin is registered via entry point and not yet loaded, it will be loaded on first access (lazy loading).</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>Type of plugin</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name of the plugin</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Optional[Type]</code> <p>The plugin class, or None if not found</p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef get(cls, plugin_type: str, name: str) -&gt; Optional[Type]:\n    \"\"\"\n    Get a registered plugin class by type and name.\n\n    If the plugin is registered via entry point and not yet loaded,\n    it will be loaded on first access (lazy loading).\n\n    Args:\n        plugin_type: Type of plugin\n        name: Name of the plugin\n\n    Returns:\n        The plugin class, or None if not found\n    \"\"\"\n    name_lower = name.lower()\n\n    # Ensure discovery has run\n    if not cls._discovered:\n        cls.discover()\n\n    # Check loaded cache first\n    if name_lower in cls._loaded.get(plugin_type, {}):\n        return cls._loaded[plugin_type][name_lower]\n\n    # Check manual registrations\n    if name_lower in cls._manual.get(plugin_type, {}):\n        return cls._manual[plugin_type][name_lower]\n\n    # Try to lazy load from entry point\n    ep = cls._entry_points.get(plugin_type, {}).get(name_lower)\n    if ep is not None:\n        plugin_cls = cls._load_entry_point(ep, plugin_type, name_lower)\n        if plugin_cls is not None:\n            return plugin_cls\n\n    return None\n</code></pre>"},{"location":"api-reference/#strutex.plugins.registry.PluginRegistry.get_plugin_info","title":"<code>get_plugin_info(plugin_type: str, name: str) -&gt; Optional[Dict[str, Any]]</code>  <code>classmethod</code>","text":"<p>Get metadata about a plugin without necessarily loading it.</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>Type of plugin</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name of the plugin</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Optional[Dict[str, Any]]</code> <p>Dict with plugin info, or None if not found</p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef get_plugin_info(cls, plugin_type: str, name: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"\n    Get metadata about a plugin without necessarily loading it.\n\n    Args:\n        plugin_type: Type of plugin\n        name: Name of the plugin\n\n    Returns:\n        Dict with plugin info, or None if not found\n    \"\"\"\n    name_lower = name.lower()\n\n    if not cls._discovered:\n        cls.discover()\n\n    # Check if loaded\n    if name_lower in cls._loaded.get(plugin_type, {}):\n        plugin_cls = cls._loaded[plugin_type][name_lower]\n        return {\n            \"name\": name_lower,\n            \"version\": getattr(plugin_cls, \"strutex_plugin_version\", \"unknown\"),\n            \"priority\": getattr(plugin_cls, \"priority\", 50),\n            \"cost\": getattr(plugin_cls, \"cost\", 1.0),\n            \"capabilities\": getattr(plugin_cls, \"capabilities\", []),\n            \"loaded\": True,\n            \"healthy\": cls._check_health(plugin_cls),\n        }\n\n    # Check entry point\n    ep = cls._entry_points.get(plugin_type, {}).get(name_lower)\n    if ep is not None:\n        return {\n            \"name\": name_lower,\n            \"entry_point\": f\"{ep.group}:{ep.name}\",\n            \"loaded\": False,\n            \"healthy\": None,  # Unknown until loaded\n        }\n\n    return None\n</code></pre>"},{"location":"api-reference/#strutex.plugins.registry.PluginRegistry.get_sorted","title":"<code>get_sorted(plugin_type: str, reverse: bool = True) -&gt; List[Tuple[str, Type]]</code>  <code>classmethod</code>","text":"<p>Get all plugins of a type sorted by priority.</p> <p>Useful for waterfall selection where you want to try higher-priority plugins first.</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>Type of plugin</p> <p> TYPE: <code>str</code> </p> <code>reverse</code> <p>If True (default), higher priority first</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>List[Tuple[str, Type]]</code> <p>List of (name, class) tuples sorted by priority</p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef get_sorted(cls, plugin_type: str, reverse: bool = True) -&gt; List[Tuple[str, Type]]:\n    \"\"\"\n    Get all plugins of a type sorted by priority.\n\n    Useful for waterfall selection where you want to try\n    higher-priority plugins first.\n\n    Args:\n        plugin_type: Type of plugin\n        reverse: If True (default), higher priority first\n\n    Returns:\n        List of (name, class) tuples sorted by priority\n    \"\"\"\n    plugins = cls.list(plugin_type)\n    return sorted(\n        plugins.items(),\n        key=lambda x: getattr(x[1], 'priority', 50),\n        reverse=reverse\n    )\n</code></pre>"},{"location":"api-reference/#strutex.plugins.registry.PluginRegistry.list","title":"<code>list(plugin_type: str) -&gt; Dict[str, Type]</code>  <code>classmethod</code>","text":"<p>List all plugins of a given type.</p> <p>Note: This loads all plugins of the type. Use list_names() for a lightweight listing without loading.</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>Type of plugin</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Dict[str, Type]</code> <p>Dictionary mapping names to plugin classes</p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef list(cls, plugin_type: str) -&gt; Dict[str, Type]:\n    \"\"\"\n    List all plugins of a given type.\n\n    Note: This loads all plugins of the type. Use list_names()\n    for a lightweight listing without loading.\n\n    Args:\n        plugin_type: Type of plugin\n\n    Returns:\n        Dictionary mapping names to plugin classes\n    \"\"\"\n    if not cls._discovered:\n        cls.discover()\n\n    result = {}\n\n    # Get all names from entry points and manual registrations\n    all_names = set()\n    all_names.update(cls._entry_points.get(plugin_type, {}).keys())\n    all_names.update(cls._manual.get(plugin_type, {}).keys())\n    all_names.update(cls._loaded.get(plugin_type, {}).keys())\n\n    # Load each plugin\n    for name in all_names:\n        plugin_cls = cls.get(plugin_type, name)\n        if plugin_cls is not None:\n            result[name] = plugin_cls\n\n    return result\n</code></pre>"},{"location":"api-reference/#strutex.plugins.registry.PluginRegistry.list_names","title":"<code>list_names(plugin_type: str) -&gt; List[str]</code>  <code>classmethod</code>","text":"<p>List names of all plugins of a given type without loading them.</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>Type of plugin</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>List[str]</code> <p>List of plugin names</p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef list_names(cls, plugin_type: str) -&gt; List[str]:\n    \"\"\"\n    List names of all plugins of a given type without loading them.\n\n    Args:\n        plugin_type: Type of plugin\n\n    Returns:\n        List of plugin names\n    \"\"\"\n    if not cls._discovered:\n        cls.discover()\n\n    names = set()\n    names.update(cls._entry_points.get(plugin_type, {}).keys())\n    names.update(cls._manual.get(plugin_type, {}).keys())\n    names.update(cls._loaded.get(plugin_type, {}).keys())\n\n    return sorted(names)\n</code></pre>"},{"location":"api-reference/#strutex.plugins.registry.PluginRegistry.list_types","title":"<code>list_types() -&gt; List[str]</code>  <code>classmethod</code>","text":"<p>List all registered plugin types.</p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef list_types(cls) -&gt; List[str]:\n    \"\"\"List all registered plugin types.\"\"\"\n    if not cls._discovered:\n        cls.discover()\n\n    types = set()\n    types.update(cls._entry_points.keys())\n    types.update(cls._manual.keys())\n    types.update(cls._loaded.keys())\n\n    return sorted(types)\n</code></pre>"},{"location":"api-reference/#strutex.plugins.registry.PluginRegistry.register","title":"<code>register(plugin_type: str, name: str, plugin_cls: Type) -&gt; None</code>  <code>classmethod</code>","text":"<p>Register a plugin class manually.</p> <p>This is used by the @register decorator for backwards compatibility. Prefer using entry points in pyproject.toml for new plugins.</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>Type of plugin (e.g., \"provider\", \"security\", \"validator\")</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Unique name for this plugin</p> <p> TYPE: <code>str</code> </p> <code>plugin_cls</code> <p>The plugin class to register</p> <p> TYPE: <code>Type</code> </p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef register(cls, plugin_type: str, name: str, plugin_cls: Type) -&gt; None:\n    \"\"\"\n    Register a plugin class manually.\n\n    This is used by the @register decorator for backwards compatibility.\n    Prefer using entry points in pyproject.toml for new plugins.\n\n    Args:\n        plugin_type: Type of plugin (e.g., \"provider\", \"security\", \"validator\")\n        name: Unique name for this plugin\n        plugin_cls: The plugin class to register\n    \"\"\"\n    if plugin_type not in cls._manual:\n        cls._manual[plugin_type] = {}\n\n    cls._manual[plugin_type][name.lower()] = plugin_cls\n\n    # Also add to loaded cache\n    if plugin_type not in cls._loaded:\n        cls._loaded[plugin_type] = {}\n    cls._loaded[plugin_type][name.lower()] = plugin_cls\n</code></pre>"},{"location":"api-reference/#strutex.plugins.registry.register","title":"<code>register(plugin_type: str, name: Optional[str] = None) -&gt; Callable[[Type], Type]</code>","text":"<p>Decorator to register a plugin class at runtime.</p> <p>Use this decorator for: - Runtime/dynamic registration based on config - Prototyping plugins without packaging - Plugins in the same codebase (not installed separately) - Conditional loading based on environment or feature flags</p> <p>For distributable third-party plugin packages, use entry points in pyproject.toml instead.</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>Type of plugin (e.g., \"provider\", \"security\", \"validator\")</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Optional name. If not provided, uses lowercase class name.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Usage <p>@register(\"provider\") class MyProvider(Provider):     ...</p> <p>@register(\"provider\", name=\"custom_name\") class AnotherProvider(Provider):     ...</p> See Also <p>Entry points in pyproject.toml for distributable packages:</p> <pre><code>[project.entry-points.\"strutex.providers\"]\nmy_provider = \"my_package:MyProvider\"\n</code></pre> Source code in <code>strutex/plugins/registry.py</code> <pre><code>def register(\n    plugin_type: str,\n    name: Optional[str] = None,\n) -&gt; Callable[[Type], Type]:\n    \"\"\"\n    Decorator to register a plugin class at runtime.\n\n    Use this decorator for:\n    - Runtime/dynamic registration based on config\n    - Prototyping plugins without packaging\n    - Plugins in the same codebase (not installed separately)\n    - Conditional loading based on environment or feature flags\n\n    For distributable third-party plugin packages, use entry points\n    in pyproject.toml instead.\n\n    Args:\n        plugin_type: Type of plugin (e.g., \"provider\", \"security\", \"validator\")\n        name: Optional name. If not provided, uses lowercase class name.\n\n    Usage:\n        @register(\"provider\")\n        class MyProvider(Provider):\n            ...\n\n        @register(\"provider\", name=\"custom_name\")\n        class AnotherProvider(Provider):\n            ...\n\n    See Also:\n        Entry points in pyproject.toml for distributable packages:\n\n            [project.entry-points.\"strutex.providers\"]\n            my_provider = \"my_package:MyProvider\"\n    \"\"\"\n    def decorator(cls: Type) -&gt; Type:\n        plugin_name = name if name else cls.__name__.lower()\n        PluginRegistry.register(plugin_type, plugin_name, cls)\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"api-reference/#base-classes","title":"Base Classes","text":"<p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p>"},{"location":"api-reference/#strutex.plugins.base.Provider","title":"<code>Provider</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for LLM providers.</p> <p>All providers must implement the process method to handle document extraction via their specific LLM API.</p> <p>Subclassing auto-registers the plugin. Use class arguments to customize:</p> <pre><code>class MyProvider(Provider, name=\"custom\", priority=90):\n    ...\n</code></pre> ATTRIBUTE DESCRIPTION <code>strutex_plugin_version</code> <p>API version for compatibility checks</p> <p> TYPE: <code>str</code> </p> <code>priority</code> <p>Ordering priority (0-100, higher = preferred)</p> <p> TYPE: <code>int</code> </p> <code>cost</code> <p>Cost hint for optimization (lower = cheaper)</p> <p> TYPE: <code>float</code> </p> <code>capabilities</code> <p>List of supported features</p> <p> TYPE: <code>List[str]</code> </p>"},{"location":"api-reference/#strutex.plugins.base.Provider.aprocess","title":"<code>aprocess(file_path: str, prompt: str, schema: Schema, mime_type: str, **kwargs) -&gt; Any</code>  <code>async</code>","text":"<p>Async version of process. Override for true async support. Default implementation calls sync version.</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>async def aprocess(\n    self,\n    file_path: str,\n    prompt: str,\n    schema: Schema,\n    mime_type: str,\n    **kwargs\n) -&gt; Any:\n    \"\"\"\n    Async version of process. Override for true async support.\n    Default implementation calls sync version.\n    \"\"\"\n    return self.process(file_path, prompt, schema, mime_type, **kwargs)\n</code></pre>"},{"location":"api-reference/#strutex.plugins.base.Provider.has_capability","title":"<code>has_capability(capability: str) -&gt; bool</code>","text":"<p>Check if this provider has a specific capability.</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>def has_capability(self, capability: str) -&gt; bool:\n    \"\"\"Check if this provider has a specific capability.\"\"\"\n    return capability.lower() in [c.lower() for c in self.capabilities]\n</code></pre>"},{"location":"api-reference/#strutex.plugins.base.Provider.health_check","title":"<code>health_check() -&gt; bool</code>  <code>classmethod</code>","text":"<p>Check if this provider is healthy and ready to use.</p> <p>Override in subclasses for custom health checks (e.g., API connectivity).</p> RETURNS DESCRIPTION <code>bool</code> <p>True if healthy, False otherwise</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>@classmethod\ndef health_check(cls) -&gt; bool:\n    \"\"\"\n    Check if this provider is healthy and ready to use.\n\n    Override in subclasses for custom health checks (e.g., API connectivity).\n\n    Returns:\n        True if healthy, False otherwise\n    \"\"\"\n    return True\n</code></pre>"},{"location":"api-reference/#strutex.plugins.base.Provider.process","title":"<code>process(file_path: str, prompt: str, schema: Schema, mime_type: str, **kwargs) -&gt; Any</code>  <code>abstractmethod</code>","text":"<p>Process a document and extract structured data.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>Path to the document file</p> <p> TYPE: <code>str</code> </p> <code>prompt</code> <p>Extraction prompt/instructions</p> <p> TYPE: <code>str</code> </p> <code>schema</code> <p>Expected output schema</p> <p> TYPE: <code>Schema</code> </p> <code>mime_type</code> <p>MIME type of the file</p> <p> TYPE: <code>str</code> </p> <code>**kwargs</code> <p>Provider-specific options</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>Extracted data matching the schema</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>@abstractmethod\ndef process(\n    self,\n    file_path: str,\n    prompt: str,\n    schema: Schema,\n    mime_type: str,\n    **kwargs\n) -&gt; Any:\n    \"\"\"\n    Process a document and extract structured data.\n\n    Args:\n        file_path: Path to the document file\n        prompt: Extraction prompt/instructions\n        schema: Expected output schema\n        mime_type: MIME type of the file\n        **kwargs: Provider-specific options\n\n    Returns:\n        Extracted data matching the schema\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/#strutex.plugins.base.Validator","title":"<code>Validator</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for output validators.</p> <p>Validators check extracted data for correctness and can optionally fix issues.</p> <p>Subclassing auto-registers the plugin.</p> ATTRIBUTE DESCRIPTION <code>strutex_plugin_version</code> <p>API version for compatibility checks</p> <p> TYPE: <code>str</code> </p> <code>priority</code> <p>Ordering priority in validation chain</p> <p> TYPE: <code>int</code> </p>"},{"location":"api-reference/#strutex.plugins.base.Validator.health_check","title":"<code>health_check() -&gt; bool</code>  <code>classmethod</code>","text":"<p>Check if this validator is healthy and ready.</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>@classmethod\ndef health_check(cls) -&gt; bool:\n    \"\"\"Check if this validator is healthy and ready.\"\"\"\n    return True\n</code></pre>"},{"location":"api-reference/#strutex.plugins.base.Validator.validate","title":"<code>validate(data: Dict[str, Any], schema: Optional[Schema] = None) -&gt; ValidationResult</code>  <code>abstractmethod</code>","text":"<p>Validate extracted data.</p> PARAMETER DESCRIPTION <code>data</code> <p>The extracted data to validate</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>schema</code> <p>Optional schema to validate against</p> <p> TYPE: <code>Optional[Schema]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValidationResult</code> <p>ValidationResult with status and any issues</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>@abstractmethod\ndef validate(self, data: Dict[str, Any], schema: Optional[Schema] = None) -&gt; \"ValidationResult\":\n    \"\"\"\n    Validate extracted data.\n\n    Args:\n        data: The extracted data to validate\n        schema: Optional schema to validate against\n\n    Returns:\n        ValidationResult with status and any issues\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/#strutex.plugins.base.Postprocessor","title":"<code>Postprocessor</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for data postprocessors.</p> <p>Postprocessors transform extracted data (e.g., normalize dates, convert currencies, standardize units).</p> <p>Subclassing auto-registers the plugin.</p> ATTRIBUTE DESCRIPTION <code>strutex_plugin_version</code> <p>API version for compatibility checks</p> <p> TYPE: <code>str</code> </p> <code>priority</code> <p>Ordering priority in postprocessing pipeline</p> <p> TYPE: <code>int</code> </p>"},{"location":"api-reference/#strutex.plugins.base.Postprocessor.health_check","title":"<code>health_check() -&gt; bool</code>  <code>classmethod</code>","text":"<p>Check if this postprocessor is healthy and ready.</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>@classmethod\ndef health_check(cls) -&gt; bool:\n    \"\"\"Check if this postprocessor is healthy and ready.\"\"\"\n    return True\n</code></pre>"},{"location":"api-reference/#strutex.plugins.base.Postprocessor.process","title":"<code>process(data: Dict[str, Any]) -&gt; Dict[str, Any]</code>  <code>abstractmethod</code>","text":"<p>Process/transform the extracted data.</p> PARAMETER DESCRIPTION <code>data</code> <p>The data to transform</p> <p> TYPE: <code>Dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Transformed data</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>@abstractmethod\ndef process(self, data: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"\n    Process/transform the extracted data.\n\n    Args:\n        data: The data to transform\n\n    Returns:\n        Transformed data\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/#strutex.plugins.base.SecurityPlugin","title":"<code>SecurityPlugin</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for security plugins.</p> <p>Security plugins can validate/sanitize input before sending to the LLM and validate output before returning to the user.</p> <p>Subclassing auto-registers the plugin.</p> ATTRIBUTE DESCRIPTION <code>strutex_plugin_version</code> <p>API version for compatibility checks</p> <p> TYPE: <code>str</code> </p> <code>priority</code> <p>Ordering priority in security chain</p> <p> TYPE: <code>int</code> </p>"},{"location":"api-reference/#strutex.plugins.base.SecurityPlugin.health_check","title":"<code>health_check() -&gt; bool</code>  <code>classmethod</code>","text":"<p>Check if this security plugin is healthy and ready.</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>@classmethod\ndef health_check(cls) -&gt; bool:\n    \"\"\"Check if this security plugin is healthy and ready.\"\"\"\n    return True\n</code></pre>"},{"location":"api-reference/#strutex.plugins.base.SecurityPlugin.validate_input","title":"<code>validate_input(text: str) -&gt; SecurityResult</code>","text":"<p>Validate/sanitize input text before sending to LLM.</p> PARAMETER DESCRIPTION <code>text</code> <p>The input text (prompt + document content)</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>SecurityResult</code> <p>SecurityResult with sanitized text or rejection</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>def validate_input(self, text: str) -&gt; \"SecurityResult\":\n    \"\"\"\n    Validate/sanitize input text before sending to LLM.\n\n    Args:\n        text: The input text (prompt + document content)\n\n    Returns:\n        SecurityResult with sanitized text or rejection\n    \"\"\"\n    return SecurityResult(valid=True, text=text)\n</code></pre>"},{"location":"api-reference/#strutex.plugins.base.SecurityPlugin.validate_output","title":"<code>validate_output(data: Dict[str, Any]) -&gt; SecurityResult</code>","text":"<p>Validate output data before returning to user.</p> PARAMETER DESCRIPTION <code>data</code> <p>The extracted data</p> <p> TYPE: <code>Dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>SecurityResult</code> <p>SecurityResult with clean data or rejection</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>def validate_output(self, data: Dict[str, Any]) -&gt; \"SecurityResult\":\n    \"\"\"\n    Validate output data before returning to user.\n\n    Args:\n        data: The extracted data\n\n    Returns:\n        SecurityResult with clean data or rejection\n    \"\"\"\n    return SecurityResult(valid=True, data=data)\n</code></pre>"},{"location":"api-reference/#security","title":"Security","text":"<p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p>"},{"location":"api-reference/#strutex.security.chain.SecurityChain","title":"<code>SecurityChain(plugins: List[SecurityPlugin])</code>","text":"<p>               Bases: <code>SecurityPlugin</code></p> <p>Chains multiple security plugins together.</p> <p>Runs each plugin in sequence. If any plugin rejects, the chain stops.</p> Usage <p>chain = SecurityChain([     InputSanitizer(collapse_whitespace=True),     PromptInjectionDetector(), ]) result = chain.validate_input(text)</p> PARAMETER DESCRIPTION <code>plugins</code> <p>List of security plugins to run in order</p> <p> TYPE: <code>List[SecurityPlugin]</code> </p> Source code in <code>strutex/security/chain.py</code> <pre><code>def __init__(self, plugins: List[SecurityPlugin]):\n    \"\"\"\n    Args:\n        plugins: List of security plugins to run in order\n    \"\"\"\n    self.plugins = plugins\n</code></pre>"},{"location":"api-reference/#strutex.security.chain.SecurityChain.add","title":"<code>add(plugin: SecurityPlugin) -&gt; SecurityChain</code>","text":"<p>Add a plugin to the chain. Returns self for chaining.</p> Source code in <code>strutex/security/chain.py</code> <pre><code>def add(self, plugin: SecurityPlugin) -&gt; \"SecurityChain\":\n    \"\"\"Add a plugin to the chain. Returns self for chaining.\"\"\"\n    self.plugins.append(plugin)\n    return self\n</code></pre>"},{"location":"api-reference/#strutex.security.chain.SecurityChain.validate_input","title":"<code>validate_input(text: str) -&gt; SecurityResult</code>","text":"<p>Run all plugins' input validation in sequence.</p> Source code in <code>strutex/security/chain.py</code> <pre><code>def validate_input(self, text: str) -&gt; SecurityResult:\n    \"\"\"Run all plugins' input validation in sequence.\"\"\"\n    current_text = text\n\n    for plugin in self.plugins:\n        result = plugin.validate_input(current_text)\n        if not result.valid:\n            return result\n        # Use possibly-sanitized text for next plugin\n        if result.text is not None:\n            current_text = result.text\n\n    return SecurityResult(valid=True, text=current_text)\n</code></pre>"},{"location":"api-reference/#strutex.security.chain.SecurityChain.validate_output","title":"<code>validate_output(data: Dict[str, Any]) -&gt; SecurityResult</code>","text":"<p>Run all plugins' output validation in sequence.</p> Source code in <code>strutex/security/chain.py</code> <pre><code>def validate_output(self, data: Dict[str, Any]) -&gt; SecurityResult:\n    \"\"\"Run all plugins' output validation in sequence.\"\"\"\n    current_data = data\n\n    for plugin in self.plugins:\n        result = plugin.validate_output(current_data)\n        if not result.valid:\n            return result\n        # Use possibly-modified data for next plugin\n        if result.data is not None:\n            current_data = result.data\n\n    return SecurityResult(valid=True, data=current_data)\n</code></pre>"},{"location":"api-reference/#strutex.security.sanitizer.InputSanitizer","title":"<code>InputSanitizer(collapse_whitespace: bool = True, normalize_unicode: bool = True, remove_invisible: bool = True, max_length: Optional[int] = None)</code>","text":"<p>               Bases: <code>SecurityPlugin</code></p> <p>Sanitizes input text to prevent various attacks.</p> <p>Features: - Collapse excessive whitespace - Normalize Unicode characters - Remove invisible characters - Limit input length</p> Usage <p>sanitizer = InputSanitizer(collapse_whitespace=True, max_length=50000) result = sanitizer.validate_input(text)</p> Source code in <code>strutex/security/sanitizer.py</code> <pre><code>def __init__(\n    self,\n    collapse_whitespace: bool = True,\n    normalize_unicode: bool = True,\n    remove_invisible: bool = True,\n    max_length: Optional[int] = None\n):\n    self.collapse_whitespace = collapse_whitespace\n    self.normalize_unicode = normalize_unicode\n    self.remove_invisible = remove_invisible\n    self.max_length = max_length\n</code></pre>"},{"location":"api-reference/#strutex.security.sanitizer.InputSanitizer.validate_input","title":"<code>validate_input(text: str) -&gt; SecurityResult</code>","text":"<p>Sanitize the input text.</p> Source code in <code>strutex/security/sanitizer.py</code> <pre><code>def validate_input(self, text: str) -&gt; SecurityResult:\n    \"\"\"Sanitize the input text.\"\"\"\n    sanitized = text\n\n    # Normalize Unicode (NFC form)\n    if self.normalize_unicode:\n        sanitized = unicodedata.normalize(\"NFC\", sanitized)\n\n    # Remove invisible characters (zero-width, etc.)\n    if self.remove_invisible:\n        # Remove zero-width characters and other invisibles\n        invisible_pattern = r'[\\u200b\\u200c\\u200d\\u2060\\u2061\\u2062\\u2063\\u2064\\ufeff]'\n        sanitized = re.sub(invisible_pattern, '', sanitized)\n\n    # Collapse whitespace (multiple spaces/newlines \u2192 single)\n    if self.collapse_whitespace:\n        # Collapse multiple spaces to single\n        sanitized = re.sub(r' {2,}', ' ', sanitized)\n        # Collapse multiple newlines to double (preserve paragraphs)\n        sanitized = re.sub(r'\\n{3,}', '\\n\\n', sanitized)\n        # Remove trailing whitespace per line\n        sanitized = re.sub(r' +$', '', sanitized, flags=re.MULTILINE)\n\n    # Enforce max length\n    if self.max_length and len(sanitized) &gt; self.max_length:\n        return SecurityResult(\n            valid=False,\n            text=None,\n            reason=f\"Input exceeds maximum length of {self.max_length} characters\"\n        )\n\n    return SecurityResult(valid=True, text=sanitized)\n</code></pre>"},{"location":"api-reference/#strutex.security.injection.PromptInjectionDetector","title":"<code>PromptInjectionDetector(strict: bool = False, additional_patterns: List[Tuple[str, str]] = None, block_on_detection: bool = True)</code>","text":"<p>               Bases: <code>SecurityPlugin</code></p> <p>Detects common prompt injection patterns.</p> <p>Checks for: - Direct instruction overrides (\"ignore previous instructions\") - Role manipulation (\"you are now\", \"pretend to be\") - Delimiter attacks (markdown, XML-style tags) - Encoding attacks (base64 instructions)</p> Usage <p>detector = PromptInjectionDetector(strict=True) result = detector.validate_input(text)</p> PARAMETER DESCRIPTION <code>strict</code> <p>If True, use stricter matching</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>additional_patterns</code> <p>Extra (pattern, category) tuples to check</p> <p> TYPE: <code>List[Tuple[str, str]]</code> DEFAULT: <code>None</code> </p> <code>block_on_detection</code> <p>If True, reject input on detection. If False, just warn.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>strutex/security/injection.py</code> <pre><code>def __init__(\n    self,\n    strict: bool = False,\n    additional_patterns: List[Tuple[str, str]] = None,\n    block_on_detection: bool = True\n):\n    \"\"\"\n    Args:\n        strict: If True, use stricter matching\n        additional_patterns: Extra (pattern, category) tuples to check\n        block_on_detection: If True, reject input on detection. If False, just warn.\n    \"\"\"\n    self.strict = strict\n    self.patterns = list(self.DEFAULT_PATTERNS)\n    if additional_patterns:\n        self.patterns.extend(additional_patterns)\n    self.block_on_detection = block_on_detection\n\n    # Compile patterns\n    flags = re.IGNORECASE\n    self._compiled = [(re.compile(p, flags), cat) for p, cat in self.patterns]\n</code></pre>"},{"location":"api-reference/#strutex.security.injection.PromptInjectionDetector.get_detections","title":"<code>get_detections(text: str) -&gt; List[dict]</code>","text":"<p>Get detailed detection information without blocking.</p> Source code in <code>strutex/security/injection.py</code> <pre><code>def get_detections(self, text: str) -&gt; List[dict]:\n    \"\"\"Get detailed detection information without blocking.\"\"\"\n    detections = []\n    for pattern, category in self._compiled:\n        matches = pattern.findall(text)\n        if matches:\n            detections.append({\n                \"category\": category,\n                \"pattern\": pattern.pattern,\n                \"matches\": matches[:5]  # Limit for safety\n            })\n    return detections\n</code></pre>"},{"location":"api-reference/#strutex.security.injection.PromptInjectionDetector.validate_input","title":"<code>validate_input(text: str) -&gt; SecurityResult</code>","text":"<p>Check for prompt injection patterns.</p> Source code in <code>strutex/security/injection.py</code> <pre><code>def validate_input(self, text: str) -&gt; SecurityResult:\n    \"\"\"Check for prompt injection patterns.\"\"\"\n    detections = []\n\n    for pattern, category in self._compiled:\n        matches = pattern.findall(text)\n        if matches:\n            detections.append({\n                \"category\": category,\n                \"pattern\": pattern.pattern,\n                \"count\": len(matches)\n            })\n\n    if detections:\n        if self.block_on_detection:\n            categories = list(set(d[\"category\"] for d in detections))\n            return SecurityResult(\n                valid=False,\n                text=None,\n                reason=f\"Potential prompt injection detected: {', '.join(categories)}\"\n            )\n        else:\n            # Allow but flag\n            return SecurityResult(\n                valid=True,\n                text=text,\n                reason=f\"Warning: potential injection patterns found\"\n            )\n\n    return SecurityResult(valid=True, text=text)\n</code></pre>"},{"location":"api-reference/#strutex.security.output.OutputValidator","title":"<code>OutputValidator(check_secrets: bool = True, check_prompt_leaks: bool = True, secret_patterns: Optional[List[tuple]] = None, block_on_detection: bool = True)</code>","text":"<p>               Bases: <code>SecurityPlugin</code></p> <p>Validates LLM output for security issues.</p> <p>Checks for: - Leaked API keys/secrets - Leaked system prompts - Suspicious executable patterns - PII exposure</p> Usage <p>validator = OutputValidator() result = validator.validate_output(data)</p> Source code in <code>strutex/security/output.py</code> <pre><code>def __init__(\n    self,\n    check_secrets: bool = True,\n    check_prompt_leaks: bool = True,\n    secret_patterns: Optional[List[tuple]] = None,\n    block_on_detection: bool = True\n):\n    self.check_secrets = check_secrets\n    self.check_prompt_leaks = check_prompt_leaks\n    self.block_on_detection = block_on_detection\n\n    # Compile patterns\n    patterns = secret_patterns or self.SECRET_PATTERNS\n    self._secret_patterns = [(re.compile(p, re.IGNORECASE), name) for p, name in patterns]\n    self._leak_patterns = [re.compile(p, re.IGNORECASE) for p in self.PROMPT_LEAK_PATTERNS]\n</code></pre>"},{"location":"api-reference/#strutex.security.output.OutputValidator.validate_output","title":"<code>validate_output(data: Dict[str, Any]) -&gt; SecurityResult</code>","text":"<p>Validate output data for security issues.</p> Source code in <code>strutex/security/output.py</code> <pre><code>def validate_output(self, data: Dict[str, Any]) -&gt; SecurityResult:\n    \"\"\"Validate output data for security issues.\"\"\"\n    issues = []\n\n    # Convert to string for pattern matching\n    text = self._flatten_to_text(data)\n\n    # Check for secrets\n    if self.check_secrets:\n        for pattern, secret_type in self._secret_patterns:\n            if pattern.search(text):\n                issues.append(f\"Potential {secret_type} detected in output\")\n\n    # Check for prompt leaks\n    if self.check_prompt_leaks:\n        for pattern in self._leak_patterns:\n            if pattern.search(text):\n                issues.append(\"Potential system prompt leak detected\")\n                break\n\n    if issues:\n        if self.block_on_detection:\n            return SecurityResult(\n                valid=False,\n                data=None,\n                reason=\"; \".join(issues)\n            )\n        else:\n            return SecurityResult(\n                valid=True,\n                data=data,\n                reason=f\"Warning: {'; '.join(issues)}\"\n            )\n\n    return SecurityResult(valid=True, data=data)\n</code></pre>"},{"location":"api-reference/#prompts","title":"Prompts","text":"<p>options: show_root_heading: true members: - init - add_general_rule - add_field_rule - add_output_guideline - compile</p>"},{"location":"api-reference/#strutex.prompts.builder.StructuredPrompt","title":"<code>StructuredPrompt(persona: str = 'You are a highly accurate AI Data Extraction Assistant.')</code>","text":"<p>Builder for organizing complex extraction prompts.</p> <p>Provides a fluent API for constructing well-structured prompts with general rules, field-specific rules, and output guidelines.</p> Usage <p>prompt = StructuredPrompt(\"You are an expert...\")</p> Example <p>prompt = ( ...     StructuredPrompt() ...     .add_general_rule( ...         \"Strict data fidelity: do not invent values.\",  ...         \"Dates must be in DD.MM.YYYY format.\" ...     ) ...     .add_field_rule( ...         \"artikelnummer\",  ...         \"Must be 8 digits.\",  ...         \"Ignore supplier codes.\", ...         critical=True ...     ) ...     .add_output_guideline(\"Return valid JSON.\") ...     .compile() ... )</p> <p>Initialize the prompt builder.</p> PARAMETER DESCRIPTION <code>persona</code> <p>The system persona/role description.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'You are a highly accurate AI Data Extraction Assistant.'</code> </p> Source code in <code>strutex/prompts/builder.py</code> <pre><code>def __init__(self, persona: str = \"You are a highly accurate AI Data Extraction Assistant.\"):\n    \"\"\"\n    Initialize the prompt builder.\n\n    Args:\n        persona: The system persona/role description.\n    \"\"\"\n    self.persona = persona.strip()\n    self.general_rules: List[str] = []\n    self.field_rules: Dict[str, List[str]] = {}\n    self.output_guidelines: List[str] = []\n</code></pre>"},{"location":"api-reference/#strutex.prompts.builder.StructuredPrompt--variadic-arguments-allow-adding-multiple-rules-at-once","title":"Variadic arguments allow adding multiple rules at once","text":"<p>prompt.add_general_rule(\"No guessing\", \"Use ISO dates\") prompt.add_field_rule(\"total\", \"Exclude tax\", \"Must be numeric\", critical=True) final_string = prompt.compile()</p>"},{"location":"api-reference/#strutex.prompts.builder.StructuredPrompt.__str__","title":"<code>__str__() -&gt; str</code>","text":"<p>Allow using the prompt directly as a string.</p> Source code in <code>strutex/prompts/builder.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Allow using the prompt directly as a string.\"\"\"\n    return self.compile()\n</code></pre>"},{"location":"api-reference/#strutex.prompts.builder.StructuredPrompt.add_field_rule","title":"<code>add_field_rule(field_name: str, *rules: str, critical: bool = False) -&gt; StructuredPrompt</code>","text":"<p>Adds one or more rules specific to a single field.</p> PARAMETER DESCRIPTION <code>field_name</code> <p>The name of the field these rules apply to.</p> <p> TYPE: <code>str</code> </p> <code>*rules</code> <p>Variable number of rule strings.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>critical</code> <p>If True, prefixes rules with CRITICAL.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>StructuredPrompt</code> <p>Self for method chaining.</p> Example <p>.add_field_rule(\"invoice_id\", \"Must be numeric\", \"8 digits\", critical=True)</p> Source code in <code>strutex/prompts/builder.py</code> <pre><code>def add_field_rule(self, field_name: str, *rules: str, critical: bool = False) -&gt; \"StructuredPrompt\":\n    \"\"\"\n    Adds one or more rules specific to a single field.\n\n    Args:\n        field_name: The name of the field these rules apply to.\n        *rules: Variable number of rule strings.\n        critical: If True, prefixes rules with **CRITICAL**.\n\n    Returns:\n        Self for method chaining.\n\n    Example:\n        .add_field_rule(\"invoice_id\", \"Must be numeric\", \"8 digits\", critical=True)\n    \"\"\"\n    if field_name not in self.field_rules:\n        self.field_rules[field_name] = []\n\n    prefix = \"**CRITICAL**: \" if critical else \"\"\n    for rule in rules:\n        self.field_rules[field_name].append(f\"{prefix}{rule}\")\n    return self\n</code></pre>"},{"location":"api-reference/#strutex.prompts.builder.StructuredPrompt.add_general_rule","title":"<code>add_general_rule(*rules: str) -&gt; StructuredPrompt</code>","text":"<p>Adds one or more high-level rules.</p> PARAMETER DESCRIPTION <code>*rules</code> <p>Variable number of rule strings.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>StructuredPrompt</code> <p>Self for method chaining.</p> Example <p>.add_general_rule(\"Rule 1\", \"Rule 2\", \"Rule 3\")</p> Source code in <code>strutex/prompts/builder.py</code> <pre><code>def add_general_rule(self, *rules: str) -&gt; \"StructuredPrompt\":\n    \"\"\"\n    Adds one or more high-level rules.\n\n    Args:\n        *rules: Variable number of rule strings.\n\n    Returns:\n        Self for method chaining.\n\n    Example:\n        .add_general_rule(\"Rule 1\", \"Rule 2\", \"Rule 3\")\n    \"\"\"\n    self.general_rules.extend(rules)\n    return self\n</code></pre>"},{"location":"api-reference/#strutex.prompts.builder.StructuredPrompt.add_output_guideline","title":"<code>add_output_guideline(*guidelines: str) -&gt; StructuredPrompt</code>","text":"<p>Adds formatting instructions for the output.</p> PARAMETER DESCRIPTION <code>*guidelines</code> <p>Variable number of guideline strings.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>StructuredPrompt</code> <p>Self for method chaining.</p> Example <p>.add_output_guideline(\"JSON only\", \"No markdown\", \"No comments\")</p> Source code in <code>strutex/prompts/builder.py</code> <pre><code>def add_output_guideline(self, *guidelines: str) -&gt; \"StructuredPrompt\":\n    \"\"\"\n    Adds formatting instructions for the output.\n\n    Args:\n        *guidelines: Variable number of guideline strings.\n\n    Returns:\n        Self for method chaining.\n\n    Example:\n        .add_output_guideline(\"JSON only\", \"No markdown\", \"No comments\")\n    \"\"\"\n    self.output_guidelines.extend(guidelines)\n    return self\n</code></pre>"},{"location":"api-reference/#strutex.prompts.builder.StructuredPrompt.compile","title":"<code>compile() -&gt; str</code>","text":"<p>Builds the final prompt string.</p> RETURNS DESCRIPTION <code>str</code> <p>The complete formatted prompt ready for LLM consumption.</p> Source code in <code>strutex/prompts/builder.py</code> <pre><code>def compile(self) -&gt; str:\n    \"\"\"\n    Builds the final prompt string.\n\n    Returns:\n        The complete formatted prompt ready for LLM consumption.\n    \"\"\"\n    parts = [self.persona, \"\"]\n\n    if self.general_rules:\n        parts.append(\"### 1. General Principles\")\n        parts.extend([f\"- {r}\" for r in self.general_rules])\n        parts.append(\"\")\n\n    if self.field_rules:\n        parts.append(\"### 2. Field Rules\")\n        for field, rules in self.field_rules.items():\n            parts.append(f\"\\n**{field}**:\")\n            parts.extend([f\"- {r}\" for r in rules])\n        parts.append(\"\")\n\n    parts.append(\"### 3. Output Format\")\n    if self.output_guidelines:\n        parts.extend([f\"- {r}\" for r in self.output_guidelines])\n    else:\n        parts.append(\"- Output valid JSON only. No markdown.\")\n\n    return \"\\n\".join(parts)\n</code></pre>"},{"location":"api-reference/#strutex.prompts.builder.StructuredPrompt.from_schema","title":"<code>from_schema(schema, persona: Optional[str] = None) -&gt; StructuredPrompt</code>  <code>classmethod</code>","text":"<p>Create a StructuredPrompt with field rules auto-generated from a Pydantic schema.</p> PARAMETER DESCRIPTION <code>schema</code> <p>A Pydantic BaseModel class with Field descriptions.</p> <p> </p> <code>persona</code> <p>Optional custom persona string.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>StructuredPrompt</code> <p>A StructuredPrompt with field rules for each described field.</p> Example <p>from pydantic import BaseModel, Field class Invoice(BaseModel): ...     invoice_number: str = Field(description=\"Unique invoice ID\") ...     total: float = Field(description=\"Final amount due\")</p> <p>prompt = StructuredPrompt.from_schema(Invoice) prompt.add_general_rule(\"Use ISO dates\") print(prompt.compile())</p> Source code in <code>strutex/prompts/builder.py</code> <pre><code>@classmethod\ndef from_schema(cls, schema, persona: Optional[str] = None) -&gt; \"StructuredPrompt\":\n    \"\"\"\n    Create a StructuredPrompt with field rules auto-generated from a Pydantic schema.\n\n    Args:\n        schema: A Pydantic BaseModel class with Field descriptions.\n        persona: Optional custom persona string.\n\n    Returns:\n        A StructuredPrompt with field rules for each described field.\n\n    Example:\n        &gt;&gt;&gt; from pydantic import BaseModel, Field\n        &gt;&gt;&gt; class Invoice(BaseModel):\n        ...     invoice_number: str = Field(description=\"Unique invoice ID\")\n        ...     total: float = Field(description=\"Final amount due\")\n        &gt;&gt;&gt; \n        &gt;&gt;&gt; prompt = StructuredPrompt.from_schema(Invoice)\n        &gt;&gt;&gt; prompt.add_general_rule(\"Use ISO dates\")\n        &gt;&gt;&gt; print(prompt.compile())\n    \"\"\"\n    if persona:\n        instance = cls(persona=persona)\n    else:\n        instance = cls()\n\n    # Check if it's a Pydantic model\n    if hasattr(schema, \"model_fields\"):\n        # Pydantic v2\n        for field_name, field_info in schema.model_fields.items():\n            description = field_info.description\n            if description:\n                # Mark required fields as critical\n                is_required = field_info.is_required()\n                instance.add_field_rule(field_name, description, critical=is_required)\n    elif hasattr(schema, \"__fields__\"):\n        # Pydantic v1 fallback\n        for field_name, field_info in schema.__fields__.items():\n            description = field_info.field_info.description\n            if description:\n                is_required = field_info.required\n                instance.add_field_rule(field_name, description, critical=is_required)\n\n    return instance\n</code></pre>"},{"location":"api-reference/#pydantic-support","title":"Pydantic Support","text":"<p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p>"},{"location":"api-reference/#strutex.pydantic_support.pydantic_to_schema","title":"<code>pydantic_to_schema(model: Type) -&gt; Schema</code>","text":"<p>Convert a Pydantic BaseModel to a strutex Schema.</p> PARAMETER DESCRIPTION <code>model</code> <p>A Pydantic BaseModel class</p> <p> TYPE: <code>Type</code> </p> RETURNS DESCRIPTION <code>Schema</code> <p>Equivalent strutex Schema (Object)</p> Example <p>from pydantic import BaseModel</p> <p>class Invoice(BaseModel):     invoice_number: str     total: float     items: list[LineItem]</p> <p>schema = pydantic_to_schema(Invoice)</p> Source code in <code>strutex/pydantic_support.py</code> <pre><code>def pydantic_to_schema(model: Type) -&gt; Schema:\n    \"\"\"\n    Convert a Pydantic BaseModel to a strutex Schema.\n\n    Args:\n        model: A Pydantic BaseModel class\n\n    Returns:\n        Equivalent strutex Schema (Object)\n\n    Example:\n        from pydantic import BaseModel\n\n        class Invoice(BaseModel):\n            invoice_number: str\n            total: float\n            items: list[LineItem]\n\n        schema = pydantic_to_schema(Invoice)\n    \"\"\"\n    try:\n        from pydantic import BaseModel\n        from pydantic.fields import FieldInfo\n    except ImportError:\n        raise ImportError(\"Pydantic is required for pydantic_to_schema. Install with: pip install pydantic\")\n\n    if not (inspect.isclass(model) and issubclass(model, BaseModel)):\n        raise TypeError(f\"Expected Pydantic BaseModel, got {type(model)}\")\n\n    properties = {}\n    required_fields = []\n\n    # Get model fields\n    for field_name, field_info in model.model_fields.items():\n        field_type = field_info.annotation\n        description = field_info.description\n\n        # Check if required\n        if field_info.is_required():\n            required_fields.append(field_name)\n\n        # Convert type to schema\n        properties[field_name] = _python_type_to_schema(\n            field_type, \n            description=description,\n            nullable=not field_info.is_required()\n        )\n\n    return Object(\n        properties=properties,\n        description=model.__doc__,\n        required=required_fields if required_fields else None\n    )\n</code></pre>"},{"location":"api-reference/#strutex.pydantic_support.validate_with_pydantic","title":"<code>validate_with_pydantic(data: Dict[str, Any], model: Type) -&gt; Any</code>","text":"<p>Validate extracted data against a Pydantic model.</p> PARAMETER DESCRIPTION <code>data</code> <p>Extracted dictionary data</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>model</code> <p>Pydantic BaseModel class to validate against</p> <p> TYPE: <code>Type</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>Validated Pydantic model instance</p> RAISES DESCRIPTION <code>ValidationError</code> <p>If validation fails</p> Source code in <code>strutex/pydantic_support.py</code> <pre><code>def validate_with_pydantic(data: Dict[str, Any], model: Type) -&gt; Any:\n    \"\"\"\n    Validate extracted data against a Pydantic model.\n\n    Args:\n        data: Extracted dictionary data\n        model: Pydantic BaseModel class to validate against\n\n    Returns:\n        Validated Pydantic model instance\n\n    Raises:\n        pydantic.ValidationError: If validation fails\n    \"\"\"\n    try:\n        from pydantic import BaseModel\n    except ImportError:\n        raise ImportError(\"Pydantic is required. Install with: pip install pydantic\")\n\n    if not (inspect.isclass(model) and issubclass(model, BaseModel)):\n        raise TypeError(f\"Expected Pydantic BaseModel, got {type(model)}\")\n\n    return model.model_validate(data)\n</code></pre>"},{"location":"api-reference/#exceptions","title":"Exceptions","text":"<p>options: show_root_heading: true</p>"},{"location":"api-reference/#strutex.processor.SecurityError","title":"<code>SecurityError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when security validation fails.</p> <p>This exception is raised when either input validation (e.g., prompt injection detected) or output validation (e.g., leaked secrets detected) fails.</p> ATTRIBUTE DESCRIPTION <code>message</code> <p>Description of the security failure.</p> <p> </p> Example <pre><code>from strutex.processor import SecurityError\n\ntry:\n    result = processor.process(file, prompt, schema, security=True)\nexcept SecurityError as e:\n    print(f\"Security check failed: {e}\")\n</code></pre>"},{"location":"cache/","title":"Caching","text":"<p>Reduce API costs and improve response times with strutex's caching system.</p>"},{"location":"cache/#quick-start","title":"Quick Start","text":"<pre><code>from strutex import DocumentProcessor, MemoryCache\nfrom strutex.schemas import INVOICE_US\n\n# Create processor with cache\nprocessor = DocumentProcessor(\n    provider=\"gemini\",\n    cache=MemoryCache(max_size=100, ttl=3600)  # 1 hour TTL\n)\n\n# First call: hits LLM API\nresult1 = processor.process(\"invoice.pdf\", \"Extract invoice\", model=INVOICE_US)\n\n# Second call: returns cached result instantly (no API call)\nresult2 = processor.process(\"invoice.pdf\", \"Extract invoice\", model=INVOICE_US)\n\nprint(f\"Invoice: {result1}\")\n</code></pre> <p>The cache key is automatically computed from:</p> <ul> <li>File content hash (same content = same key)</li> <li>Prompt hash</li> <li>Schema hash</li> <li>Provider and model name</li> </ul>"},{"location":"cache/#manual-cache-usage","title":"Manual Cache Usage","text":"<p>For more control, you can manually manage the cache:</p> <pre><code>from strutex import DocumentProcessor, MemoryCache, CacheKey\n\ncache = MemoryCache()\nprocessor = DocumentProcessor(provider=\"gemini\")\n\n# Create cache key\nkey = CacheKey.create(\"invoice.pdf\", \"Extract invoice\", INVOICE_US, \"gemini\")\n\n# Check cache\nresult = cache.get(key)\nif result is None:\n    result = processor.process(\"invoice.pdf\", \"Extract invoice\", model=INVOICE_US)\n    cache.set(key, result)\n</code></pre>"},{"location":"cache/#cache-types","title":"Cache Types","text":""},{"location":"cache/#memorycache","title":"MemoryCache","text":"<p>Fast, in-memory LRU cache. Best for single-process applications.</p> <pre><code>from strutex import MemoryCache\n\ncache = MemoryCache(\n    max_size=100,   # Max entries (LRU eviction)\n    ttl=3600        # TTL in seconds (optional)\n)\n\n# Thread-safe operations\ncache.set(key, result)\nresult = cache.get(key)\n</code></pre> <p>Features:</p> <ul> <li>LRU eviction when max_size reached</li> <li>Optional TTL (time-to-live)</li> <li>Thread-safe</li> <li>Hit/miss statistics</li> </ul>"},{"location":"cache/#sqlitecache","title":"SQLiteCache","text":"<p>Persistent cache that survives restarts. Best for durability.</p> <pre><code>from strutex import SQLiteCache\n\ncache = SQLiteCache(\n    db_path=\"~/.cache/strutex/cache.db\",\n    ttl=86400,      # 24 hour TTL\n    max_size=1000   # Optional size limit\n)\n\n# Persists across restarts\ncache.set(key, result)\n</code></pre> <p>Features:</p> <ul> <li>Persistent storage</li> <li>Automatic table creation</li> <li>Lazy TTL cleanup</li> <li>Size limits with oldest-first eviction</li> </ul>"},{"location":"cache/#filecache","title":"FileCache","text":"<p>Simple JSON file cache. Best for debugging and portability.</p> <pre><code>from strutex import FileCache\n\ncache = FileCache(\n    cache_dir=\"~/.cache/strutex/files/\",\n    ttl=3600\n)\n\n# Each entry is a separate JSON file\ncache.set(key, result)  # Creates {hash}.json\n</code></pre> <p>Features:</p> <ul> <li>One JSON file per entry</li> <li>Easy to inspect/debug</li> <li>Portable across systems</li> </ul>"},{"location":"cache/#cachekey","title":"CacheKey","text":"<p>Cache keys are computed from:</p> <ul> <li>File content hash (SHA256 of file bytes)</li> <li>Prompt hash (SHA256 of prompt text)</li> <li>Schema hash (SHA256 of schema structure)</li> <li>Provider name</li> <li>Model name (optional)</li> </ul> <pre><code>from strutex import CacheKey\n\n# Create from extraction parameters\nkey = CacheKey.create(\n    file_path=\"invoice.pdf\",\n    prompt=\"Extract invoice details\",\n    schema=INVOICE_US,\n    provider=\"gemini\",\n    model=\"gemini-2.5-flash\"\n)\n\n# Key string: \"a1b2c3:d4e5f6:g7h8i9:gemini:gemini-2.5-flash\"\nprint(key.to_string())\n</code></pre> <p>Content-based Keys</p> <p>Keys are based on file content, not filename. Same file under different names = same cache entry.</p>"},{"location":"cache/#cache-statistics","title":"Cache Statistics","text":"<p>All caches provide statistics:</p> <pre><code>stats = cache.stats()\nprint(f\"Cache size: {stats['size']}\")\nprint(f\"Hit rate: {stats['hit_rate']}%\")\nprint(f\"Hits: {stats['hits']}, Misses: {stats['misses']}\")\n</code></pre> <p>MemoryCache stats:</p> <pre><code>{\n    \"type\": \"memory\",\n    \"size\": 42,\n    \"max_size\": 100,\n    \"hits\": 150,\n    \"misses\": 20,\n    \"hit_rate\": 88.24,\n    \"ttl\": 3600\n}\n</code></pre>"},{"location":"cache/#cache-maintenance","title":"Cache Maintenance","text":""},{"location":"cache/#clear-all-entries","title":"Clear all entries","text":"<pre><code>count = cache.clear()\nprint(f\"Cleared {count} entries\")\n</code></pre>"},{"location":"cache/#clean-up-expired-entries","title":"Clean up expired entries","text":"<pre><code>count = cache.cleanup_expired()\nprint(f\"Removed {count} expired entries\")\n</code></pre>"},{"location":"cache/#vacuum-sqlite-reclaim-disk-space","title":"Vacuum SQLite (reclaim disk space)","text":"<pre><code>sqlite_cache.vacuum()\n</code></pre>"},{"location":"cache/#wrapper-pattern","title":"Wrapper Pattern","text":"<p>Create a cached processor wrapper:</p> <pre><code>class CachedProcessor:\n    def __init__(self, processor, cache):\n        self.processor = processor\n        self.cache = cache\n\n    def process(self, file_path, prompt, schema, **kwargs):\n        # Generate cache key\n        provider = self.processor.provider.__class__.__name__\n        key = CacheKey.create(file_path, prompt, schema, provider)\n\n        # Try cache first\n        result = self.cache.get(key)\n        if result is not None:\n            return result\n\n        # Call API and cache result\n        result = self.processor.process(file_path, prompt, schema=schema, **kwargs)\n        self.cache.set(key, result)\n        return result\n\n# Usage\nprocessor = DocumentProcessor(provider=\"gemini\")\ncached = CachedProcessor(processor, MemoryCache(max_size=100))\nresult = cached.process(\"invoice.pdf\", \"Extract\", INVOICE_US)\n</code></pre>"},{"location":"cache/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Choose the right cache type:</p> </li> <li> <p><code>MemoryCache</code> for speed</p> </li> <li><code>SQLiteCache</code> for persistence</li> <li> <p><code>FileCache</code> for debugging</p> </li> <li> <p>Set appropriate TTLs:</p> </li> <li> <p>Short TTL for dynamic content</p> </li> <li> <p>Long TTL for static documents</p> </li> <li> <p>Monitor hit rates:</p> </li> <li> <p>Low hit rate = check key generation</p> </li> <li> <p>High miss rate = increase cache size</p> </li> <li> <p>Clean up regularly:</p> </li> <li> <p>Call <code>cleanup_expired()</code> periodically</p> </li> <li> <p>Use <code>vacuum()</code> for SQLite after deletes</p> </li> <li> <p>Don't cache errors:</p> </li> <li>Only cache successful results</li> <li>Let failed requests retry</li> </ol>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to strutex will be documented here.</p>"},{"location":"changelog/#v081-december-26-2025","title":"v0.8.1 (December 26, 2025)","text":""},{"location":"changelog/#bug-fixes-improvements","title":"\ud83d\udc1b Bug Fixes &amp; Improvements","text":"<ul> <li>Documentation: Updated README with \"What's New\" and PyPI links.</li> <li>Coverage: Increased test coverage &gt;61% (OpenAI/Langdock tests).</li> <li>Docs: Added <code>docs/caching.md</code>.</li> </ul>"},{"location":"changelog/#v080-december-26-2025","title":"v0.8.0 (December 26, 2025)","text":""},{"location":"changelog/#new-features","title":"\ud83d\ude80 New Features","text":"<p>Core Processing Enhancements</p> <ul> <li>Async Support: <code>aprocess()</code> on <code>DocumentProcessor</code> and all Providers for high-concurrency apps.</li> <li>Batch Processing: <code>process_batch()</code> and <code>aprocess_batch()</code> for efficient multi-document handling.</li> <li>Token &amp; Cost Tracking: Usage statistics (tokens, cost) aggregated in <code>ProcessingContext</code>.</li> <li>Hybrid Fallback: <code>HybridProvider</code> robustly falls back to local PDF text extraction if LLM fails.</li> <li>Verification: <code>verify()</code> method and <code>process(verify=True)</code> for LLM-based self-correction and auditing of results.</li> </ul> <p>Cache System</p> <ul> <li><code>MemoryCache</code> \u2014 In-memory LRU cache with TTL and thread-safety</li> <li><code>SQLiteCache</code> \u2014 Persistent SQLite-based cache with lazy cleanup</li> <li><code>FileCache</code> \u2014 Simple file-based JSON cache for debugging</li> <li><code>CacheKey</code> \u2014 Smart hashing of file content + prompt + schema + provider</li> <li>Cache statistics tracking (hits, misses, hit rate)</li> <li>Automatic expiration and cleanup</li> </ul> <p>Processing Context</p> <ul> <li><code>ProcessingContext</code> \u2014 State management for multi-step workflows</li> <li><code>BatchContext</code> \u2014 Progress tracking for batch processing</li> <li>Extraction history with timing and error tracking</li> <li>Step listeners for monitoring and logging</li> <li>Serialization for debugging and persistence</li> </ul> <p>Streaming Support</p> <ul> <li><code>StreamingProcessor</code> \u2014 Real-time response streaming</li> <li><code>StreamChunk</code> \u2014 Typed streaming chunks</li> <li><code>stream_to_string()</code> / <code>stream_with_callback()</code> utilities</li> <li>Async streaming support</li> </ul>"},{"location":"changelog/#new-files","title":"\ud83d\udcc1 New Files","text":"<ul> <li><code>strutex/extractors/pdf.py</code> \u2014 PDF Extractor (pdfplumber)</li> <li><code>strutex/providers/hybrid.py</code> \u2014 Hybrid Provider</li> <li><code>strutex/cache/__init__.py</code> \u2014 Cache module</li> <li><code>strutex/cache/base.py</code> \u2014 Cache interface and CacheKey</li> <li><code>strutex/cache/memory.py</code> \u2014 MemoryCache</li> <li><code>strutex/cache/sqlite.py</code> \u2014 SQLiteCache</li> <li><code>strutex/cache/file.py</code> \u2014 FileCache</li> <li><code>strutex/context.py</code> \u2014 ProcessingContext and BatchContext</li> <li><code>strutex/providers/streaming.py</code> \u2014 Streaming support</li> <li><code>docs/cache.md</code> \u2014 Caching documentation</li> <li><code>docs/context.md</code> \u2014 Context documentation</li> <li><code>docs/streaming.md</code> \u2014 Streaming documentation</li> <li><code>examples/caching_example.py</code></li> <li><code>examples/context_example.py</code></li> </ul>"},{"location":"changelog/#v070-december-26-2025","title":"v0.7.0 (December 26, 2025)","text":""},{"location":"changelog/#new-features_1","title":"\ud83d\ude80 New Features","text":"<p>Multi-Provider Support</p> <ul> <li><code>OpenAIProvider</code> \u2014 GPT-4o and GPT-4 Vision support</li> <li><code>AnthropicProvider</code> \u2014 Claude 3.5 Sonnet and Claude 3 Opus</li> <li><code>OllamaProvider</code> \u2014 Local models via Ollama (free, air-gapped)</li> <li><code>GroqProvider</code> \u2014 Ultra-fast inference at low cost</li> </ul> <p>Provider Chains</p> <ul> <li><code>ProviderChain</code> \u2014 Automatic fallback between providers</li> <li><code>local_first_chain()</code> \u2014 Ollama \u2192 Gemini \u2192 OpenAI</li> <li><code>cost_optimized_chain()</code> \u2014 Providers ordered by cost</li> <li><code>create_fallback_chain()</code> \u2014 Quick chain creation</li> <li>Fallback callbacks for monitoring</li> <li><code>last_provider</code> property for tracking</li> </ul> <p>Retry Infrastructure</p> <ul> <li><code>RetryConfig</code> \u2014 Configurable retry with exponential backoff</li> <li><code>with_retry()</code> decorator for sync/async functions</li> <li><code>RateLimiter</code> \u2014 Simple rate limiting for API calls</li> </ul>"},{"location":"changelog/#new-files_1","title":"\ud83d\udcc1 New Files","text":"<ul> <li><code>strutex/providers/openai.py</code> \u2014 OpenAI provider</li> <li><code>strutex/providers/anthropic.py</code> \u2014 Anthropic provider</li> <li><code>strutex/providers/ollama.py</code> \u2014 Ollama provider</li> <li><code>strutex/providers/groq.py</code> \u2014 Groq provider</li> <li><code>strutex/providers/chain.py</code> \u2014 Provider chain</li> <li><code>strutex/providers/retry.py</code> \u2014 Retry utilities</li> <li><code>docs/providers.md</code> \u2014 Updated provider documentation</li> <li><code>docs/provider-chains.md</code> \u2014 Chain documentation</li> <li><code>examples/provider_chain_example.py</code></li> </ul>"},{"location":"changelog/#v060-december-26-2025","title":"v0.6.0 (December 26, 2025)","text":""},{"location":"changelog/#new-features_2","title":"\ud83d\ude80 New Features","text":"<p>Built-in Schemas Module</p> <ul> <li>9 ready-to-use Pydantic schemas for common document types:</li> <li><code>INVOICE_GENERIC</code>, <code>INVOICE_US</code>, <code>INVOICE_EU</code></li> <li><code>RECEIPT</code>, <code>PURCHASE_ORDER</code>, <code>BILL_OF_LADING</code></li> <li><code>BANK_STATEMENT</code>, <code>RESUME</code>, <code>CONTRACT_CLAUSE</code></li> <li>One-line imports: <code>from strutex.schemas import INVOICE_US</code></li> <li>Schema inheritance for customization</li> </ul> <p>Logging Module</p> <ul> <li><code>strutex.logging</code> module with standardized logging</li> <li><code>get_logger()</code>, <code>configure_logging()</code>, <code>set_level()</code></li> <li>Environment variable support: <code>STRUTEX_LOG_LEVEL</code></li> </ul> <p>CI/CD Improvements</p> <ul> <li>pytest-cov for coverage reporting</li> <li>Codecov integration</li> <li>mypy type checking (non-blocking)</li> <li>Coverage badge in README</li> </ul>"},{"location":"changelog/#new-files_2","title":"\ud83d\udcc1 New Files","text":"<ul> <li><code>strutex/schemas/__init__.py</code> \u2014 Schema exports</li> <li><code>strutex/schemas/invoice.py</code> \u2014 Invoice schemas</li> <li><code>strutex/schemas/receipt.py</code> \u2014 Receipt schema</li> <li><code>strutex/schemas/purchase_order.py</code> \u2014 PO schema</li> <li><code>strutex/schemas/shipping.py</code> \u2014 Bill of Lading</li> <li><code>strutex/schemas/financial.py</code> \u2014 Bank Statement</li> <li><code>strutex/schemas/resume.py</code> \u2014 Resume schema</li> <li><code>strutex/schemas/legal.py</code> \u2014 Contract clauses</li> <li><code>strutex/logging.py</code> \u2014 Logging module</li> <li><code>docs/schemas.md</code> \u2014 Schema documentation</li> <li><code>examples/schemas_example.py</code></li> </ul>"},{"location":"changelog/#v030-december-23-2025","title":"v0.3.0 (December 23, 2025)","text":""},{"location":"changelog/#new-features_3","title":"\ud83d\ude80 New Features","text":"<p>Plugin System v2</p> <ul> <li>Lazy Loading: Plugins are only imported when first used via <code>PluginRegistry.get()</code>, improving startup time</li> <li>Entry Points: Register plugins via <code>pyproject.toml</code> entry points (recommended over <code>@register</code> decorator)</li> <li>API Versioning: All plugins have <code>strutex_plugin_version = \"1.0\"</code> attribute for compatibility checks</li> <li>Priority Ordering: Plugins declare <code>priority</code> (0-100) for waterfall ordering; higher = preferred</li> <li>Cost Hints: Plugins declare <code>cost</code> for optimization; lower = cheaper</li> <li>Health Checks: All base classes have <code>health_check()</code> classmethod</li> <li>Protocol Types: <code>ProviderProtocol</code>, <code>ValidatorProtocol</code>, etc. for mypy-compatible type checking</li> <li>Discovery Caching: Plugin discovery cached in <code>~/.cache/strutex/plugins.json</code>, invalidated on pip changes</li> <li>Sandboxed Probing: <code>sandbox.py</code> for safely probing untrusted plugins in subprocess</li> </ul> <p>CLI Tooling</p> <ul> <li><code>strutex plugins list</code> \u2014 Show all discovered plugins with health status</li> <li><code>strutex plugins list --type provider</code> \u2014 Filter by plugin type</li> <li><code>strutex plugins list --json</code> \u2014 JSON output for scripting</li> <li><code>strutex plugins info &lt;name&gt; --type &lt;type&gt;</code> \u2014 Detailed plugin info</li> <li><code>strutex plugins refresh</code> \u2014 Re-scan entry points and refresh cache</li> <li><code>strutex plugins cache</code> \u2014 Show/clear discovery cache</li> </ul> <p>Pluggy Hooks</p> <ul> <li><code>@hookimpl</code> decorator for pipeline extension</li> <li><code>strutex_pre_process</code> \u2014 Called before document processing</li> <li><code>strutex_post_process</code> \u2014 Called after processing, can transform results</li> <li><code>strutex_on_error</code> \u2014 Called on failure for error recovery</li> </ul> <p>Documentation</p> <ul> <li>Versioned documentation with mike</li> <li>Version selector dropdown in docs</li> <li>Automated docs deployment via GitHub Actions</li> <li>New changelog page</li> </ul>"},{"location":"changelog/#new-files_3","title":"\ud83d\udcc1 New Files","text":"<ul> <li><code>strutex/plugins/protocol.py</code> \u2014 Protocol-typed interfaces</li> <li><code>strutex/plugins/hooks.py</code> \u2014 Pluggy hook specifications</li> <li><code>strutex/plugins/discovery.py</code> \u2014 Cached plugin discovery</li> <li><code>strutex/plugins/sandbox.py</code> \u2014 Subprocess plugin probing</li> <li><code>strutex/cli.py</code> \u2014 CLI commands</li> <li><code>tests/test_plugin_contract.py</code> \u2014 Contract tests for plugins</li> <li><code>tests/test_v030_features.py</code> \u2014 v0.3.0 feature tests</li> <li><code>.github/workflows/docs.yml</code> \u2014 Automated docs deployment</li> <li><code>docs/changelog.md</code> \u2014 This changelog</li> <li><code>docs/hooks.md</code> \u2014 Hooks system documentation</li> <li><code>docs/cli.md</code> \u2014 CLI commands documentation</li> </ul>"},{"location":"changelog/#updated-files","title":"\u270f\ufe0f Updated Files","text":"<ul> <li><code>strutex/plugins/registry.py</code> \u2014 Complete rewrite for lazy loading</li> <li><code>strutex/plugins/base.py</code> \u2014 Added version, priority, cost, health_check to all base classes</li> <li><code>strutex/plugins/__init__.py</code> \u2014 Export new v2 modules</li> <li><code>strutex/providers/gemini.py</code> \u2014 Added v2 attributes, removed deprecated decorator</li> <li><code>pyproject.toml</code> \u2014 Added pluggy, click, mike; added CLI entry point</li> <li><code>mkdocs.yml</code> \u2014 Added version selector config</li> <li><code>docs/plugins.md</code> \u2014 Rewritten for v0.3.0 features</li> <li><code>examples/plugin_example.py</code> \u2014 Updated to showcase v2 features</li> </ul>"},{"location":"changelog/#deprecations","title":"\u26a0\ufe0f Deprecations","text":"<ul> <li><code>@register</code> decorator now emits <code>DeprecationWarning</code></li> <li>Use entry points in <code>pyproject.toml</code> instead:     <pre><code>[project.entry-points.\"strutex.providers\"]\nmy_provider = \"my_package:MyProvider\"\n</code></pre></li> </ul>"},{"location":"changelog/#new-dependencies","title":"\ud83d\udce6 New Dependencies","text":"<ul> <li><code>pluggy ^1.5.0</code> \u2014 Hook system (battle-tested, from pytest team)</li> <li><code>click ^8.1.0</code> \u2014 CLI framework</li> <li><code>mike ^2.1.0</code> \u2014 Documentation versioning (dev dependency)</li> </ul>"},{"location":"changelog/#v020","title":"v0.2.0","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Plugin registry system with <code>@register</code> decorator</li> <li>Security plugins: <code>InputSanitizer</code>, <code>PromptInjectionDetector</code>, <code>OutputValidator</code></li> <li>Composable <code>SecurityChain</code></li> <li>Pydantic model support for schemas</li> <li>Base classes: <code>Provider</code>, <code>Extractor</code>, <code>Validator</code>, <code>Postprocessor</code>, <code>SecurityPlugin</code></li> </ul>"},{"location":"changelog/#v010","title":"v0.1.0","text":""},{"location":"changelog/#initial-release","title":"Initial Release","text":"<ul> <li>Google Gemini provider</li> <li>Custom schema types (<code>Object</code>, <code>String</code>, <code>Number</code>, <code>Array</code>, <code>Boolean</code>)</li> <li>PDF text extraction with waterfall fallback (pypdf \u2192 pdfplumber \u2192 pdfminer \u2192 OCR)</li> <li>Excel/spreadsheet support</li> <li>MIME type detection</li> <li><code>StructuredPrompt</code> fluent builder API</li> </ul>"},{"location":"cli/","title":"CLI Commands","text":"<p>Manage plugins and inspect strutex from the command line.</p> <p>Requires cli extra</p> <p><code>bash     pip install strutex[cli]</code></p>"},{"location":"cli/#plugin-commands","title":"Plugin Commands","text":""},{"location":"cli/#list-plugins","title":"List Plugins","text":"<pre><code># List all plugins\nstrutex plugins list\n\n# Filter by type\nstrutex plugins list --type provider\n\n# JSON output for scripting\nstrutex plugins list --json\n\n# Only show loaded plugins\nstrutex plugins list --loaded-only\n</code></pre> <p>Output:</p> <pre><code>PROVIDERS\n----------------------------------------\n  \u2713 \u25cf gemini               v1.0      priority: 50\n       \u2514\u2500 capabilities: vision\n\nVALIDATORS\n----------------------------------------\n  \u2713 \u25cb invoice_validator    v1.0      priority: 60\n</code></pre> <p>Legend:</p> <ul> <li><code>\u2713</code> = healthy, <code>\u2717</code> = unhealthy, <code>?</code> = unknown</li> <li><code>\u25cf</code> = loaded, <code>\u25cb</code> = not loaded (lazy)</li> </ul>"},{"location":"cli/#plugin-info","title":"Plugin Info","text":"<pre><code># Get detailed info about a plugin\nstrutex plugins info gemini --type provider\n\n# JSON output\nstrutex plugins info gemini --type provider --json\n</code></pre> <p>Output:</p> <pre><code>Plugin: gemini\n----------------------------------------\n  version        : 1.0\n  priority       : 50\n  cost           : 1.0\n  capabilities   : vision\n  loaded         : True\n  healthy        : True\n</code></pre>"},{"location":"cli/#refresh-discovery","title":"Refresh Discovery","text":"<pre><code># Re-scan entry points and refresh cache\nstrutex plugins refresh\n</code></pre> <p>Use after:</p> <ul> <li>Installing new plugins with pip</li> <li>Updating plugin packages</li> <li>Modifying entry points</li> </ul>"},{"location":"cli/#cache-management","title":"Cache Management","text":"<pre><code># Show cache status\nstrutex plugins cache\n\n# Clear the cache\nstrutex plugins cache --clear\n</code></pre> <p>Output:</p> <pre><code>Cache file: /home/user/.cache/strutex/plugins.json\nCache valid: True\nCached plugins: 5\n</code></pre>"},{"location":"cli/#examples","title":"Examples","text":""},{"location":"cli/#find-all-providers","title":"Find All Providers","text":"<pre><code>strutex plugins list --type provider --json | jq '.provider[].name'\n</code></pre>"},{"location":"cli/#check-plugin-health","title":"Check Plugin Health","text":"<pre><code>strutex plugins info gemini -t provider --json | jq '.healthy'\n</code></pre>"},{"location":"cli/#list-high-priority-plugins","title":"List High-Priority Plugins","text":"<pre><code>strutex plugins list --json | jq '.provider | sort_by(.priority) | reverse'\n</code></pre>"},{"location":"cli/#programmatic-equivalent","title":"Programmatic Equivalent","text":"<p>Every CLI command has a Python equivalent:</p> CLI Python <code>strutex plugins list</code> <code>PluginRegistry.list_names(\"provider\")</code> <code>strutex plugins info X</code> <code>PluginRegistry.get_plugin_info(\"provider\", \"X\")</code> <code>strutex plugins refresh</code> <code>PluginRegistry.discover(force=True)</code> <code>strutex plugins cache --clear</code> <code>PluginDiscovery.clear_cache()</code> <pre><code>from strutex.plugins import PluginRegistry\nfrom strutex.plugins.discovery import PluginDiscovery\n\n# List all providers\nfor name in PluginRegistry.list_names(\"provider\"):\n    info = PluginRegistry.get_plugin_info(\"provider\", name)\n    print(f\"{name}: priority={info['priority']}\")\n\n# Clear cache\nPluginDiscovery.clear_cache()\n</code></pre>"},{"location":"context/","title":"Processing Context","text":"<p>Share state across multi-step document workflows with <code>ProcessingContext</code>.</p>"},{"location":"context/#quick-start","title":"Quick Start","text":"<pre><code>from strutex import DocumentProcessor, ProcessingContext\nfrom strutex.schemas import INVOICE_US, RECEIPT\n\nprocessor = DocumentProcessor(provider=\"gemini\")\nctx = ProcessingContext()\n\n# First extraction\ninvoice = ctx.extract(processor, \"invoice.pdf\", \"Extract invoice\", INVOICE_US)\n\n# Store state for use in next step\nctx.set(\"expected_total\", invoice.total)\n\n# Second extraction using stored state\nreceipt = ctx.extract(\n    processor,\n    \"receipt.jpg\",\n    f\"Verify receipt total matches {ctx.get('expected_total')}\",\n    RECEIPT\n)\n\n# Check results\nprint(f\"Processed {len(ctx.history)} documents\")\nprint(f\"Total time: {ctx.total_duration_ms:.0f}ms\")\n</code></pre>"},{"location":"context/#state-management","title":"State Management","text":"<p>Store and retrieve values across extraction steps:</p> <pre><code>ctx = ProcessingContext()\n\n# Store values\nctx.set(\"vendor_id\", \"ACME-001\")\nctx.set(\"items\", [\"item1\", \"item2\"])\n\n# Retrieve values\nvendor = ctx.get(\"vendor_id\")\nitems = ctx.get(\"items\", default=[])\n\n# Check if key exists\nif ctx.has(\"vendor_id\"):\n    print(\"Vendor ID found\")\n\n# Update multiple values\nctx.update({\n    \"total\": 1500.00,\n    \"currency\": \"USD\"\n})\n\n# Get all state\nstate = ctx.state  # Returns copy\n</code></pre>"},{"location":"context/#extraction-history","title":"Extraction History","text":"<p>Every extraction is recorded:</p> <pre><code># Perform extractions\nctx.extract(processor, \"doc1.pdf\", \"Extract\", schema1)\nctx.extract(processor, \"doc2.pdf\", \"Extract\", schema2)\n\n# Access history\nfor step in ctx.history:\n    print(f\"Step {step.step_id}:\")\n    print(f\"  File: {step.file_path}\")\n    print(f\"  Provider: {step.provider}\")\n    print(f\"  Duration: {step.duration_ms:.0f}ms\")\n    print(f\"  Success: {step.result is not None}\")\n</code></pre>"},{"location":"context/#extractionstep-fields","title":"ExtractionStep Fields","text":"Field Type Description <code>step_id</code> str Unique step identifier <code>file_path</code> str Document path <code>prompt</code> str Extraction prompt (truncated) <code>provider</code> str Provider class name <code>result</code> Any Extraction result (or None) <code>error</code> str Error message (or None) <code>duration_ms</code> float Processing time <code>timestamp</code> str ISO timestamp"},{"location":"context/#metrics","title":"Metrics","text":"<pre><code># Aggregate metrics\nprint(f\"Total duration: {ctx.total_duration_ms:.0f}ms\")\nprint(f\"Success count: {ctx.success_count}\")\nprint(f\"Error count: {ctx.error_count}\")\n\n# Get last result\nlast = ctx.last_result\nprint(f\"Last result: {last}\")\n\n# Get all successful results\nall_results = ctx.get_results()\n</code></pre>"},{"location":"context/#step-listeners","title":"Step Listeners","text":"<p>Get notified after each extraction:</p> <pre><code>def log_step(step):\n    if step.error:\n        print(f\"\u274c {step.file_path} failed: {step.error}\")\n    else:\n        print(f\"\u2705 {step.file_path} completed in {step.duration_ms:.0f}ms\")\n\nctx = ProcessingContext()\nctx.on_step(log_step)\n\n# Listener called after each extraction\nctx.extract(processor, \"doc.pdf\", \"Extract\", schema)\n# Output: \u2705 doc.pdf completed in 2150ms\n</code></pre>"},{"location":"context/#batch-processing","title":"Batch Processing","text":"<p>For processing multiple documents, use <code>BatchContext</code>:</p> <pre><code>from strutex import BatchContext\nimport os\n\n# Get list of files\npdf_files = [f for f in os.listdir(\".\") if f.endswith(\".pdf\")]\n\n# Create batch context\nctx = BatchContext(total_documents=len(pdf_files))\n\nfor pdf in pdf_files:\n    try:\n        result = ctx.extract(processor, pdf, \"Extract invoice\", INVOICE_US)\n        ctx.set(pdf, result.invoice_number)\n    except Exception as e:\n        print(f\"Failed: {pdf}\")\n\n    # Progress tracking\n    print(f\"Progress: {ctx.progress}/{ctx.total_documents} ({ctx.progress_percent:.1f}%)\")\n    print(f\"Success rate: {ctx.success_rate:.1f}%\")\n    print(f\"Avg time: {ctx.average_duration_ms:.0f}ms\")\n    print(f\"ETA: {ctx.estimated_remaining_ms / 1000:.0f}s\")\n\n# Final summary\nprint(f\"\\nCompleted: {ctx.success_count}/{ctx.total_documents}\")\n</code></pre>"},{"location":"context/#batchcontext-properties","title":"BatchContext Properties","text":"Property Description <code>progress</code> Documents processed so far <code>progress_percent</code> Progress as percentage <code>success_rate</code> Success rate as percentage <code>average_duration_ms</code> Average time per document <code>estimated_remaining_ms</code> Estimated time remaining"},{"location":"context/#async-support","title":"Async Support","text":"<pre><code>import asyncio\n\nasync def batch_extract():\n    ctx = ProcessingContext()\n\n    for pdf in pdf_files:\n        result = await ctx.aextract(\n            processor, pdf, \"Extract\", INVOICE_US\n        )\n        print(f\"Extracted: {result.invoice_number}\")\n\n    return ctx.get_results()\n\nresults = asyncio.run(batch_extract())\n</code></pre>"},{"location":"context/#serialization","title":"Serialization","text":"<p>Export context for logging/persistence:</p> <pre><code># Serialize to dict\ndata = ctx.to_dict()\n\n# Contains:\n# - context_id\n# - metadata\n# - state\n# - history (list of steps)\n# - created_at\n# - total_duration_ms\n# - success_count\n# - error_count\n\nimport json\nprint(json.dumps(data, indent=2, default=str))\n</code></pre>"},{"location":"context/#best-practices","title":"Best Practices","text":"<ol> <li>Use meaningful context IDs:</li> </ol> <pre><code>ctx = ProcessingContext(context_id=\"invoice-batch-2024-01\")\n</code></pre> <ol> <li>Store intermediate results:</li> </ol> <pre><code>ctx.set(\"step1_result\", result1)\n# Use in later steps\nprevious = ctx.get(\"step1_result\")\n</code></pre> <ol> <li>Add listeners for monitoring:</li> </ol> <pre><code>ctx.on_step(lambda s: log_to_monitoring(s))\n</code></pre> <ol> <li> <p>Use BatchContext for multiple documents:</p> </li> <li> <p>Get progress tracking for free</p> </li> <li> <p>Estimate completion time</p> </li> <li> <p>Export history for debugging: <pre><code>with open(\"context.json\", \"w\") as f:\n    json.dump(ctx.to_dict(), f, default=str)\n</code></pre></p> </li> </ol>"},{"location":"extractors/","title":"Extractors","text":"<p>Extract text from documents for LLM processing.</p>"},{"location":"extractors/#overview","title":"Overview","text":"<p>Extractors convert document files (PDF, images, spreadsheets) into text that can be sent to an LLM.</p> <pre><code>from strutex import PDFExtractor, get_extractor\n\n# Direct usage\nextractor = PDFExtractor()\ntext = extractor.extract(\"invoice.pdf\")\n\n# Auto-select by MIME type\nextractor = get_extractor(\"application/pdf\")\ntext = extractor.extract(\"invoice.pdf\")\n</code></pre>"},{"location":"extractors/#built-in-extractors","title":"Built-in Extractors","text":""},{"location":"extractors/#pdfextractor","title":"PDFExtractor","text":"<p>Uses a waterfall strategy: pypdf \u2192 pdfplumber \u2192 pdfminer \u2192 OCR.</p> <pre><code>from strutex import PDFExtractor\n\nextractor = PDFExtractor()\ntext = extractor.extract(\"document.pdf\")\n</code></pre>"},{"location":"extractors/#imageextractor","title":"ImageExtractor","text":"<p>Uses Tesseract OCR. Requires <code>pytesseract</code> and <code>PIL</code>.</p> <pre><code>from strutex import ImageExtractor\n\nextractor = ImageExtractor()\ntext = extractor.extract(\"scan.png\")\n</code></pre> <p>OCR Dependencies</p> <p>Install with: <code>pip install strutex[ocr]</code></p>"},{"location":"extractors/#excelextractor","title":"ExcelExtractor","text":"<p>Converts spreadsheets to CSV text representation.</p> <pre><code>from strutex import ExcelExtractor\n\nextractor = ExcelExtractor()\ntext = extractor.extract(\"data.xlsx\")\n</code></pre>"},{"location":"extractors/#auto-selection","title":"Auto-Selection","text":"<p>Use <code>get_extractor()</code> to automatically select based on MIME type:</p> <pre><code>from strutex import get_extractor\nfrom strutex.documents import get_mime_type\n\nmime_type = get_mime_type(\"file.pdf\")\nextractor = get_extractor(mime_type)\ntext = extractor.extract(\"file.pdf\")\n</code></pre>"},{"location":"extractors/#creating-custom-extractors","title":"Creating Custom Extractors","text":"<pre><code>from strutex.plugins import Extractor\n\nclass XMLExtractor(Extractor, name=\"xml\"):\n    mime_types = [\"application/xml\", \"text/xml\"]\n\n    def extract(self, file_path: str) -&gt; str:\n        import xml.etree.ElementTree as ET\n        tree = ET.parse(file_path)\n        return ET.tostring(tree.getroot(), encoding=\"unicode\")\n\n    def can_handle(self, mime_type: str) -&gt; bool:\n        return mime_type in self.mime_types\n</code></pre>"},{"location":"extractors/#api-reference","title":"API Reference","text":"<p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p>"},{"location":"extractors/#strutex.extractors.PDFExtractor","title":"<code>PDFExtractor</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extracts text from PDF files using pdfplumber.</p> <p>Robust fallback when multimodal LLM processing fails.</p>"},{"location":"extractors/#strutex.extractors.PDFExtractor.extract","title":"<code>extract(file_path: str) -&gt; str</code>","text":"<p>Extract text from a PDF file.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>Path to the PDF file</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Extracted text content from all pages</p> Source code in <code>strutex/extractors/pdf.py</code> <pre><code>def extract(self, file_path: str) -&gt; str:\n    \"\"\"\n    Extract text from a PDF file.\n\n    Args:\n        file_path: Path to the PDF file\n\n    Returns:\n        Extracted text content from all pages\n    \"\"\"\n    if not PDFPLUMBER_AVAILABLE:\n        raise ImportError(\"pdfplumber is required for PDFExtractor. Install with: pip install pdfplumber\")\n\n    text_content = []\n    try:\n        with pdfplumber.open(file_path) as pdf:\n            for i, page in enumerate(pdf.pages):\n                page_text = page.extract_text()\n                if page_text:\n                    text_content.append(f\"--- Page {i+1} ---\\n{page_text}\")\n\n        return \"\\n\\n\".join(text_content)\n\n    except Exception as e:\n        logger.error(f\"Failed to extract text from {file_path}: {e}\")\n        raise RuntimeError(f\"PDF extraction failed: {e}\") from e\n</code></pre>"},{"location":"extractors/#strutex.extractors.ImageExtractor","title":"<code>ImageExtractor</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Image extractor using Tesseract OCR.</p> <p>Requires pytesseract and PIL to be installed. Install with: pip install strutex[ocr]</p> ATTRIBUTE DESCRIPTION <code>mime_types</code> <p>MIME types this extractor handles</p> <p> </p> <code>priority</code> <p>Extraction priority</p> <p> </p>"},{"location":"extractors/#strutex.extractors.ImageExtractor.can_handle","title":"<code>can_handle(mime_type: str) -&gt; bool</code>","text":"<p>Check if this extractor can handle the given MIME type.</p> Source code in <code>strutex/extractors/image.py</code> <pre><code>def can_handle(self, mime_type: str) -&gt; bool:\n    \"\"\"Check if this extractor can handle the given MIME type.\"\"\"\n    return mime_type in self.mime_types\n</code></pre>"},{"location":"extractors/#strutex.extractors.ImageExtractor.extract","title":"<code>extract(file_path: str) -&gt; str</code>","text":"<p>Extract text from an image using OCR.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>Path to the image file</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Extracted text content</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If OCR dependencies are not installed</p> Source code in <code>strutex/extractors/image.py</code> <pre><code>def extract(self, file_path: str) -&gt; str:\n    \"\"\"\n    Extract text from an image using OCR.\n\n    Args:\n        file_path: Path to the image file\n\n    Returns:\n        Extracted text content\n\n    Raises:\n        RuntimeError: If OCR dependencies are not installed\n    \"\"\"\n    if not _OCR_AVAILABLE:\n        raise RuntimeError(\n            \"OCR dependencies not installed. \"\n            \"Install with: pip install strutex[ocr]\"\n        )\n\n    try:\n        image = Image.open(file_path)\n        text = pytesseract.image_to_string(image)\n        return text.strip()\n    except Exception as e:\n        logger.error(f\"OCR extraction failed for {file_path}: {e}\")\n        raise RuntimeError(f\"Failed to extract text from image: {e}\")\n</code></pre>"},{"location":"extractors/#strutex.extractors.ImageExtractor.health_check","title":"<code>health_check() -&gt; bool</code>  <code>classmethod</code>","text":"<p>Check if OCR dependencies are available.</p> Source code in <code>strutex/extractors/image.py</code> <pre><code>@classmethod\ndef health_check(cls) -&gt; bool:\n    \"\"\"Check if OCR dependencies are available.\"\"\"\n    return _OCR_AVAILABLE\n</code></pre>"},{"location":"extractors/#strutex.extractors.ExcelExtractor","title":"<code>ExcelExtractor</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Excel and spreadsheet extractor.</p> <p>Converts spreadsheet data to a text representation suitable for LLM processing.</p> ATTRIBUTE DESCRIPTION <code>mime_types</code> <p>MIME types this extractor handles</p> <p> </p> <code>priority</code> <p>Extraction priority</p> <p> </p>"},{"location":"extractors/#strutex.extractors.ExcelExtractor.can_handle","title":"<code>can_handle(mime_type: str) -&gt; bool</code>","text":"<p>Check if this extractor can handle the given MIME type.</p> Source code in <code>strutex/extractors/excel.py</code> <pre><code>def can_handle(self, mime_type: str) -&gt; bool:\n    \"\"\"Check if this extractor can handle the given MIME type.\"\"\"\n    return mime_type in self.mime_types\n</code></pre>"},{"location":"extractors/#strutex.extractors.ExcelExtractor.extract","title":"<code>extract(file_path: str) -&gt; str</code>","text":"<p>Extract text from a spreadsheet file.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>Path to the spreadsheet file</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Text representation of the spreadsheet data</p> Source code in <code>strutex/extractors/excel.py</code> <pre><code>def extract(self, file_path: str) -&gt; str:\n    \"\"\"\n    Extract text from a spreadsheet file.\n\n    Args:\n        file_path: Path to the spreadsheet file\n\n    Returns:\n        Text representation of the spreadsheet data\n    \"\"\"\n    from ..documents.spreadsheet import spreadsheet_to_text\n    return spreadsheet_to_text(file_path)\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>pip install strutex\n</code></pre>"},{"location":"getting-started/#optional-dependencies","title":"Optional Dependencies","text":"OCR SupportAll Features <pre><code>pip install strutex[ocr]\n</code></pre> <pre><code>pip install strutex[ocr] pydantic\n</code></pre>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/#1-define-your-schema","title":"1. Define Your Schema","text":"<pre><code>from strutex import Object, String, Number, Array\n\nschema = Object(\n    description=\"Invoice data\",\n    properties={\n        \"invoice_number\": String(description=\"The invoice ID\"),\n        \"date\": String(description=\"Invoice date\"),\n        \"total\": Number(description=\"Total amount\"),\n        \"items\": Array(\n            items=Object(\n                properties={\n                    \"description\": String(),\n                    \"amount\": Number()\n                }\n            )\n        )\n    }\n)\n</code></pre>"},{"location":"getting-started/#2-create-a-processor","title":"2. Create a Processor","text":"<pre><code>from strutex import DocumentProcessor\n\nprocessor = DocumentProcessor(\n    provider=\"gemini\",\n    model_name=\"gemini-2.5-flash\"\n    # api_key=\"...\"  # Or set GOOGLE_API_KEY env var\n)\n</code></pre>"},{"location":"getting-started/#3-process-a-document","title":"3. Process a Document","text":"<pre><code>result = processor.process(\n    file_path=\"invoice.pdf\",\n    prompt=\"Extract all invoice data.\",\n    schema=schema\n)\n\nprint(f\"Invoice: {result['invoice_number']}\")\nprint(f\"Total: ${result['total']}\")\n</code></pre>"},{"location":"getting-started/#environment-variables","title":"Environment Variables","text":"Variable Description <code>GOOGLE_API_KEY</code> Google Gemini API key <code>OPENAI_API_KEY</code> OpenAI API key (future)"},{"location":"getting-started/#supported-file-types","title":"Supported File Types","text":"Format Extensions Notes PDF <code>.pdf</code> Native support, OCR fallback Images <code>.png</code>, <code>.jpg</code>, <code>.tiff</code> Vision-capable model Excel <code>.xlsx</code>, <code>.xls</code> Converted to text Text <code>.txt</code>, <code>.csv</code> Direct input"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Schema Types \u2014 Learn all available types</li> <li>Prompt Builder \u2014 Build structured prompts</li> <li>Plugin System \u2014 Extend with custom plugins</li> <li>Security \u2014 Add input/output protection</li> </ul>"},{"location":"hooks/","title":"Hooks System","text":"<p>Extend the strutex processing pipeline without modifying core components.</p> <p>New in v0.4.2</p> <p>Callback and decorator hooks \u2014 No pluggy knowledge required! Use simple callbacks or decorators directly on <code>DocumentProcessor</code>.</p>"},{"location":"hooks/#plugins-vs-hooks","title":"Plugins vs Hooks","text":"<p>Before diving in, understand the distinction:</p> Plugins (Provider, Validator, etc.) Hooks (pre_process, post_process) Role core components \u2014 do the actual work Monitors \u2014 observe without replacing Pattern Strategy (replace engine) Observer (wrap engine) Quantity One at a time Many simultaneously Use case \"Use OpenAI instead of Gemini\" \"Log every request and add timestamps\" <p>Rule of thumb:</p> <ul> <li>Changing what runs? \u2192 Plugin</li> <li>Observing when things run? \u2192 Hook</li> </ul>"},{"location":"hooks/#quick-start-recommended","title":"Quick Start (Recommended)","text":"CallbacksDecorators <pre><code>from strutex import DocumentProcessor\n\nprocessor = DocumentProcessor(\n    on_pre_process=lambda fp, prompt, schema, mime, ctx: {\n        \"prompt\": prompt + \"\\nBe precise.\"\n    },\n    on_post_process=lambda result, ctx: {\n        **result, \"processed\": True\n    },\n    on_error=lambda error, fp, ctx: {\n        \"status\": \"error\", \"message\": str(error)\n    }\n)\n</code></pre> <pre><code>from strutex import DocumentProcessor\nfrom datetime import datetime\n\nprocessor = DocumentProcessor()\n\n@processor.on_post_process\ndef add_timestamp(result, context):\n    result[\"processed_at\"] = datetime.now().isoformat()\n    return result\n\n@processor.on_pre_process\ndef add_instructions(file_path, prompt, schema, mime_type, context):\n    return {\"prompt\": prompt + \"\\nExtract all values precisely.\"}\n\n@processor.on_error\ndef handle_rate_limit(error, file_path, context):\n    if \"rate limit\" in str(error).lower():\n        return {\"error\": \"Rate limited, please retry later\"}\n    return None  # Propagate other errors\n</code></pre>"},{"location":"hooks/#hook-types","title":"Hook Types","text":"Hook Called Receives Returns <code>on_pre_process</code> Before processing <code>(file_path, prompt, schema, mime_type, context)</code> <code>{\"prompt\": ...}</code> or <code>None</code> <code>on_post_process</code> After processing <code>(result, context)</code> Modified result or <code>None</code> <code>on_error</code> On exception <code>(error, file_path, context)</code> Fallback result or <code>None</code>"},{"location":"hooks/#callbacks-vs-decorators","title":"Callbacks vs Decorators","text":"Approach Best For Callbacks Quick, inline transformations; lambda functions Decorators Reusable, named functions; complex logic <p>You can use both together \u2014 they execute in order:</p> <pre><code>processor = DocumentProcessor(\n    on_post_process=lambda r, c: {**r, \"via_callback\": True}\n)\n\n@processor.on_post_process\ndef via_decorator(result, context):\n    result[\"via_decorator\"] = True\n    return result\n\n# Result will have both keys\n</code></pre>"},{"location":"hooks/#complete-example","title":"Complete Example","text":"<pre><code>from strutex import DocumentProcessor, Object, String, Number\nfrom datetime import datetime\nimport time\n\nprocessor = DocumentProcessor(provider=\"gemini\")\n\n@processor.on_pre_process\ndef start_timer(file_path, prompt, schema, mime_type, context):\n    context[\"start_time\"] = time.time()\n    print(f\"Processing: {file_path}\")\n    return None\n\n@processor.on_post_process\ndef add_metadata(result, context):\n    result[\"_processed_at\"] = datetime.now().isoformat()\n    result[\"_elapsed_seconds\"] = time.time() - context[\"start_time\"]\n    return result\n\n@processor.on_error\ndef fallback_handler(error, file_path, context):\n    print(f\"Error processing {file_path}: {error}\")\n    return {\"error\": str(error), \"file\": file_path}\n\nschema = Object(properties={\"invoice_number\": String(), \"total\": Number()})\nresult = processor.process(\"invoice.pdf\", \"Extract invoice data\", schema)\n</code></pre>"},{"location":"hooks/#hook-execution-order","title":"Hook Execution Order","text":"<ol> <li>Pre-process hooks run in registration order</li> <li>Security validation (input sanitization)</li> <li>Provider processing (LLM extraction)</li> <li>Security validation (output validation)</li> <li>Post-process hooks run in registration order</li> <li>Pydantic validation (if model was provided)</li> </ol> <p>If an error occurs at step 3, error hooks run until one returns a fallback.</p>"},{"location":"hooks/#advanced-pluggy-integration","title":"Advanced: Pluggy Integration","text":"<p>Callback/decorator hooks are automatically integrated with pluggy. This means:</p> <ul> <li>Your callbacks work alongside global pluggy plugins</li> <li>Third-party packages can register hooks via entry points</li> <li>All hooks execute through the same pipeline</li> </ul>"},{"location":"hooks/#global-pluggy-hooks","title":"Global Pluggy Hooks","text":"<p>For distributed plugins or complex scenarios:</p> <pre><code>from strutex.plugins import hookimpl, register_hook_plugin\n\nclass MetricsPlugin:\n    @hookimpl\n    def pre_process(self, file_path, prompt, schema, mime_type, context):\n        context[\"start_time\"] = time.time()\n\n    @hookimpl\n    def post_process(self, result, context):\n        elapsed = time.time() - context[\"start_time\"]\n        metrics.record(\"extraction_time\", elapsed)\n\nregister_hook_plugin(MetricsPlugin())\n</code></pre>"},{"location":"hooks/#how-it-works","title":"How It Works","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  processor.process() calls call_hook(\"post_process\", ...)       \u2502\n\u2502                              \u2502                                   \u2502\n\u2502                              \u25bc                                   \u2502\n\u2502              pluggy.PluginManager.hook.post_process()           \u2502\n\u2502                              \u2502                                   \u2502\n\u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u2502\n\u2502     \u25bc                        \u25bc                        \u25bc         \u2502\n\u2502  Callback       Decorator       Global Pluggy                   \u2502\n\u2502  Hooks          Hooks           Plugins                         \u2502\n\u2502  (wrapped in    (wrapped in     (registered via                 \u2502\n\u2502  _CallbackHook) _CallbackHook)  register_hook_plugin)           \u2502\n\u2502                                                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"hooks/#api-reference","title":"API Reference","text":"<p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p>"},{"location":"hooks/#strutex.plugins.hooks.register_hook_plugin","title":"<code>register_hook_plugin(plugin: Any) -&gt; None</code>","text":"<p>Register a plugin with hook implementations.</p> PARAMETER DESCRIPTION <code>plugin</code> <p>An object with @hookimpl decorated methods</p> <p> TYPE: <code>Any</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If pluggy is not installed</p> Source code in <code>strutex/plugins/hooks.py</code> <pre><code>def register_hook_plugin(plugin: Any) -&gt; None:\n    \"\"\"\n    Register a plugin with hook implementations.\n\n    Args:\n        plugin: An object with @hookimpl decorated methods\n\n    Raises:\n        RuntimeError: If pluggy is not installed\n    \"\"\"\n    pm = get_plugin_manager()\n    if pm is None:\n        raise RuntimeError(\"pluggy is required for hook plugins. Install with: pip install pluggy\")\n\n    pm.register(plugin)\n</code></pre>"},{"location":"hooks/#strutex.plugins.hooks.unregister_hook_plugin","title":"<code>unregister_hook_plugin(plugin: Any) -&gt; None</code>","text":"<p>Unregister a previously registered hook plugin.</p> PARAMETER DESCRIPTION <code>plugin</code> <p>The plugin object to unregister</p> <p> TYPE: <code>Any</code> </p> Source code in <code>strutex/plugins/hooks.py</code> <pre><code>def unregister_hook_plugin(plugin: Any) -&gt; None:\n    \"\"\"\n    Unregister a previously registered hook plugin.\n\n    Args:\n        plugin: The plugin object to unregister\n    \"\"\"\n    pm = get_plugin_manager()\n    if pm is not None:\n        pm.unregister(plugin)\n</code></pre>"},{"location":"integrations/","title":"Framework Integrations","text":"<p>Strutex integrates with popular AI/ML frameworks, allowing you to use its structured extraction capabilities within existing pipelines.</p> <p>[!WARNING] &gt; Experimental: These integrations are community-maintained and may break with framework updates. LangChain, LlamaIndex, and Haystack evolve rapidly. Pin your versions and test after upgrades. Issues: GitHub</p>"},{"location":"integrations/#installation","title":"Installation","text":"<p>Install with integration extras:</p> <pre><code># LangChain\npip install strutex[langchain]\n\n# LlamaIndex\npip install strutex[llamaindex]\n\n# Haystack\npip install strutex[haystack]\n\n# Unstructured.io fallback\npip install strutex[fallback]\n\n# All integrations\npip install strutex[all]\n</code></pre>"},{"location":"integrations/#langchain","title":"LangChain","text":""},{"location":"integrations/#strutexloader","title":"StrutexLoader","text":"<p>Use Strutex as a LangChain document loader for structured extraction:</p> <pre><code>from strutex.integrations import StrutexLoader\nfrom strutex.schemas import INVOICE_US\n\n# Load and extract structured data\nloader = StrutexLoader(\n    file_path=\"invoice.pdf\",\n    schema=INVOICE_US,\n    provider=\"gemini\"\n)\ndocuments = loader.load()\n\n# Use in LangChain pipeline\nprint(documents[0].page_content)  # JSON string\nprint(documents[0].metadata)       # {\"source\": \"invoice.pdf\", \"extractor\": \"strutex\", ...}\n</code></pre>"},{"location":"integrations/#strutexoutputparser","title":"StrutexOutputParser","text":"<p>Validate LLM output against schemas:</p> <pre><code>from strutex.integrations import StrutexOutputParser\nfrom pydantic import BaseModel\n\nclass InvoiceData(BaseModel):\n    vendor: str\n    total: float\n    date: str\n\nparser = StrutexOutputParser(\n    schema=InvoiceData,\n    validators=[\"schema\", \"sum\", \"date\"]  # Use strutex validators\n)\n\n# Parse LLM response\nresult = parser.parse(llm_response_text)\nprint(result.vendor)  # Validated Pydantic model\n\n# Get format instructions for prompts\ninstructions = parser.get_format_instructions()\n</code></pre>"},{"location":"integrations/#llamaindex","title":"LlamaIndex","text":""},{"location":"integrations/#strutexreader","title":"StrutexReader","text":"<p>Use Strutex as a LlamaIndex document reader:</p> <pre><code>from strutex.integrations import StrutexReader\nfrom strutex.schemas import INVOICE_GENERIC\n\nreader = StrutexReader(\n    schema=INVOICE_GENERIC,\n    provider=\"openai\"\n)\n\ndocuments = reader.load_data(\"invoice.pdf\")\n\n# Use with LlamaIndex index\nfrom llama_index.core import VectorStoreIndex\nindex = VectorStoreIndex.from_documents(documents)\n</code></pre>"},{"location":"integrations/#strutexnodeparser","title":"StrutexNodeParser","text":"<p>Keep structured documents as single nodes (prevents chunking):</p> <pre><code>from strutex.integrations import StrutexReader, StrutexNodeParser\n\nreader = StrutexReader(schema=MySchema)\ndocs = reader.load_data(\"complex_doc.pdf\")\n\n# Don't chunk structured JSON\nparser = StrutexNodeParser()\nnodes = parser.get_nodes_from_documents(docs)\n</code></pre>"},{"location":"integrations/#haystack","title":"Haystack","text":""},{"location":"integrations/#strutexconverter","title":"StrutexConverter","text":"<p>Use Strutex in Haystack pipelines (coming soon):</p> <pre><code>from strutex.integrations import StrutexConverter\nfrom strutex.schemas import INVOICE_US\n\nconverter = StrutexConverter(schema=INVOICE_US)\ndocuments = converter.run(file_path=\"invoice.pdf\")\n</code></pre>"},{"location":"integrations/#unstructured-fallback","title":"Unstructured Fallback","text":""},{"location":"integrations/#unstructuredfallbackprocessor","title":"UnstructuredFallbackProcessor","text":"<p>Hybrid mode: use Strutex first, fall back to Unstructured.io if extraction fails:</p> <pre><code>from strutex.integrations import UnstructuredFallbackProcessor\nfrom strutex.schemas import INVOICE_US\n\nprocessor = UnstructuredFallbackProcessor(\n    schema=INVOICE_US,\n    provider=\"gemini\"\n)\n\n# Tries strutex first, falls back to unstructured.partition()\nresult = processor.process(\"messy_doc.pdf\")\n</code></pre>"},{"location":"integrations/#documentinput","title":"DocumentInput","text":"<p>Handle both file paths and BytesIO (e.g., from HTTP uploads):</p> <pre><code>from strutex import DocumentInput, DocumentProcessor\nimport io\n\n# From file path\ndoc = DocumentInput(\"invoice.pdf\")\n\n# From in-memory bytes (e.g., HTTP request)\npdf_bytes = request.files['document'].read()\ndoc = DocumentInput(io.BytesIO(pdf_bytes), filename=\"upload.pdf\")\n\n# Use with processor\nprocessor = DocumentProcessor(provider=\"gemini\")\nwith doc.as_file_path() as path:\n    result = processor.process(path, schema=MySchema)\n\n# Or get raw bytes\ncontent = doc.get_bytes()\nmime = doc.get_mime_type()  # \"application/pdf\"\n</code></pre>"},{"location":"integrations/#example-full-rag-pipeline","title":"Example: Full RAG Pipeline","text":"<p>Combine Strutex with LangChain for a complete RAG system:</p> <pre><code>from strutex.integrations import StrutexLoader\nfrom strutex.schemas import INVOICE_US\nfrom langchain_community.vectorstores import Chroma\nfrom langchain_openai import OpenAIEmbeddings\nfrom langchain.chains import RetrievalQA\nfrom langchain_openai import ChatOpenAI\n\n# 1. Load and extract invoices\nloader = StrutexLoader(\"invoices/*.pdf\", schema=INVOICE_US)\ndocs = loader.load()\n\n# 2. Create vector store\nvectorstore = Chroma.from_documents(docs, OpenAIEmbeddings())\n\n# 3. Build QA chain\nqa = RetrievalQA.from_chain_type(\n    llm=ChatOpenAI(),\n    retriever=vectorstore.as_retriever()\n)\n\n# 4. Query\nanswer = qa.invoke(\"Which invoice had the highest total?\")\n</code></pre>"},{"location":"plugins/","title":"Plugin System","text":"<p>Everything in strutex is pluggable. Use defaults or register your own implementations.</p> <p>New in v0.3.0</p> <p>Plugin System v2 introduces auto-registration via inheritance, lazy loading, entry points, priority-based ordering, and CLI tooling.</p>"},{"location":"plugins/#architecture-plugins-vs-hooks","title":"Architecture: Plugins vs Hooks","text":"<p>Strutex has two extension mechanisms that serve different purposes:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     DocumentProcessor.process()                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500 HOOKS (Observers) \u2500\u2500\u2500\u2510                                     \u2502\n\u2502  \u2502 \u2022 pre_process           \u2502 \u25c4\u2500\u2500 Logging, timing, prompt mods   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                     \u2502\n\u2502              \u2502                                                   \u2502\n\u2502              \u25bc                                                   \u2502\n\u2502  \u250c\u2500\u2500\u2500 PLUGINS (Components) \u2500\u2510                                    \u2502\n\u2502  \u2502 \u2022 SecurityPlugin         \u2502 \u25c4\u2500\u2500 Validates input               \u2502\n\u2502  \u2502 \u2022 Extractor              \u2502 \u25c4\u2500\u2500 PDF \u2192 text                    \u2502\n\u2502  \u2502 \u2022 Provider               \u2502 \u25c4\u2500\u2500 LLM call                      \u2502\n\u2502  \u2502 \u2022 Validator              \u2502 \u25c4\u2500\u2500 Validates output              \u2502\n\u2502  \u2502 \u2022 Postprocessor          \u2502 \u25c4\u2500\u2500 Transforms result             \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                    \u2502\n\u2502              \u2502                                                   \u2502\n\u2502              \u25bc                                                   \u2502\n\u2502  \u250c\u2500\u2500\u2500 HOOKS (Observers) \u2500\u2500\u2500\u2510                                     \u2502\n\u2502  \u2502 \u2022 post_process          \u2502 \u25c4\u2500\u2500 Add metadata, notifications    \u2502\n\u2502  \u2502 \u2022 on_error              \u2502 \u25c4\u2500\u2500 Fallbacks, alerting            \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                     \u2502\n\u2502                                                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"plugins/#when-to-use-which","title":"When to Use Which?","text":"Feature Plugins (Base Classes) Hooks System Pattern Strategy Pattern Observer/Middleware Pattern Role Drivers \u2014 define how a step is performed Observers \u2014 react to pipeline events Cardinality 1:1 \u2014 one Provider, one Extractor per run 1:N \u2014 many hooks can run simultaneously Complexity Higher \u2014 implement interface methods Lower \u2014 just a function or decorator Goal Interchangeability \u2014 replace the engine Cross-cutting concerns \u2014 add without touching engine <p>Use a Plugin when:</p> <ul> <li>Changing the fundamental logic (e.g., \"use OCR instead of text extraction\")</li> <li>Replacing a core component (different LLM provider)</li> </ul> <p>Use a Hook when:</p> <ul> <li>Observing events (logging, timing, metrics)</li> <li>Modifying data generically (add metadata to all results)</li> <li>Handling errors (fallbacks, alerting)</li> </ul>"},{"location":"plugins/#plugin-types","title":"Plugin Types","text":"Type Purpose Built-in Examples <code>provider</code> LLM backends Gemini, OpenAI <code>security</code> Input/output protection InputSanitizer, PromptInjectionDetector <code>extractor</code> Document parsing PDF, Image, Excel <code>validator</code> Output validation Schema, business rules <code>postprocessor</code> Data transformation DateNormalizer <p>The <code>PluginType</code> enum provides type-safe access:</p> <pre><code>from strutex.plugins import PluginType\n\nPluginType.PROVIDER      # \"provider\"\nPluginType.EXTRACTOR     # \"extractor\"\nPluginType.VALIDATOR     # \"validator\"\nPluginType.POSTPROCESSOR # \"postprocessor\"\nPluginType.SECURITY      # \"security\"\n</code></pre>"},{"location":"plugins/#quick-start","title":"Quick Start","text":""},{"location":"plugins/#auto-registration-via-inheritance","title":"Auto-Registration via Inheritance","text":"<p>Simply inherit from a base class and your plugin is automatically registered:</p> <pre><code>from strutex.plugins import Provider\n\nclass MyProvider(Provider):\n    \"\"\"Auto-registered as 'myprovider'\"\"\"\n    capabilities = [\"vision\"]\n\n    def process(self, file_path, prompt, schema, mime_type, **kwargs):\n        return {\"result\": \"data\"}\n</code></pre> <p>That's it! No decorators or manual registration needed.</p>"},{"location":"plugins/#customizing-registration","title":"Customizing Registration","text":"<p>Use class arguments to customize the name:</p> <pre><code>class FastProvider(Provider, name=\"fast\"):\n    \"\"\"Registered as 'fast' with high priority\"\"\"\n    priority = 90  # Priority is a class attribute\n    cost = 0.5\n    capabilities = [\"vision\", \"batch\"]\n\n    def process(self, *args, **kwargs):\n        ...\n</code></pre>"},{"location":"plugins/#opting-out-of-auto-registration","title":"Opting Out of Auto-Registration","text":"<p>For intermediate base classes:</p> <pre><code>class BasePdfProvider(Provider, register=False):\n    \"\"\"NOT registered - abstract base class\"\"\"\n    def common_pdf_logic(self):\n        ...\n\nclass AdobeProvider(BasePdfProvider):\n    \"\"\"Registered as 'adobeprovider'\"\"\"\n    def process(self, *args, **kwargs):\n        ...\n</code></pre> <p>Tip</p> <p>Classes with unimplemented <code>@abstractmethod</code>s are automatically skipped.</p>"},{"location":"plugins/#plugin-attributes","title":"Plugin Attributes","text":"Attribute Type Default Description <code>strutex_plugin_version</code> <code>str</code> <code>\"1.0\"</code> API version for compatibility <code>priority</code> <code>int</code> <code>50</code> Order in waterfall (0-100, higher = preferred) <code>cost</code> <code>float</code> <code>1.0</code> Cost hint (lower = cheaper) <code>capabilities</code> <code>list</code> <code>[]</code> Features this plugin supports"},{"location":"plugins/#registration-methods","title":"Registration Methods","text":""},{"location":"plugins/#1-auto-registration-recommended","title":"1. Auto-Registration (Recommended)","text":"<p>Just inherit from a base class:</p> <pre><code>class MyProvider(Provider):\n    def process(self, ...): ...\n# \u2192 Registered as \"myprovider\"\n\nclass MyProvider(Provider, name=\"custom\"):\n    def process(self, ...): ...\n# \u2192 Registered as \"custom\"\n</code></pre>"},{"location":"plugins/#2-entry-points-for-packages","title":"2. Entry Points (For Packages)","text":"<p>For distributable packages, register in <code>pyproject.toml</code>:</p> <pre><code>[project.entry-points.\"strutex.providers\"]\nmy_provider = \"my_package:MyProvider\"\n\n[project.entry-points.\"strutex.validators\"]\nmy_validator = \"my_package:MyValidator\"\n</code></pre> <p>Plugins are lazy loaded \u2014 only imported when first used.</p>"},{"location":"plugins/#3-manual-registration","title":"3. Manual Registration","text":"<pre><code>from strutex.plugins import PluginRegistry\n\nPluginRegistry.register(\"provider\", \"my_provider\", MyProvider)\n</code></pre>"},{"location":"plugins/#cli-commands","title":"CLI Commands","text":"<pre><code># List all plugins\nstrutex plugins list\n\n# Filter by type\nstrutex plugins list --type provider\n\n# JSON output\nstrutex plugins list --json\n\n# Plugin details\nstrutex plugins info gemini --type provider\n\n# Refresh discovery cache\nstrutex plugins refresh\n</code></pre>"},{"location":"plugins/#creating-custom-plugins","title":"Creating Custom Plugins","text":""},{"location":"plugins/#custom-provider","title":"Custom Provider","text":"<pre><code>from strutex.plugins import Provider\n\nclass OllamaProvider(Provider):\n    priority = 60\n    capabilities = [\"local\", \"vision\"]\n\n    def __init__(self, model=\"llama3\"):\n        self.model = model\n\n    def process(self, file_path, prompt, schema, mime_type, **kwargs):\n        # Your implementation\n        ...\n</code></pre>"},{"location":"plugins/#custom-validator","title":"Custom Validator","text":"<pre><code>from strutex.plugins import Validator, ValidationResult\n\nclass SumValidator(Validator):\n    \"\"\"Verify line items sum to total.\"\"\"\n    priority = 70\n\n    def validate(self, data, schema=None):\n        items_sum = sum(i.get(\"amount\", 0) for i in data.get(\"items\", []))\n        total = data.get(\"total\", 0)\n\n        if abs(items_sum - total) &gt; 0.01:\n            return ValidationResult(\n                valid=False,\n                data=data,\n                issues=[f\"Sum mismatch: {items_sum} != {total}\"]\n            )\n        return ValidationResult(valid=True, data=data)\n</code></pre>"},{"location":"plugins/#custom-postprocessor","title":"Custom Postprocessor","text":"<pre><code>from strutex.plugins import Postprocessor\nimport re\n\nclass DateNormalizer(Postprocessor):\n    \"\"\"Convert DD.MM.YYYY to YYYY-MM-DD.\"\"\"\n\n    def process(self, data):\n        result = data.copy()\n        if \"date\" in result:\n            match = re.match(r'(\\d{2})\\.(\\d{2})\\.(\\d{4})', result[\"date\"])\n            if match:\n                d, m, y = match.groups()\n                result[\"date\"] = f\"{y}-{m}-{d}\"\n        return result\n</code></pre>"},{"location":"plugins/#api-reference","title":"API Reference","text":"<p>options: show_root_heading: true members: - register - get - list - discover</p> <p>options: show_root_heading: true</p>"},{"location":"plugins/#strutex.plugins.PluginRegistry","title":"<code>PluginRegistry</code>","text":"<p>Central registry for all plugin types with lazy loading.</p> <p>Plugins are stored as EntryPoint objects and only loaded when first accessed via get(). This improves startup time and avoids importing unused dependencies.</p> Usage"},{"location":"plugins/#strutex.plugins.PluginRegistry--get-a-plugin-loads-on-first-access","title":"Get a plugin (loads on first access)","text":"<p>cls = PluginRegistry.get(\"provider\", \"gemini\")</p>"},{"location":"plugins/#strutex.plugins.PluginRegistry--list-all-plugins-does-not-load-them","title":"List all plugins (does not load them)","text":"<p>all_providers = PluginRegistry.list(\"provider\")</p>"},{"location":"plugins/#strutex.plugins.PluginRegistry--force-discovery-from-entry-points","title":"Force discovery from entry points","text":"<p>count = PluginRegistry.discover()</p>"},{"location":"plugins/#strutex.plugins.PluginRegistry.clear","title":"<code>clear(plugin_type: Optional[str] = None) -&gt; None</code>  <code>classmethod</code>","text":"<p>Clear registered plugins.</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>If provided, only clear this type. Otherwise clear all.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef clear(cls, plugin_type: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Clear registered plugins.\n\n    Args:\n        plugin_type: If provided, only clear this type. Otherwise clear all.\n    \"\"\"\n    if plugin_type:\n        cls._entry_points.pop(plugin_type, None)\n        cls._loaded.pop(plugin_type, None)\n        cls._manual.pop(plugin_type, None)\n    else:\n        cls._entry_points.clear()\n        cls._loaded.clear()\n        cls._manual.clear()\n        cls._discovered = False\n</code></pre>"},{"location":"plugins/#strutex.plugins.PluginRegistry.discover","title":"<code>discover(group_prefix: str = 'strutex', force: bool = False) -&gt; int</code>  <code>classmethod</code>","text":"<p>Discover and register plugins from entry points.</p> <p>Scans for entry points matching the pattern: - strutex.providers - strutex.validators - strutex.postprocessors - strutex.security - etc.</p> <p>Entry points are stored for lazy loading - they are not imported until first use via get().</p> PARAMETER DESCRIPTION <code>group_prefix</code> <p>Entry point group prefix (default: \"strutex\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'strutex'</code> </p> <code>force</code> <p>Force re-discovery even if already discovered</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>int</code> <p>Number of entry points discovered</p> <p>Example pyproject.toml:     [project.entry-points.\"strutex.providers\"]     my_provider = \"my_package:MyProvider\"</p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef discover(cls, group_prefix: str = \"strutex\", force: bool = False) -&gt; int:\n    \"\"\"\n    Discover and register plugins from entry points.\n\n    Scans for entry points matching the pattern:\n    - strutex.providers\n    - strutex.validators\n    - strutex.postprocessors\n    - strutex.security\n    - etc.\n\n    Entry points are stored for lazy loading - they are not imported\n    until first use via get().\n\n    Args:\n        group_prefix: Entry point group prefix (default: \"strutex\")\n        force: Force re-discovery even if already discovered\n\n    Returns:\n        Number of entry points discovered\n\n    Example pyproject.toml:\n        [project.entry-points.\"strutex.providers\"]\n        my_provider = \"my_package:MyProvider\"\n    \"\"\"\n    if cls._discovered and not force:\n        return sum(len(eps) for eps in cls._entry_points.values())\n\n    discovered = 0\n\n    # Get entry_points function\n    if sys.version_info &gt;= (3, 10):\n        from importlib.metadata import entry_points\n    else:\n        try:\n            from importlib_metadata import entry_points\n        except ImportError:\n            cls._discovered = True\n            return 0\n\n    # Get all entry point groups\n    try:\n        all_eps = entry_points()\n\n        # Get group names that match our prefix\n        if hasattr(all_eps, 'groups'):\n            # Python 3.12+ style\n            groups = [g for g in all_eps.groups if g.startswith(f\"{group_prefix}.\")]\n        elif hasattr(all_eps, 'keys'):\n            # Python 3.9-3.11 style (dict-like)\n            groups = [g for g in all_eps.keys() if g.startswith(f\"{group_prefix}.\")]\n        else:\n            groups = []\n    except Exception:\n        cls._discovered = True\n        return 0\n\n    for group in groups:\n        # Extract plugin type from group name\n        # e.g., \"strutex.providers\" -&gt; \"provider\"\n        plugin_type = group.replace(f\"{group_prefix}.\", \"\").rstrip(\"s\")\n\n        if plugin_type not in cls._entry_points:\n            cls._entry_points[plugin_type] = {}\n\n        try:\n            # Get entry points for this group\n            if hasattr(all_eps, 'select'):\n                eps = all_eps.select(group=group)\n            else:\n                eps = all_eps.get(group, [])\n\n            for ep in eps:\n                # Store entry point for lazy loading\n                cls._entry_points[plugin_type][ep.name.lower()] = ep\n                discovered += 1\n\n        except Exception:\n            pass\n\n    cls._discovered = True\n    return discovered\n</code></pre>"},{"location":"plugins/#strutex.plugins.PluginRegistry.get","title":"<code>get(plugin_type: str, name: str) -&gt; Optional[Type]</code>  <code>classmethod</code>","text":"<p>Get a registered plugin class by type and name.</p> <p>If the plugin is registered via entry point and not yet loaded, it will be loaded on first access (lazy loading).</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>Type of plugin</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name of the plugin</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Optional[Type]</code> <p>The plugin class, or None if not found</p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef get(cls, plugin_type: str, name: str) -&gt; Optional[Type]:\n    \"\"\"\n    Get a registered plugin class by type and name.\n\n    If the plugin is registered via entry point and not yet loaded,\n    it will be loaded on first access (lazy loading).\n\n    Args:\n        plugin_type: Type of plugin\n        name: Name of the plugin\n\n    Returns:\n        The plugin class, or None if not found\n    \"\"\"\n    name_lower = name.lower()\n\n    # Ensure discovery has run\n    if not cls._discovered:\n        cls.discover()\n\n    # Check loaded cache first\n    if name_lower in cls._loaded.get(plugin_type, {}):\n        return cls._loaded[plugin_type][name_lower]\n\n    # Check manual registrations\n    if name_lower in cls._manual.get(plugin_type, {}):\n        return cls._manual[plugin_type][name_lower]\n\n    # Try to lazy load from entry point\n    ep = cls._entry_points.get(plugin_type, {}).get(name_lower)\n    if ep is not None:\n        plugin_cls = cls._load_entry_point(ep, plugin_type, name_lower)\n        if plugin_cls is not None:\n            return plugin_cls\n\n    return None\n</code></pre>"},{"location":"plugins/#strutex.plugins.PluginRegistry.get_plugin_info","title":"<code>get_plugin_info(plugin_type: str, name: str) -&gt; Optional[Dict[str, Any]]</code>  <code>classmethod</code>","text":"<p>Get metadata about a plugin without necessarily loading it.</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>Type of plugin</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name of the plugin</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Optional[Dict[str, Any]]</code> <p>Dict with plugin info, or None if not found</p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef get_plugin_info(cls, plugin_type: str, name: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"\n    Get metadata about a plugin without necessarily loading it.\n\n    Args:\n        plugin_type: Type of plugin\n        name: Name of the plugin\n\n    Returns:\n        Dict with plugin info, or None if not found\n    \"\"\"\n    name_lower = name.lower()\n\n    if not cls._discovered:\n        cls.discover()\n\n    # Check if loaded\n    if name_lower in cls._loaded.get(plugin_type, {}):\n        plugin_cls = cls._loaded[plugin_type][name_lower]\n        return {\n            \"name\": name_lower,\n            \"version\": getattr(plugin_cls, \"strutex_plugin_version\", \"unknown\"),\n            \"priority\": getattr(plugin_cls, \"priority\", 50),\n            \"cost\": getattr(plugin_cls, \"cost\", 1.0),\n            \"capabilities\": getattr(plugin_cls, \"capabilities\", []),\n            \"loaded\": True,\n            \"healthy\": cls._check_health(plugin_cls),\n        }\n\n    # Check entry point\n    ep = cls._entry_points.get(plugin_type, {}).get(name_lower)\n    if ep is not None:\n        return {\n            \"name\": name_lower,\n            \"entry_point\": f\"{ep.group}:{ep.name}\",\n            \"loaded\": False,\n            \"healthy\": None,  # Unknown until loaded\n        }\n\n    return None\n</code></pre>"},{"location":"plugins/#strutex.plugins.PluginRegistry.get_sorted","title":"<code>get_sorted(plugin_type: str, reverse: bool = True) -&gt; List[Tuple[str, Type]]</code>  <code>classmethod</code>","text":"<p>Get all plugins of a type sorted by priority.</p> <p>Useful for waterfall selection where you want to try higher-priority plugins first.</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>Type of plugin</p> <p> TYPE: <code>str</code> </p> <code>reverse</code> <p>If True (default), higher priority first</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>List[Tuple[str, Type]]</code> <p>List of (name, class) tuples sorted by priority</p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef get_sorted(cls, plugin_type: str, reverse: bool = True) -&gt; List[Tuple[str, Type]]:\n    \"\"\"\n    Get all plugins of a type sorted by priority.\n\n    Useful for waterfall selection where you want to try\n    higher-priority plugins first.\n\n    Args:\n        plugin_type: Type of plugin\n        reverse: If True (default), higher priority first\n\n    Returns:\n        List of (name, class) tuples sorted by priority\n    \"\"\"\n    plugins = cls.list(plugin_type)\n    return sorted(\n        plugins.items(),\n        key=lambda x: getattr(x[1], 'priority', 50),\n        reverse=reverse\n    )\n</code></pre>"},{"location":"plugins/#strutex.plugins.PluginRegistry.list","title":"<code>list(plugin_type: str) -&gt; Dict[str, Type]</code>  <code>classmethod</code>","text":"<p>List all plugins of a given type.</p> <p>Note: This loads all plugins of the type. Use list_names() for a lightweight listing without loading.</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>Type of plugin</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Dict[str, Type]</code> <p>Dictionary mapping names to plugin classes</p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef list(cls, plugin_type: str) -&gt; Dict[str, Type]:\n    \"\"\"\n    List all plugins of a given type.\n\n    Note: This loads all plugins of the type. Use list_names()\n    for a lightweight listing without loading.\n\n    Args:\n        plugin_type: Type of plugin\n\n    Returns:\n        Dictionary mapping names to plugin classes\n    \"\"\"\n    if not cls._discovered:\n        cls.discover()\n\n    result = {}\n\n    # Get all names from entry points and manual registrations\n    all_names = set()\n    all_names.update(cls._entry_points.get(plugin_type, {}).keys())\n    all_names.update(cls._manual.get(plugin_type, {}).keys())\n    all_names.update(cls._loaded.get(plugin_type, {}).keys())\n\n    # Load each plugin\n    for name in all_names:\n        plugin_cls = cls.get(plugin_type, name)\n        if plugin_cls is not None:\n            result[name] = plugin_cls\n\n    return result\n</code></pre>"},{"location":"plugins/#strutex.plugins.PluginRegistry.list_names","title":"<code>list_names(plugin_type: str) -&gt; List[str]</code>  <code>classmethod</code>","text":"<p>List names of all plugins of a given type without loading them.</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>Type of plugin</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>List[str]</code> <p>List of plugin names</p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef list_names(cls, plugin_type: str) -&gt; List[str]:\n    \"\"\"\n    List names of all plugins of a given type without loading them.\n\n    Args:\n        plugin_type: Type of plugin\n\n    Returns:\n        List of plugin names\n    \"\"\"\n    if not cls._discovered:\n        cls.discover()\n\n    names = set()\n    names.update(cls._entry_points.get(plugin_type, {}).keys())\n    names.update(cls._manual.get(plugin_type, {}).keys())\n    names.update(cls._loaded.get(plugin_type, {}).keys())\n\n    return sorted(names)\n</code></pre>"},{"location":"plugins/#strutex.plugins.PluginRegistry.list_types","title":"<code>list_types() -&gt; List[str]</code>  <code>classmethod</code>","text":"<p>List all registered plugin types.</p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef list_types(cls) -&gt; List[str]:\n    \"\"\"List all registered plugin types.\"\"\"\n    if not cls._discovered:\n        cls.discover()\n\n    types = set()\n    types.update(cls._entry_points.keys())\n    types.update(cls._manual.keys())\n    types.update(cls._loaded.keys())\n\n    return sorted(types)\n</code></pre>"},{"location":"plugins/#strutex.plugins.PluginRegistry.register","title":"<code>register(plugin_type: str, name: str, plugin_cls: Type) -&gt; None</code>  <code>classmethod</code>","text":"<p>Register a plugin class manually.</p> <p>This is used by the @register decorator for backwards compatibility. Prefer using entry points in pyproject.toml for new plugins.</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>Type of plugin (e.g., \"provider\", \"security\", \"validator\")</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Unique name for this plugin</p> <p> TYPE: <code>str</code> </p> <code>plugin_cls</code> <p>The plugin class to register</p> <p> TYPE: <code>Type</code> </p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef register(cls, plugin_type: str, name: str, plugin_cls: Type) -&gt; None:\n    \"\"\"\n    Register a plugin class manually.\n\n    This is used by the @register decorator for backwards compatibility.\n    Prefer using entry points in pyproject.toml for new plugins.\n\n    Args:\n        plugin_type: Type of plugin (e.g., \"provider\", \"security\", \"validator\")\n        name: Unique name for this plugin\n        plugin_cls: The plugin class to register\n    \"\"\"\n    if plugin_type not in cls._manual:\n        cls._manual[plugin_type] = {}\n\n    cls._manual[plugin_type][name.lower()] = plugin_cls\n\n    # Also add to loaded cache\n    if plugin_type not in cls._loaded:\n        cls._loaded[plugin_type] = {}\n    cls._loaded[plugin_type][name.lower()] = plugin_cls\n</code></pre>"},{"location":"plugins/#strutex.plugins.Provider","title":"<code>Provider</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for LLM providers.</p> <p>All providers must implement the process method to handle document extraction via their specific LLM API.</p> <p>Subclassing auto-registers the plugin. Use class arguments to customize:</p> <pre><code>class MyProvider(Provider, name=\"custom\", priority=90):\n    ...\n</code></pre> ATTRIBUTE DESCRIPTION <code>strutex_plugin_version</code> <p>API version for compatibility checks</p> <p> TYPE: <code>str</code> </p> <code>priority</code> <p>Ordering priority (0-100, higher = preferred)</p> <p> TYPE: <code>int</code> </p> <code>cost</code> <p>Cost hint for optimization (lower = cheaper)</p> <p> TYPE: <code>float</code> </p> <code>capabilities</code> <p>List of supported features</p> <p> TYPE: <code>List[str]</code> </p>"},{"location":"plugins/#strutex.plugins.Provider.aprocess","title":"<code>aprocess(file_path: str, prompt: str, schema: Schema, mime_type: str, **kwargs) -&gt; Any</code>  <code>async</code>","text":"<p>Async version of process. Override for true async support. Default implementation calls sync version.</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>async def aprocess(\n    self,\n    file_path: str,\n    prompt: str,\n    schema: Schema,\n    mime_type: str,\n    **kwargs\n) -&gt; Any:\n    \"\"\"\n    Async version of process. Override for true async support.\n    Default implementation calls sync version.\n    \"\"\"\n    return self.process(file_path, prompt, schema, mime_type, **kwargs)\n</code></pre>"},{"location":"plugins/#strutex.plugins.Provider.has_capability","title":"<code>has_capability(capability: str) -&gt; bool</code>","text":"<p>Check if this provider has a specific capability.</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>def has_capability(self, capability: str) -&gt; bool:\n    \"\"\"Check if this provider has a specific capability.\"\"\"\n    return capability.lower() in [c.lower() for c in self.capabilities]\n</code></pre>"},{"location":"plugins/#strutex.plugins.Provider.health_check","title":"<code>health_check() -&gt; bool</code>  <code>classmethod</code>","text":"<p>Check if this provider is healthy and ready to use.</p> <p>Override in subclasses for custom health checks (e.g., API connectivity).</p> RETURNS DESCRIPTION <code>bool</code> <p>True if healthy, False otherwise</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>@classmethod\ndef health_check(cls) -&gt; bool:\n    \"\"\"\n    Check if this provider is healthy and ready to use.\n\n    Override in subclasses for custom health checks (e.g., API connectivity).\n\n    Returns:\n        True if healthy, False otherwise\n    \"\"\"\n    return True\n</code></pre>"},{"location":"plugins/#strutex.plugins.Provider.process","title":"<code>process(file_path: str, prompt: str, schema: Schema, mime_type: str, **kwargs) -&gt; Any</code>  <code>abstractmethod</code>","text":"<p>Process a document and extract structured data.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>Path to the document file</p> <p> TYPE: <code>str</code> </p> <code>prompt</code> <p>Extraction prompt/instructions</p> <p> TYPE: <code>str</code> </p> <code>schema</code> <p>Expected output schema</p> <p> TYPE: <code>Schema</code> </p> <code>mime_type</code> <p>MIME type of the file</p> <p> TYPE: <code>str</code> </p> <code>**kwargs</code> <p>Provider-specific options</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>Extracted data matching the schema</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>@abstractmethod\ndef process(\n    self,\n    file_path: str,\n    prompt: str,\n    schema: Schema,\n    mime_type: str,\n    **kwargs\n) -&gt; Any:\n    \"\"\"\n    Process a document and extract structured data.\n\n    Args:\n        file_path: Path to the document file\n        prompt: Extraction prompt/instructions\n        schema: Expected output schema\n        mime_type: MIME type of the file\n        **kwargs: Provider-specific options\n\n    Returns:\n        Extracted data matching the schema\n    \"\"\"\n    pass\n</code></pre>"},{"location":"prompt-builder/","title":"Prompt Builder","text":"<p>Build structured, organized prompts with the <code>StructuredPrompt</code> fluent API.</p>"},{"location":"prompt-builder/#basic-usage","title":"Basic Usage","text":"<pre><code>from strutex import StructuredPrompt\n\nprompt = (\n    StructuredPrompt()\n    .add_general_rule(\"Extract data exactly as shown\")\n    .add_field_rule(\"invoice_number\", \"Look for 'Invoice No'\")\n    .add_output_guideline(\"Return valid JSON only\")\n    .compile()\n)\n</code></pre> <p>Output:</p> <pre><code>You are a highly accurate AI Data Extraction Assistant.\n\n### 1. General Principles\n- Extract data exactly as shown\n\n### 2. Field Rules\n\n**invoice_number**:\n- Look for 'Invoice No'\n\n### 3. Output Format\n- Return valid JSON only\n</code></pre>"},{"location":"prompt-builder/#multiple-rules","title":"Multiple Rules","text":"<p>Use variadic arguments for cleaner code:</p> <pre><code>prompt = (\n    StructuredPrompt()\n    .add_general_rule(\n        \"Extract all visible data exactly as shown\",\n        \"Use null for missing values\",\n        \"Dates must be in YYYY-MM-DD format\",\n        \"Numbers use dot as decimal separator\"\n    )\n    .compile()\n)\n</code></pre>"},{"location":"prompt-builder/#critical-fields","title":"Critical Fields","text":"<p>Mark important fields as critical:</p> <pre><code>prompt = (\n    StructuredPrompt()\n    .add_field_rule(\n        \"total\",\n        \"Final payable amount\",\n        \"Usually labeled 'Total' or 'Grand Total'\",\n        critical=True\n    )\n    .compile()\n)\n</code></pre> <p>Output:</p> <pre><code>**total**:\n- **CRITICAL**: Final payable amount\n- **CRITICAL**: Usually labeled 'Total' or 'Grand Total'\n</code></pre>"},{"location":"prompt-builder/#custom-persona","title":"Custom Persona","text":"<pre><code>prompt = StructuredPrompt(\n    persona=\"You are an expert German invoice analyst.\"\n)\n</code></pre>"},{"location":"prompt-builder/#complete-example","title":"Complete Example","text":"<pre><code>from strutex import StructuredPrompt\n\nprompt = (\n    StructuredPrompt(\n        persona=\"You are a precise invoice extraction specialist.\"\n    )\n    .add_general_rule(\n        \"Extract all data exactly as shown in the document\",\n        \"Do not invent missing values - use null\",\n        \"Ignore handwritten annotations\"\n    )\n    .add_field_rule(\n        \"invoice_number\",\n        \"Look for 'Invoice No', 'Invoice #', 'Inv-'\",\n        critical=True\n    )\n    .add_field_rule(\n        \"date\",\n        \"Invoice date, convert to YYYY-MM-DD format\"\n    )\n    .add_field_rule(\n        \"total\",\n        \"Final amount including tax\",\n        \"May be labeled 'Total', 'Amount Due', 'Grand Total'\",\n        critical=True\n    )\n    .add_output_guideline(\n        \"Return valid JSON only\",\n        \"No markdown code blocks\",\n        \"Match the provided schema exactly\"\n    )\n    .compile()\n)\n</code></pre>"},{"location":"prompt-builder/#using-with-processor","title":"Using with Processor","text":"<pre><code>from strutex import DocumentProcessor, StructuredPrompt\n\nprompt = (\n    StructuredPrompt()\n    .add_general_rule(\"Extract invoice data\")\n    .add_field_rule(\"total\", \"Total amount\", critical=True)\n    .compile()\n)\n\nprocessor = DocumentProcessor(provider=\"gemini\")\nresult = processor.process(\"invoice.pdf\", prompt, schema)\n</code></pre>"},{"location":"provider-chains/","title":"Provider Chains","text":"<p>Provider chains allow automatic fallback between multiple providers for reliability and cost optimization.</p>"},{"location":"provider-chains/#quick-start","title":"Quick Start","text":"<pre><code>from strutex import DocumentProcessor, ProviderChain, local_first_chain\n\n# Use a pre-built chain\nprocessor = DocumentProcessor(provider=local_first_chain())\n\n# Or create a custom chain\nfrom strutex import GeminiProvider, OllamaProvider, OpenAIProvider\n\nchain = ProviderChain([\n    OllamaProvider(model=\"llama3.2-vision\"),  # Try local first\n    GeminiProvider(),                          # Then Gemini\n    OpenAIProvider()                           # Finally OpenAI\n])\n\nprocessor = DocumentProcessor(provider=chain)\n</code></pre>"},{"location":"provider-chains/#how-it-works","title":"How It Works","text":"<p>When you call <code>process()</code> on a ProviderChain:</p> <ol> <li>The first provider attempts the extraction</li> <li>If it fails (any exception), the chain moves to the next provider</li> <li>Process continues until one succeeds or all fail</li> <li>If all fail, raises <code>ProviderChainError</code> with details</li> </ol> <pre><code>graph LR\n    A[Request] --&gt; B[Provider 1]\n    B --&gt;|Success| C[Return Result]\n    B --&gt;|Fail| D[Provider 2]\n    D --&gt;|Success| C\n    D --&gt;|Fail| E[Provider 3]\n    E --&gt;|Success| C\n    E --&gt;|Fail| F[ProviderChainError]</code></pre>"},{"location":"provider-chains/#pre-built-chains","title":"Pre-built Chains","text":""},{"location":"provider-chains/#local_first_chain","title":"local_first_chain()","text":"<p>Prefers local/free providers:</p> <pre><code>from strutex import local_first_chain\n\nchain = local_first_chain()\n# Order: Ollama \u2192 Gemini \u2192 OpenAI\n</code></pre>"},{"location":"provider-chains/#cost_optimized_chain","title":"cost_optimized_chain()","text":"<p>Ordered by cost (cheapest first):</p> <pre><code>from strutex import cost_optimized_chain\n\nchain = cost_optimized_chain()\n# Order: Ollama (free) \u2192 Gemini \u2192 Anthropic \u2192 OpenAI\n</code></pre>"},{"location":"provider-chains/#custom-chains","title":"Custom Chains","text":""},{"location":"provider-chains/#using-provider-instances","title":"Using Provider Instances","text":"<pre><code>from strutex import ProviderChain, OllamaProvider, GeminiProvider\n\nchain = ProviderChain([\n    OllamaProvider(model=\"llama3.2-vision\", timeout=30),\n    GeminiProvider(model=\"gemini-2.5-flash\")\n])\n</code></pre>"},{"location":"provider-chains/#using-provider-names","title":"Using Provider Names","text":"<pre><code>from strutex.providers import create_fallback_chain\n\n# Resolves provider names automatically\nchain = create_fallback_chain(\"ollama\", \"gemini\", \"openai\")\n</code></pre>"},{"location":"provider-chains/#fallback-callbacks","title":"Fallback Callbacks","text":"<p>Get notified when fallback occurs:</p> <pre><code>def on_fallback(provider, error):\n    print(f\"Provider {provider.__class__.__name__} failed: {error}\")\n    # Log, send alert, etc.\n\nchain = ProviderChain(\n    providers=[\"ollama\", \"gemini\"],\n    on_fallback=on_fallback\n)\n</code></pre>"},{"location":"provider-chains/#tracking-which-provider-succeeded","title":"Tracking Which Provider Succeeded","text":"<pre><code>chain = ProviderChain([\"ollama\", \"gemini\", \"openai\"])\n\nresult = chain.process(file_path, prompt, schema, mime_type)\n\n# Check which provider was used\nprint(f\"Used: {chain.last_provider.__class__.__name__}\")\n</code></pre>"},{"location":"provider-chains/#async-support","title":"Async Support","text":"<pre><code>import asyncio\n\nasync def extract():\n    chain = ProviderChain([\"ollama\", \"gemini\"])\n    result = await chain.aprocess(file_path, prompt, schema, mime_type)\n    return result\n\nresult = asyncio.run(extract())\n</code></pre>"},{"location":"provider-chains/#error-handling","title":"Error Handling","text":"<pre><code>from strutex.providers import ProviderChain, ProviderChainError\n\nchain = ProviderChain([\"ollama\", \"gemini\"])\n\ntry:\n    result = chain.process(...)\nexcept ProviderChainError as e:\n    print(f\"All providers failed: {e}\")\n\n    # Access individual errors\n    for provider, error in e.errors:\n        print(f\"  - {provider.__class__.__name__}: {error}\")\n</code></pre>"},{"location":"provider-chains/#available-providers","title":"Available Providers","text":"Provider Cost Priority Capabilities <code>OllamaProvider</code> 0.0 40 vision, local <code>GroqProvider</code> 0.3 45 fast, vision <code>GeminiProvider</code> 1.0 50 vision <code>AnthropicProvider</code> 1.5 55 vision, large_context <code>OpenAIProvider</code> 2.0 60 vision, function_calling"},{"location":"provider-chains/#best-practices","title":"Best Practices","text":"<ol> <li>Put cheapest/fastest providers first for cost optimization</li> <li>Put most reliable providers last as final fallback</li> <li>Set appropriate timeouts on each provider</li> <li>Use callbacks to log/alert on failures</li> <li>Check <code>last_provider</code> to understand usage patterns</li> </ol>"},{"location":"providers/","title":"Providers","text":"<p>LLM providers handle the actual document processing via their respective APIs.</p>"},{"location":"providers/#built-in-providers","title":"Built-in Providers","text":"<p>strutex includes 6 production-ready providers:</p> Provider Cost Priority Capabilities Env Variable <code>GeminiProvider</code> 1.0 50 vision <code>GOOGLE_API_KEY</code> <code>OpenAIProvider</code> 2.0 60 vision, function_calling <code>OPENAI_API_KEY</code> <code>AnthropicProvider</code> 1.5 55 vision, large_context <code>ANTHROPIC_API_KEY</code> <code>OllamaProvider</code> 0.0 40 vision, local <code>OLLAMA_HOST</code> <code>GroqProvider</code> 0.3 45 fast, vision <code>GROQ_API_KEY</code> <code>LangdockProvider</code> 1.0 55 enterprise, multi_model <code>LANGDOCK_API_KEY</code>"},{"location":"providers/#geminiprovider","title":"GeminiProvider","text":"<p>Google's Gemini models (default provider).</p> <pre><code>from strutex import DocumentProcessor, GeminiProvider\n\n# Via string\nprocessor = DocumentProcessor(provider=\"gemini\")\n\n# Via instance (more control)\nprovider = GeminiProvider(\n    api_key=\"...\",  # or set GOOGLE_API_KEY\n    model=\"gemini-2.5-flash\"\n)\nprocessor = DocumentProcessor(provider=provider)\n</code></pre> <p>Features:</p> <ul> <li>Native PDF/image processing (vision)</li> <li>Structured JSON output</li> <li>Fast and cost-effective</li> </ul>"},{"location":"providers/#openaiprovider","title":"OpenAIProvider","text":"<p>OpenAI GPT-4o and GPT-4 Vision.</p> <pre><code>from strutex import OpenAIProvider\n\nprovider = OpenAIProvider(\n    api_key=\"...\",  # or set OPENAI_API_KEY\n    model=\"gpt-4o\",\n    base_url=None,  # Custom endpoint (Azure, proxy)\n    timeout=120.0\n)\n</code></pre> <p>Features:</p> <ul> <li>Vision (GPT-4o, GPT-4 Vision)</li> <li>JSON response format</li> <li>Function calling support</li> <li>Custom base URL for Azure/proxies</li> </ul> <p>Models:</p> <ul> <li><code>gpt-4o</code> (recommended)</li> <li><code>gpt-4-turbo</code></li> <li><code>gpt-4-vision-preview</code></li> </ul>"},{"location":"providers/#anthropicprovider","title":"AnthropicProvider","text":"<p>Claude 3.5 Sonnet and Claude 3 Opus.</p> <pre><code>from strutex import AnthropicProvider\n\nprovider = AnthropicProvider(\n    api_key=\"...\",  # or set ANTHROPIC_API_KEY\n    model=\"claude-3-5-sonnet-20241022\",\n    timeout=120.0\n)\n</code></pre> <p>Features:</p> <ul> <li>Vision support (Claude 3+)</li> <li>Large context window (100k+ tokens)</li> <li>Excellent at following instructions</li> </ul> <p>Models:</p> <ul> <li><code>claude-3-5-sonnet-20241022</code> (recommended)</li> <li><code>claude-3-opus-20240229</code></li> <li><code>claude-3-haiku-20240307</code></li> </ul>"},{"location":"providers/#ollamaprovider","title":"OllamaProvider","text":"<p>Local models via Ollama (free, air-gapped).</p> <pre><code>from strutex import OllamaProvider\n\nprovider = OllamaProvider(\n    host=\"http://localhost:11434\",  # or set OLLAMA_HOST\n    model=\"llama3.2-vision\",\n    timeout=120.0\n)\n</code></pre> <p>Features:</p> <ul> <li>Free (no API costs)</li> <li>Air-gapped/offline support</li> <li>Vision with multimodal models</li> <li>Respects <code>OLLAMA_HOST</code> env var</li> </ul> <p>Models:</p> <ul> <li><code>llama3.2-vision</code> (recommended for vision)</li> <li><code>llama3.2</code></li> <li><code>llava</code></li> <li><code>bakllava</code></li> </ul> <p>Local-first Development</p> <p>Use Ollama for development to avoid API costs, then switch to cloud providers for production.</p>"},{"location":"providers/#groqprovider","title":"GroqProvider","text":"<p>Ultra-fast inference at low cost.</p> <pre><code>from strutex import GroqProvider\n\nprovider = GroqProvider(\n    api_key=\"...\",  # or set GROQ_API_KEY\n    model=\"llama-3.3-70b-versatile\",\n    timeout=60.0\n)\n</code></pre> <p>Features:</p> <ul> <li>Extremely fast inference (100+ tokens/sec)</li> <li>Very low cost</li> <li>JSON mode support</li> <li>Vision with specific models</li> </ul> <p>Models:</p> <ul> <li><code>llama-3.3-70b-versatile</code> (recommended)</li> <li><code>llama-3.2-90b-vision-preview</code> (vision)</li> <li><code>llama-3.2-11b-vision-preview</code> (vision)</li> <li><code>mixtral-8x7b-32768</code></li> </ul>"},{"location":"providers/#langdockprovider","title":"LangdockProvider","text":"<p>Enterprise-grade access to multiple LLM models via a unified API.</p> <pre><code>from strutex import LangdockProvider\n\nprovider = LangdockProvider(\n    api_key=\"...\",  # or set LANGDOCK_API_KEY\n    model=\"gemini-2.5-flash\",\n    temperature=0.0\n)\n</code></pre> <p>Features:</p> <ul> <li>Enterprise-grade API access</li> <li>Multiple model support (Gemini, GPT-4, Claude)</li> <li>Document upload with attachment handling</li> <li>Structured JSON output via inline assistant</li> </ul> <p>Models:</p> <ul> <li><code>gemini-2.5-flash</code> (recommended)</li> <li><code>gemini-2.5-pro</code></li> <li><code>gpt-4o</code></li> <li><code>gpt-4-turbo</code></li> <li><code>claude-3-5-sonnet</code></li> <li><code>claude-3-opus</code></li> </ul> <p>Enterprise Usage</p> <p>Langdock is ideal for enterprise environments where you need access to multiple LLM providers through a single API.</p>"},{"location":"providers/#retry-configuration","title":"Retry Configuration","text":"<p>All providers support retry with exponential backoff:</p> <pre><code>from strutex.providers import RetryConfig, OpenAIProvider\n\nretry = RetryConfig(\n    max_retries=3,\n    base_delay=1.0,\n    max_delay=60.0,\n    exponential_base=2.0\n)\n\nprovider = OpenAIProvider(retry_config=retry)\n</code></pre>"},{"location":"providers/#health-checks","title":"Health Checks","text":"<p>Check if a provider is available:</p> <pre><code>from strutex import GeminiProvider, OllamaProvider\n\n# Check if package installed and API key set\nprint(f\"Gemini: {GeminiProvider.health_check()}\")\nprint(f\"Ollama: {OllamaProvider.health_check()}\")  # Checks if server running\n</code></pre>"},{"location":"providers/#custom-providers","title":"Custom Providers","text":"<p>Create your own provider:</p> <pre><code>from strutex.providers import Provider\n\nclass MyProvider(Provider, name=\"myprovider\"):\n    \"\"\"Custom provider implementation.\"\"\"\n\n    strutex_plugin_version = \"1.0\"\n    priority = 50\n    cost = 1.0\n    capabilities = [\"vision\"]\n\n    def __init__(self, api_key=None, model=\"default\"):\n        self.api_key = api_key\n        self.model = model\n\n    def process(self, file_path, prompt, schema, mime_type, **kwargs):\n        # Your implementation here\n        ...\n        return {\"extracted\": \"data\"}\n\n    @classmethod\n    def health_check(cls):\n        # Check if provider is ready\n        return True\n</code></pre> <p>Usage:</p> <pre><code>processor = DocumentProcessor(provider=\"myprovider\")\n</code></pre>"},{"location":"providers/#provider-selection","title":"Provider Selection","text":"<p>Choose the right provider for your needs:</p> Use Case Recommended Provider Development/Testing <code>OllamaProvider</code> (free) Production (cost-sensitive) <code>GroqProvider</code> or <code>GeminiProvider</code> Production (quality) <code>OpenAIProvider</code> or <code>AnthropicProvider</code> Air-gapped environments <code>OllamaProvider</code> Large documents <code>AnthropicProvider</code> (large context) Speed-critical <code>GroqProvider</code>"},{"location":"providers/#see-also","title":"See Also","text":"<ul> <li>Provider Chains - Automatic fallback</li> <li>Caching - Reduce API costs</li> </ul>"},{"location":"pydantic/","title":"Pydantic Support","text":"<p>Use Pydantic models for type-safe document extraction with automatic validation.</p>"},{"location":"pydantic/#quick-start","title":"Quick Start","text":"<pre><code>from pydantic import BaseModel, Field\nfrom strutex import DocumentProcessor\n\nclass Invoice(BaseModel):\n    invoice_number: str = Field(description=\"Unique ID\")\n    total: float = Field(description=\"Total amount\")\n\nprocessor = DocumentProcessor(provider=\"gemini\")\nresult = processor.process(\n    \"invoice.pdf\",\n    \"Extract invoice data\",\n    model=Invoice  # Use model= instead of schema=\n)\n\n# result is a validated Invoice instance!\nprint(result.invoice_number)\nprint(result.total)\n</code></pre>"},{"location":"pydantic/#nested-models","title":"Nested Models","text":"<pre><code>from typing import List, Optional\n\nclass LineItem(BaseModel):\n    description: str\n    quantity: int\n    unit_price: float\n    total: float\n\nclass Vendor(BaseModel):\n    name: str\n    address: Optional[str] = None\n\nclass Invoice(BaseModel):\n    invoice_number: str\n    date: str = Field(description=\"YYYY-MM-DD format\")\n    vendor: Vendor\n    items: List[LineItem]\n    subtotal: float\n    tax: Optional[float] = None\n    total: float\n</code></pre>"},{"location":"pydantic/#field-descriptions","title":"Field Descriptions","text":"<p>Use <code>Field(description=...)</code> to guide the LLM:</p> <pre><code>class Invoice(BaseModel):\n    invoice_number: str = Field(\n        description=\"The unique invoice identifier, e.g. INV-2024-001\"\n    )\n    date: str = Field(\n        description=\"Invoice date in YYYY-MM-DD format\"\n    )\n    total: float = Field(\n        description=\"Final payable amount including tax\"\n    )\n</code></pre>"},{"location":"pydantic/#manual-conversion","title":"Manual Conversion","text":"<p>You can also convert Pydantic models to strutex schemas manually:</p> <pre><code>from strutex import pydantic_to_schema, validate_with_pydantic\n\n# Convert model to schema\nschema = pydantic_to_schema(Invoice)\n\n# Later, validate dict data\ndata = {\"invoice_number\": \"INV-001\", \"total\": 100.0}\ninvoice = validate_with_pydantic(data, Invoice)\n</code></pre>"},{"location":"pydantic/#validation-errors","title":"Validation Errors","text":"<p>Pydantic validation runs after LLM extraction:</p> <pre><code>from pydantic import ValidationError\n\ntry:\n    result = processor.process(file, prompt, model=Invoice)\nexcept ValidationError as e:\n    print(f\"Output didn't match schema: {e}\")\n</code></pre>"},{"location":"schema-types/","title":"Schema Types","text":"<p>Define your expected output structure using strutex's schema types.</p>"},{"location":"schema-types/#basic-types","title":"Basic Types","text":""},{"location":"schema-types/#string","title":"String","text":"<pre><code>from strutex import String\n\nname = String(description=\"Customer name\")\noptional_name = String(description=\"Middle name\", nullable=True)\n</code></pre>"},{"location":"schema-types/#number","title":"Number","text":"<p>For floating-point values:</p> <pre><code>from strutex import Number\n\nprice = Number(description=\"Item price\")\n</code></pre>"},{"location":"schema-types/#integer","title":"Integer","text":"<p>For whole numbers:</p> <pre><code>from strutex import Integer\n\nquantity = Integer(description=\"Item count\")\n</code></pre>"},{"location":"schema-types/#boolean","title":"Boolean","text":"<pre><code>from strutex import Boolean\n\nis_paid = Boolean(description=\"Payment status\")\n</code></pre>"},{"location":"schema-types/#complex-types","title":"Complex Types","text":""},{"location":"schema-types/#array","title":"Array","text":"<pre><code>from strutex import Array, String, Object\n\n# Array of strings\ntags = Array(items=String(), description=\"Item tags\")\n\n# Array of objects\nitems = Array(\n    items=Object(\n        properties={\n            \"name\": String(),\n            \"price\": Number()\n        }\n    )\n)\n</code></pre>"},{"location":"schema-types/#object","title":"Object","text":"<pre><code>from strutex import Object, String\n\naddress = Object(\n    description=\"Shipping address\",\n    properties={\n        \"street\": String(),\n        \"city\": String(),\n        \"zip\": String()\n    }\n)\n</code></pre>"},{"location":"schema-types/#required-vs-optional","title":"Required vs Optional","text":"<p>By default, all properties are required. To make fields optional:</p> Explicit RequiredNullable Fields <pre><code>schema = Object(\n    properties={\n        \"name\": String(),\n        \"email\": String()\n    },\n    required=[\"name\"]  # Only name is required\n)\n</code></pre> <pre><code>schema = Object(\n    properties={\n        \"name\": String(),\n        \"notes\": String(nullable=True)\n    }\n)\n</code></pre>"},{"location":"schema-types/#complete-example","title":"Complete Example","text":"<pre><code>from strutex import Object, String, Number, Integer, Array, Boolean\n\ninvoice_schema = Object(\n    description=\"Complete invoice\",\n    properties={\n        \"invoice_number\": String(description=\"Unique ID\"),\n        \"date\": String(description=\"YYYY-MM-DD\"),\n        \"vendor\": Object(\n            properties={\n                \"name\": String(),\n                \"address\": String(nullable=True)\n            }\n        ),\n        \"items\": Array(\n            items=Object(\n                properties={\n                    \"description\": String(),\n                    \"quantity\": Integer(),\n                    \"price\": Number()\n                }\n            )\n        ),\n        \"total\": Number(),\n        \"paid\": Boolean()\n    }\n)\n</code></pre>"},{"location":"schemas/","title":"Built-in Schemas","text":"<p>strutex includes ready-to-use Pydantic schemas for common document types. Use these directly with <code>DocumentProcessor</code> for instant structured extraction.</p>"},{"location":"schemas/#quick-start","title":"Quick Start","text":"<pre><code>from strutex import DocumentProcessor\nfrom strutex.schemas import INVOICE_US\n\nprocessor = DocumentProcessor(provider=\"gemini\")\ninvoice = processor.process(\n    \"invoice.pdf\",\n    \"Extract invoice details\",\n    model=INVOICE_US\n)\n\nprint(f\"Invoice #{invoice.invoice_number}\")\nprint(f\"Total: ${invoice.total}\")\nprint(f\"Items: {len(invoice.line_items)}\")\n</code></pre>"},{"location":"schemas/#available-schemas","title":"Available Schemas","text":""},{"location":"schemas/#invoices","title":"Invoices","text":"Schema Description Key Fields <code>INVOICE_GENERIC</code> Universal invoice format invoice_number, vendor, customer, line_items, total <code>INVOICE_US</code> US-style with sales tax + sales_tax, state_tax_rate, ein <code>INVOICE_EU</code> EU-style with VAT + vat_number, vat_rate, reverse_charge <pre><code>from strutex.schemas import INVOICE_GENERIC, INVOICE_US, INVOICE_EU\n</code></pre>"},{"location":"schemas/#receipts","title":"Receipts","text":"Schema Description Key Fields <code>RECEIPT</code> Retail/restaurant receipts merchant_name, items, subtotal, tax, total, payment_method <pre><code>from strutex.schemas import RECEIPT\n\nreceipt = processor.process(\"receipt.jpg\", \"Extract receipt\", model=RECEIPT)\nprint(f\"Store: {receipt.merchant_name}, Total: ${receipt.total}\")\n</code></pre>"},{"location":"schemas/#purchase-orders","title":"Purchase Orders","text":"Schema Description Key Fields <code>PURCHASE_ORDER</code> B2B purchase orders po_number, vendor_name, line_items, ship_to, payment_terms <pre><code>from strutex.schemas import PURCHASE_ORDER\n</code></pre>"},{"location":"schemas/#shipping-documents","title":"Shipping Documents","text":"Schema Description Key Fields <code>BILL_OF_LADING</code> Ocean freight B/L bl_number, shipper, consignee, containers, cargo, port_of_loading, port_of_discharge <pre><code>from strutex.schemas import BILL_OF_LADING\n\nbol = processor.process(\"bl.pdf\", \"Extract B/L\", model=BILL_OF_LADING)\nprint(f\"{bol.port_of_loading} \u2192 {bol.port_of_discharge}\")\n</code></pre>"},{"location":"schemas/#financial-documents","title":"Financial Documents","text":"Schema Description Key Fields <code>BANK_STATEMENT</code> Bank account statements account_number, opening_balance, closing_balance, transactions <pre><code>from strutex.schemas import BANK_STATEMENT\n</code></pre>"},{"location":"schemas/#resumescvs","title":"Resumes/CVs","text":"Schema Description Key Fields <code>RESUME</code> Professional resumes name, email, skills, work_experience, education, certifications <pre><code>from strutex.schemas import RESUME\n\nresume = processor.process(\"resume.pdf\", \"Extract resume\", model=RESUME)\nprint(f\"{resume.name}: {len(resume.work_experience)} positions\")\n</code></pre>"},{"location":"schemas/#legal-documents","title":"Legal Documents","text":"Schema Description Key Fields <code>CONTRACT_CLAUSE</code> Contract key terms title, parties, effective_date, payment_terms, governing_law <pre><code>from strutex.schemas import CONTRACT_CLAUSE\n</code></pre>"},{"location":"schemas/#extending-schemas","title":"Extending Schemas","text":"<p>Create custom schemas by inheriting from built-in ones:</p> <pre><code>from strutex.schemas import InvoiceGeneric\nfrom pydantic import Field\n\nclass MyInvoice(InvoiceGeneric):\n    \"\"\"Custom invoice with company-specific fields.\"\"\"\n    internal_code: str = Field(..., description=\"Internal tracking code\")\n    department: str = Field(None, description=\"Department to charge\")\n\n# Use your custom schema\nresult = processor.process(\"invoice.pdf\", \"Extract invoice\", model=MyInvoice)\n</code></pre>"},{"location":"schemas/#schema-reference","title":"Schema Reference","text":""},{"location":"schemas/#invoicegeneric-fields","title":"InvoiceGeneric Fields","text":"Field Type Description <code>invoice_number</code> str Invoice number/ID <code>invoice_date</code> str? Invoice date <code>due_date</code> str? Payment due date <code>vendor</code> Party? Seller information <code>customer</code> Party? Buyer information <code>line_items</code> list List of line items <code>subtotal</code> float? Subtotal before tax <code>tax_amount</code> float? Tax amount <code>total</code> float Grand total <code>payment_terms</code> str? Payment terms"},{"location":"schemas/#receipt-fields","title":"Receipt Fields","text":"Field Type Description <code>merchant_name</code> str Store name <code>receipt_number</code> str? Receipt/transaction number <code>date</code> str? Transaction date <code>items</code> list Purchased items <code>subtotal</code> float? Before tax <code>tax</code> float? Tax amount <code>total</code> float Total paid <code>payment_method</code> str? Cash, Card, etc."},{"location":"schemas/#billoflading-fields","title":"BillOfLading Fields","text":"Field Type Description <code>bl_number</code> str B/L number <code>shipper</code> str? Shipper name/address <code>consignee</code> str? Consignee name/address <code>carrier</code> str? Shipping line <code>vessel_name</code> str? Ship name <code>port_of_loading</code> str? POL <code>port_of_discharge</code> str? POD <code>containers</code> list Container details <code>cargo</code> list Cargo details"},{"location":"schemas/#best-practices","title":"Best Practices","text":"<ol> <li>Use specific schemas when possible - <code>INVOICE_US</code> over <code>INVOICE_GENERIC</code> for better accuracy</li> <li>Extend for custom fields - Inherit and add company-specific fields</li> <li>Validate after extraction - Use Pydantic's validation:</li> </ol> <pre><code>try:\n    invoice = processor.process(\"doc.pdf\", \"Extract\", model=INVOICE_US)\nexcept ValidationError as e:\n    print(f\"Extraction incomplete: {e}\")\n</code></pre>"},{"location":"security/","title":"Security Layer","text":"<p>Protect against prompt injection and data leaks with strutex's pluggable security layer.</p> <p>Security is Opt-In</p> <p>Security features are not enabled by default. You must explicitly enable them.</p>"},{"location":"security/#quick-start","title":"Quick Start","text":"Default ChainPer-Request <pre><code>from strutex import DocumentProcessor\nfrom strutex.security import default_security_chain\n\nprocessor = DocumentProcessor(\n    provider=\"gemini\",\n    security=default_security_chain()\n)\n</code></pre> <pre><code>processor = DocumentProcessor(provider=\"gemini\")\n\n# Enable for specific request\nresult = processor.process(file, prompt, schema, security=True)\n</code></pre>"},{"location":"security/#built-in-plugins","title":"Built-in Plugins","text":""},{"location":"security/#inputsanitizer","title":"InputSanitizer","text":"<p>Cleans and normalizes input text.</p> <pre><code>from strutex.security import InputSanitizer\n\nsanitizer = InputSanitizer(\n    collapse_whitespace=True,   # \"Hello   World\" \u2192 \"Hello World\"\n    normalize_unicode=True,     # NFKC normalization\n    remove_invisible=True,      # Remove zero-width chars\n    max_length=50000            # Reject if too long\n)\n</code></pre>"},{"location":"security/#promptinjectiondetector","title":"PromptInjectionDetector","text":"<p>Detects common prompt injection patterns.</p> <pre><code>from strutex.security import PromptInjectionDetector\n\ndetector = PromptInjectionDetector()\n\nresult = detector.validate_input(\"Ignore previous instructions\")\nprint(result.valid)   # False\nprint(result.reason)  # \"Potential prompt injection detected\"\n</code></pre> <p>Detected patterns:</p> <ul> <li><code>\"Ignore previous instructions\"</code></li> <li><code>\"You are now X\"</code></li> <li><code>\"Show me your system prompt\"</code></li> <li>XML/HTML delimiter attacks</li> </ul>"},{"location":"security/#outputvalidator","title":"OutputValidator","text":"<p>Checks LLM output for sensitive data.</p> <pre><code>from strutex.security import OutputValidator\n\nvalidator = OutputValidator(check_secrets=True)\n\nresult = validator.validate_output({\"key\": \"sk-1234...\"})\nprint(result.valid)   # False\nprint(result.reason)  # \"Potential API key detected\"\n</code></pre>"},{"location":"security/#security-chain","title":"Security Chain","text":"<p>Combine multiple plugins:</p> <pre><code>from strutex.security import SecurityChain, InputSanitizer, PromptInjectionDetector\n\nchain = SecurityChain([\n    InputSanitizer(collapse_whitespace=True),\n    PromptInjectionDetector(),\n])\n\nresult = chain.validate_input(\"Ignore    all   instructions\")\nprint(result.valid)   # False (injection detected)\nprint(result.text)    # \"Ignore all instructions\" (sanitized)\n</code></pre>"},{"location":"security/#custom-security-plugin","title":"Custom Security Plugin","text":"<pre><code>from strutex.plugins import SecurityPlugin, SecurityResult, register\nimport re\n\n@register(\"security\")\nclass PIIRedactor(SecurityPlugin):\n    \"\"\"Redact emails from output.\"\"\"\n\n    def validate_output(self, data):\n        def redact(obj):\n            if isinstance(obj, str):\n                return re.sub(r'\\S+@\\S+', '[EMAIL]', obj)\n            if isinstance(obj, dict):\n                return {k: redact(v) for k, v in obj.items()}\n            if isinstance(obj, list):\n                return [redact(i) for i in obj]\n            return obj\n\n        return SecurityResult(valid=True, data=redact(data))\n</code></pre>"},{"location":"security/#handling-security-errors","title":"Handling Security Errors","text":"<pre><code>from strutex.processor import SecurityError\n\ntry:\n    result = processor.process(file, prompt, schema, security=True)\nexcept SecurityError as e:\n    print(f\"Security check failed: {e}\")\n</code></pre>"},{"location":"streaming/","title":"Streaming","text":"<p>Stream extraction results in real-time for responsive applications.</p>"},{"location":"streaming/#quick-start","title":"Quick Start","text":"<pre><code>from strutex import DocumentProcessor, StreamingProcessor\nfrom strutex.schemas import INVOICE_US\n\nprocessor = DocumentProcessor(provider=\"gemini\")\nstreamer = StreamingProcessor(processor)\n\n# Stream extraction\nfor chunk in streamer.stream(\"invoice.pdf\", \"Extract invoice\", INVOICE_US):\n    print(chunk.content, end=\"\", flush=True)\n</code></pre>"},{"location":"streaming/#streamingprocessor","title":"StreamingProcessor","text":"<p>Wrap any processor for streaming:</p> <pre><code>from strutex import StreamingProcessor\n\nstreamer = StreamingProcessor(processor)\n\n# Sync streaming\nfor chunk in streamer.stream(file_path, prompt, schema):\n    print(chunk.content, end=\"\")\n\n    if chunk.is_complete:\n        print(\"\\n--- Complete ---\")\n</code></pre>"},{"location":"streaming/#streamchunk","title":"StreamChunk","text":"<p>Each chunk contains:</p> Field Type Description <code>content</code> str New content in this chunk <code>is_complete</code> bool Whether this is the final chunk <code>accumulated</code> str All content received so far <code>metadata</code> dict Optional metadata <pre><code>for chunk in streamer.stream(...):\n    # Current chunk\n    print(f\"Content: {chunk.content}\")\n\n    # Running total\n    print(f\"So far: {chunk.accumulated}\")\n\n    # Check if done\n    if chunk.is_complete:\n        final_result = json.loads(chunk.accumulated)\n</code></pre>"},{"location":"streaming/#async-streaming","title":"Async Streaming","text":"<pre><code>import asyncio\n\nasync def stream_extract():\n    async for chunk in streamer.astream(file_path, prompt, schema):\n        print(chunk.content, end=\"\", flush=True)\n\nasyncio.run(stream_extract())\n</code></pre>"},{"location":"streaming/#utility-functions","title":"Utility Functions","text":""},{"location":"streaming/#stream_to_string","title":"stream_to_string","text":"<p>Consume entire stream and return final result:</p> <pre><code>from strutex.providers import stream_to_string\n\nresult_str = stream_to_string(streamer.stream(...))\nresult = json.loads(result_str)\n</code></pre>"},{"location":"streaming/#stream_with_callback","title":"stream_with_callback","text":"<p>Stream with callbacks:</p> <pre><code>from strutex.providers import stream_with_callback\n\ndef on_chunk(chunk):\n    print(chunk.content, end=\"\", flush=True)\n\ndef on_complete(result):\n    print(f\"\\n\\nDone! {len(result)} characters\")\n\nresult = stream_with_callback(\n    streamer.stream(...),\n    on_chunk=on_chunk,\n    on_complete=on_complete\n)\n</code></pre>"},{"location":"streaming/#async-helpers","title":"Async Helpers","text":"<pre><code>from strutex.providers.streaming import astream_to_string\n\nasync def get_result():\n    result_str = await astream_to_string(streamer.astream(...))\n    return json.loads(result_str)\n</code></pre>"},{"location":"streaming/#provider-streaming-support","title":"Provider Streaming Support","text":"<p>Default Behavior</p> <p>By default, StreamingProcessor falls back to non-streaming mode by calling <code>process()</code> and yielding a single complete chunk.</p> <p>Providers can implement native streaming by adding a <code>stream()</code> method:</p> <pre><code>from strutex.providers import Provider\nfrom strutex.providers.streaming import StreamingMixin, StreamChunk\n\nclass MyProvider(Provider, StreamingMixin):\n    def stream(self, file_path, prompt, schema, mime_type, **kwargs):\n        # Implement native streaming\n        for partial in self.api.stream_generate(...):\n            yield StreamChunk(\n                content=partial,\n                is_complete=False,\n                accumulated=self._accumulated\n            )\n\n        yield StreamChunk(\n            content=\"\",\n            is_complete=True,\n            accumulated=self._accumulated\n        )\n</code></pre>"},{"location":"streaming/#use-cases","title":"Use Cases","text":""},{"location":"streaming/#progress-indication","title":"Progress Indication","text":"<pre><code>import sys\n\nfor chunk in streamer.stream(...):\n    sys.stdout.write(f\"\\rReceived {len(chunk.accumulated)} chars...\")\n    sys.stdout.flush()\n\nprint(\"\\nDone!\")\n</code></pre>"},{"location":"streaming/#real-time-ui-updates","title":"Real-time UI Updates","text":"<pre><code># In a web framework (pseudo-code)\nasync def stream_endpoint(file_path, prompt, schema):\n    async for chunk in streamer.astream(file_path, prompt, schema):\n        yield f\"data: {json.dumps({'content': chunk.content})}\\n\\n\"\n</code></pre>"},{"location":"streaming/#timeout-with-partial-results","title":"Timeout with Partial Results","text":"<pre><code>import signal\n\nclass TimeoutError(Exception):\n    pass\n\ndef timeout_handler(signum, frame):\n    raise TimeoutError()\n\nsignal.signal(signal.SIGALRM, timeout_handler)\nsignal.alarm(30)  # 30 second timeout\n\ntry:\n    result = \"\"\n    for chunk in streamer.stream(...):\n        result = chunk.accumulated\n    signal.alarm(0)  # Cancel timeout\nexcept TimeoutError:\n    print(f\"Timed out! Partial result: {result[:100]}...\")\n</code></pre>"},{"location":"streaming/#best-practices","title":"Best Practices","text":"<ol> <li>Use <code>flush=True</code> when printing streaming output</li> <li>Handle incomplete streams gracefully</li> <li>Parse JSON only after <code>is_complete=True</code></li> <li>Use async streaming in async applications</li> <li>Implement proper error handling for network issues</li> </ol>"},{"location":"tutorial-batch/","title":"Batch &amp; Async Processing","text":"<p>Process multiple documents efficiently.</p>"},{"location":"tutorial-batch/#batch-processing","title":"Batch Processing","text":"<p>Process multiple files in a single call:</p> <pre><code>from strutex import DocumentProcessor, GeminiProvider\n\nprocessor = DocumentProcessor(provider=GeminiProvider())\n\nfiles = [\n    \"invoices/jan.pdf\",\n    \"invoices/feb.pdf\",\n    \"invoices/mar.pdf\",\n]\n\n# Process all files\nresults = processor.process_batch(\n    file_paths=files,\n    prompt=\"Extract invoice details\",\n    schema=InvoiceSchema\n)\n\nfor file_path, result in zip(files, results):\n    print(f\"{file_path}: ${result['total']}\")\n</code></pre>"},{"location":"tutorial-batch/#async-processing","title":"Async Processing","text":"<p>For high-throughput applications, use async:</p> <pre><code>import asyncio\nfrom strutex import DocumentProcessor, GeminiProvider\n\nprocessor = DocumentProcessor(provider=GeminiProvider())\n\nasync def extract_invoice(file_path):\n    result = await processor.aprocess(\n        file_path=file_path,\n        prompt=\"Extract invoice\",\n        schema=InvoiceSchema\n    )\n    return result\n\n# Process single file async\nresult = asyncio.run(extract_invoice(\"invoice.pdf\"))\n</code></pre>"},{"location":"tutorial-batch/#concurrent-async-processing","title":"Concurrent Async Processing","text":"<pre><code>import asyncio\nfrom strutex import DocumentProcessor, GeminiProvider\n\nprocessor = DocumentProcessor(provider=GeminiProvider())\n\nasync def process_all(files):\n    tasks = [\n        processor.aprocess(f, \"Extract invoice\", schema=InvoiceSchema)\n        for f in files\n    ]\n    return await asyncio.gather(*tasks)\n\nfiles = [\"inv1.pdf\", \"inv2.pdf\", \"inv3.pdf\"]\nresults = asyncio.run(process_all(files))\n</code></pre>"},{"location":"tutorial-batch/#batch-with-progress","title":"Batch with Progress","text":"<p>Track progress for large batches:</p> <pre><code>from tqdm import tqdm\nfrom strutex import DocumentProcessor, GeminiProvider\n\nprocessor = DocumentProcessor(provider=GeminiProvider())\n\nfiles = list(Path(\"invoices/\").glob(\"*.pdf\"))\n\nresults = []\nfor file_path in tqdm(files, desc=\"Processing\"):\n    result = processor.process(\n        file_path=str(file_path),\n        prompt=\"Extract invoice\",\n        schema=InvoiceSchema\n    )\n    results.append(result)\n</code></pre>"},{"location":"tutorial-batch/#error-handling-in-batches","title":"Error Handling in Batches","text":"<p>Handle failures gracefully:</p> <pre><code>from strutex import DocumentProcessor, GeminiProvider\n\nprocessor = DocumentProcessor(provider=GeminiProvider())\n\nfiles = [\"good.pdf\", \"bad.pdf\", \"also_good.pdf\"]\nresults = []\n\nfor file_path in files:\n    try:\n        result = processor.process(file_path, \"Extract\", schema=MySchema)\n        results.append({\"file\": file_path, \"status\": \"success\", \"data\": result})\n    except Exception as e:\n        results.append({\"file\": file_path, \"status\": \"error\", \"error\": str(e)})\n\n# Check results\nsuccess = [r for r in results if r[\"status\"] == \"success\"]\nfailed = [r for r in results if r[\"status\"] == \"error\"]\n\nprint(f\"Success: {len(success)}, Failed: {len(failed)}\")\n</code></pre>"},{"location":"tutorial-batch/#processingcontext-advanced","title":"ProcessingContext (Advanced)","text":"<p>Track batch processing state:</p> <pre><code>from strutex import DocumentProcessor, GeminiProvider\nfrom strutex.context import BatchContext\n\nprocessor = DocumentProcessor(provider=GeminiProvider())\n\n# Create batch context\ncontext = BatchContext(total_files=len(files))\n\nfor file_path in files:\n    context.start_file(file_path)\n\n    try:\n        result = processor.process(file_path, \"Extract\", schema=MySchema)\n        context.complete_file(file_path, success=True)\n    except Exception as e:\n        context.complete_file(file_path, success=False, error=str(e))\n\n# Get summary\nprint(f\"Processed: {context.processed_count}/{context.total_files}\")\nprint(f\"Success rate: {context.success_rate:.1%}\")\nprint(f\"Failed files: {context.failed_files}\")\n</code></pre>"},{"location":"tutorial-batch/#caching-with-batches","title":"Caching with Batches","text":"<p>Combine caching with batch processing:</p> <pre><code>from strutex import DocumentProcessor, GeminiProvider, MemoryCache\n\nprocessor = DocumentProcessor(\n    provider=GeminiProvider(),\n    cache=MemoryCache(max_size=1000)\n)\n\n# First run: all API calls\nresults1 = [processor.process(f, \"Extract\", schema=MySchema) for f in files]\n\n# Second run: all cached (free!)\nresults2 = [processor.process(f, \"Extract\", schema=MySchema) for f in files]\n</code></pre>"},{"location":"tutorial-batch/#performance-tips","title":"Performance Tips","text":"Tip Impact Use <code>MemoryCache</code> Avoid redundant API calls Use <code>aprocess</code> for I/O bound work Better throughput Batch by document type Consistent schema handling Add progress tracking UX for long jobs Handle errors per-file Don't fail entire batch"},{"location":"tutorial-batch/#next-steps","title":"Next Steps","text":"Want to... Go to... Integrate with LangChain Integrations Learn plugin system Plugins See full API reference API Reference"},{"location":"tutorial-caching/","title":"Caching","text":"<p>Reduce API costs and speed up repeated extractions with caching.</p>"},{"location":"tutorial-caching/#enable-caching","title":"Enable Caching","text":"<p>Pass a cache instance to DocumentProcessor:</p> <pre><code>from strutex import DocumentProcessor, MemoryCache, GeminiProvider\n\nprocessor = DocumentProcessor(\n    provider=GeminiProvider(),\n    cache=MemoryCache(max_size=100, ttl=3600)  # 1 hour TTL\n)\n\n# First call: hits the LLM API\nresult1 = processor.process(\"invoice.pdf\", \"Extract data\", schema=MySchema)\n\n# Second call: returns cached result instantly (no API call!)\nresult2 = processor.process(\"invoice.pdf\", \"Extract data\", schema=MySchema)\n</code></pre>"},{"location":"tutorial-caching/#cache-types","title":"Cache Types","text":""},{"location":"tutorial-caching/#memorycache","title":"MemoryCache","text":"<p>Fast, in-memory LRU cache. Best for single-process apps.</p> <pre><code>from strutex import MemoryCache\n\ncache = MemoryCache(\n    max_size=100,  # Max entries (LRU eviction)\n    ttl=3600       # TTL in seconds (optional)\n)\n\nprocessor = DocumentProcessor(provider=provider, cache=cache)\n</code></pre> <p>Features:</p> <ul> <li>LRU eviction when full</li> <li>Optional TTL (time-to-live)</li> <li>Thread-safe</li> <li>Hit/miss statistics</li> </ul>"},{"location":"tutorial-caching/#sqlitecache","title":"SQLiteCache","text":"<p>Persistent cache that survives restarts.</p> <pre><code>from strutex import SQLiteCache\n\ncache = SQLiteCache(\n    db_path=\"~/.cache/strutex/cache.db\",\n    ttl=86400,     # 24 hour TTL\n    max_size=1000  # Optional size limit\n)\n\nprocessor = DocumentProcessor(provider=provider, cache=cache)\n</code></pre> <p>Features:</p> <ul> <li>Persists across restarts</li> <li>Automatic table creation</li> <li>Lazy TTL cleanup</li> </ul>"},{"location":"tutorial-caching/#filecache","title":"FileCache","text":"<p>File-based cache for simple deployments.</p> <pre><code>from strutex import FileCache\n\ncache = FileCache(\n    cache_dir=\"/tmp/strutex_cache\",\n    ttl=3600\n)\n</code></pre>"},{"location":"tutorial-caching/#how-cache-keys-work","title":"How Cache Keys Work","text":"<p>Cache keys are computed from:</p> <ul> <li>File content hash \u2014 Same content = same key (even if renamed)</li> <li>Prompt hash \u2014 Different prompts = different keys</li> <li>Schema hash \u2014 Different schemas = different keys</li> <li>Provider + model \u2014 Different providers = different keys</li> </ul> <pre><code># These produce DIFFERENT cache keys:\nprocessor.process(\"invoice.pdf\", \"Extract all\", schema=InvoiceSchema)\nprocessor.process(\"invoice.pdf\", \"Extract total only\", schema=InvoiceSchema)\n\n# This produces the SAME cache key (same content, prompt, schema):\nprocessor.process(\"invoice.pdf\", \"Extract all\", schema=InvoiceSchema)\nprocessor.process(\"invoice_copy.pdf\", \"Extract all\", schema=InvoiceSchema)  # Same content\n</code></pre>"},{"location":"tutorial-caching/#cache-invalidation-pitfalls","title":"\u26a0\ufe0f Cache Invalidation Pitfalls","text":"<p>[!WARNING] Caching can cause stale data if you're not careful. Understand when caches invalidate.</p>"},{"location":"tutorial-caching/#when-cache-does-invalidate","title":"When Cache DOES Invalidate","text":"Change Invalidates? Why File content changes \u2705 Yes Content hash changes Prompt changes \u2705 Yes Prompt hash changes Schema adds new fields \u2705 Yes Schema hash changes Provider changes \u2705 Yes Provider in key Model changes \u2705 Yes Model in key"},{"location":"tutorial-caching/#when-cache-does-not-invalidate","title":"When Cache Does NOT Invalidate","text":"Change Invalidates? Risk Field descriptions change \u274c No Schema structure same, but extraction may differ Pydantic validators change \u274c No Post-processing logic not in key Provider credentials change \u274c No Key uses provider name, not credentials Prompt template internals \u274c No Only final prompt string is hashed"},{"location":"tutorial-caching/#safe-cache-usage","title":"Safe Cache Usage","text":"<pre><code># DANGER: Schema description changed, but cache returns old extraction\nclass Invoice_v1(BaseModel):\n    total: float = Field(description=\"Total amount\")  # Old\n\nclass Invoice_v2(BaseModel):\n    total: float = Field(description=\"Total amount including tax\")  # Changed!\n\n# These have THE SAME cache key because structure is identical:\n# processor.process(..., model=Invoice_v1)\n# processor.process(..., model=Invoice_v2)  # Returns stale cached result!\n\n# FIX: Clear cache when schema semantics change\ncache.clear()\n\n# Or use versioned prompts\nprocessor.process(..., prompt=\"Extract invoice v2\", model=Invoice_v2)\n</code></pre>"},{"location":"tutorial-caching/#recommendations","title":"Recommendations","text":"<ol> <li>Clear cache after schema changes \u2014 Especially description changes</li> <li>Use TTL \u2014 Don't cache forever: <code>MemoryCache(ttl=3600)</code></li> <li>Version your prompts \u2014 Include version in prompt string</li> <li>Test with fresh cache \u2014 After model updates</li> </ol>"},{"location":"tutorial-caching/#cache-statistics","title":"Cache Statistics","text":"<pre><code>from strutex import MemoryCache\n\ncache = MemoryCache()\nprocessor = DocumentProcessor(provider=provider, cache=cache)\n\n# After some usage...\nstats = cache.stats()\nprint(f\"Hits: {stats['hits']}\")\nprint(f\"Misses: {stats['misses']}\")\nprint(f\"Hit rate: {stats['hit_rate']:.1%}\")\nprint(f\"Size: {stats['size']}\")\n</code></pre>"},{"location":"tutorial-caching/#manual-cache-operations","title":"Manual Cache Operations","text":"<pre><code>from strutex import CacheKey, MemoryCache\n\ncache = MemoryCache()\n\n# Create a cache key manually\nkey = CacheKey.create(\n    file_path=\"invoice.pdf\",\n    prompt=\"Extract\",\n    schema=MySchema,\n    provider=\"gemini\"\n)\n\n# Check if cached\nif cache.has(key):\n    result = cache.get(key)\nelse:\n    result = processor.process(...)\n    cache.set(key, result)\n\n# Delete specific entry\ncache.delete(key)\n\n# Clear all\ncache.clear()\n</code></pre>"},{"location":"tutorial-caching/#next-steps","title":"Next Steps","text":"Want to... Go to... Add processing hooks Processing Hooks Add security checks Security Process in batches Batch Processing"},{"location":"tutorial-custom-plugins/","title":"Creating Custom Plugins","text":"<p>Extend strutex with your own providers, extractors, and security plugins.</p>"},{"location":"tutorial-custom-plugins/#plugin-system-overview","title":"Plugin System Overview","text":"<p>Strutex uses an inheritance-based plugin system. To create a custom plugin:</p> <ol> <li>Inherit from the appropriate base class</li> <li>Implement required methods</li> <li>Your plugin is auto-registered!</li> </ol> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                 Plugin Types                        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Provider      \u2192 Custom LLM backends                \u2502\n\u2502 Extractor     \u2192 Custom file format handlers        \u2502\n\u2502 SecurityPlugin \u2192 Custom security validation        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"tutorial-custom-plugins/#creating-a-custom-provider","title":"Creating a Custom Provider","text":"<p>Create your own LLM provider by inheriting from <code>Provider</code>:</p> <pre><code>from strutex.plugins.base import Provider\nfrom typing import Any, Optional\n\nclass MyCustomProvider(Provider, name=\"my_provider\"):\n    \"\"\"\n    Custom LLM provider for internal API.\n\n    Inheriting from Provider auto-registers the plugin!\n    \"\"\"\n\n    # Plugin metadata (optional)\n    priority = 50      # Lower = higher priority\n    cost = 0.001       # Cost per request for chain sorting\n    version = \"1.0.0\"\n\n    def __init__(self, api_key: Optional[str] = None, model: str = \"default\"):\n        self.api_key = api_key\n        self.model = model\n\n    def process(\n        self,\n        file_path: str,\n        prompt: str,\n        schema: Any,\n        mime_type: str,\n        **kwargs\n    ) -&gt; dict:\n        \"\"\"\n        Main extraction method. Required.\n\n        Args:\n            file_path: Path to document\n            prompt: Extraction prompt\n            schema: Target schema\n            mime_type: File MIME type\n            **kwargs: Additional options\n\n        Returns:\n            Extracted data as dict\n        \"\"\"\n        # 1. Read the file\n        with open(file_path, \"rb\") as f:\n            content = f.read()\n\n        # 2. Call your LLM API\n        response = self._call_api(content, prompt, schema)\n\n        # 3. Parse and return\n        return response\n\n    def _call_api(self, content: bytes, prompt: str, schema: Any) -&gt; dict:\n        \"\"\"Your API implementation.\"\"\"\n        import requests\n\n        response = requests.post(\n            \"https://your-api.com/extract\",\n            json={\n                \"content\": content.decode(\"utf-8\"),\n                \"prompt\": prompt,\n                \"schema\": schema.to_dict() if hasattr(schema, \"to_dict\") else schema\n            },\n            headers={\"Authorization\": f\"Bearer {self.api_key}\"}\n        )\n        return response.json()\n\n    def health_check(self) -&gt; bool:\n        \"\"\"Optional: Check if provider is available.\"\"\"\n        try:\n            # Ping your API\n            return True\n        except Exception:\n            return False\n</code></pre>"},{"location":"tutorial-custom-plugins/#using-your-custom-provider","title":"Using Your Custom Provider","text":"<pre><code>from strutex import DocumentProcessor\nfrom my_providers import MyCustomProvider\n\n# Create instance\nprovider = MyCustomProvider(api_key=\"secret\", model=\"v2\")\n\n# Use with processor\nprocessor = DocumentProcessor(provider=provider)\nresult = processor.process(\"doc.pdf\", \"Extract\", schema=MySchema)\n\n# Or use by name (auto-registered!)\nprocessor = DocumentProcessor(provider=\"my_provider\")\n</code></pre>"},{"location":"tutorial-custom-plugins/#creating-a-custom-extractor","title":"Creating a Custom Extractor","text":"<p>Handle custom file formats by inheriting from <code>Extractor</code>:</p> <pre><code>from strutex.plugins.base import Extractor\nfrom typing import Any\n\nclass XMLExtractor(Extractor, name=\"xml\"):\n    \"\"\"Extract data from XML files.\"\"\"\n\n    # Supported MIME types\n    supported_types = [\"application/xml\", \"text/xml\"]\n\n    def extract(self, file_path: str, **kwargs) -&gt; str:\n        \"\"\"\n        Extract text content from file.\n\n        Args:\n            file_path: Path to file\n            **kwargs: Additional options\n\n        Returns:\n            Text content for LLM\n        \"\"\"\n        import xml.etree.ElementTree as ET\n\n        tree = ET.parse(file_path)\n        root = tree.getroot()\n\n        # Convert XML to readable text\n        return self._xml_to_text(root)\n\n    def _xml_to_text(self, element, indent=0) -&gt; str:\n        \"\"\"Recursively convert XML to text.\"\"\"\n        lines = []\n        prefix = \"  \" * indent\n\n        if element.text and element.text.strip():\n            lines.append(f\"{prefix}{element.tag}: {element.text.strip()}\")\n        else:\n            lines.append(f\"{prefix}{element.tag}:\")\n\n        for child in element:\n            lines.append(self._xml_to_text(child, indent + 1))\n\n        return \"\\n\".join(lines)\n\n    def supports(self, mime_type: str) -&gt; bool:\n        \"\"\"Check if this extractor handles the MIME type.\"\"\"\n        return mime_type in self.supported_types\n</code></pre>"},{"location":"tutorial-custom-plugins/#registering-your-extractor","title":"Registering Your Extractor","text":"<pre><code>from strutex.plugins.registry import PluginRegistry\nfrom my_extractors import XMLExtractor\n\n# Auto-registered via inheritance, but you can also manually register\nPluginRegistry.register(\"extractor\", XMLExtractor, name=\"xml\")\n\n# Now XML files are automatically handled\nprocessor = DocumentProcessor(provider=provider)\nresult = processor.process(\"data.xml\", \"Extract\", schema=MySchema)\n</code></pre>"},{"location":"tutorial-custom-plugins/#creating-a-custom-security-plugin","title":"Creating a Custom Security Plugin","text":"<p>Add custom security validation:</p> <pre><code>from strutex.plugins.base import SecurityPlugin, SecurityResult\nfrom typing import Any, Dict\n\nclass CustomSecurityPlugin(SecurityPlugin, name=\"custom_security\"):\n    \"\"\"Custom security validation.\"\"\"\n\n    def __init__(self, forbidden_words: list = None):\n        self.forbidden_words = forbidden_words or []\n\n    def validate_input(self, text: str) -&gt; SecurityResult:\n        \"\"\"\n        Validate input prompt before LLM call.\n\n        Args:\n            text: Input prompt to validate\n\n        Returns:\n            SecurityResult with valid=True/False and reason\n        \"\"\"\n        # Check for forbidden words\n        for word in self.forbidden_words:\n            if word.lower() in text.lower():\n                return SecurityResult(\n                    valid=False,\n                    reason=f\"Forbidden word detected: {word}\"\n                )\n\n        # Check for suspicious patterns\n        if \"ignore all previous\" in text.lower():\n            return SecurityResult(\n                valid=False,\n                reason=\"Potential injection attempt\"\n            )\n\n        return SecurityResult(valid=True, text=text)\n\n    def validate_output(self, data: Dict[str, Any]) -&gt; SecurityResult:\n        \"\"\"\n        Validate LLM output before returning.\n\n        Args:\n            data: Extracted data dict\n\n        Returns:\n            SecurityResult with valid=True/False and data\n        \"\"\"\n        # Redact sensitive fields\n        redacted = data.copy()\n\n        for key in [\"ssn\", \"password\", \"secret\"]:\n            if key in redacted:\n                redacted[key] = \"[REDACTED]\"\n\n        return SecurityResult(valid=True, data=redacted)\n</code></pre>"},{"location":"tutorial-custom-plugins/#using-your-security-plugin","title":"Using Your Security Plugin","text":"<pre><code>from strutex import DocumentProcessor, GeminiProvider\nfrom my_security import CustomSecurityPlugin\n\nsecurity = CustomSecurityPlugin(\n    forbidden_words=[\"confidential\", \"internal\"]\n)\n\nprocessor = DocumentProcessor(\n    provider=GeminiProvider(),\n    security=security\n)\n\n# Security validation is now active\nresult = processor.process(\"doc.pdf\", \"Extract\", schema=MySchema)\n</code></pre>"},{"location":"tutorial-custom-plugins/#plugin-discovery-registration","title":"Plugin Discovery &amp; Registration","text":""},{"location":"tutorial-custom-plugins/#auto-registration-recommended","title":"Auto-Registration (Recommended)","text":"<p>Simply inherit from base class with <code>name</code> argument:</p> <pre><code>class MyProvider(Provider, name=\"my_provider\"):\n    pass\n</code></pre>"},{"location":"tutorial-custom-plugins/#manual-registration","title":"Manual Registration","text":"<pre><code>from strutex.plugins.registry import PluginRegistry\n\nPluginRegistry.register(\"provider\", MyProvider, name=\"my_provider\")\n</code></pre>"},{"location":"tutorial-custom-plugins/#list-registered-plugins","title":"List Registered Plugins","text":"<pre><code>from strutex.plugins.registry import PluginRegistry\n\n# List all providers\nproviders = PluginRegistry.list_names(\"provider\")\nprint(providers)  # [\"gemini\", \"openai\", \"my_provider\", ...]\n\n# Get plugin info\ninfo = PluginRegistry.get_plugin_info(\"provider\", \"my_provider\")\nprint(info)  # {\"name\": \"my_provider\", \"priority\": 50, ...}\n</code></pre>"},{"location":"tutorial-custom-plugins/#using-cli","title":"Using CLI","text":"<pre><code># List all plugins\nstrutex plugins list\n\n# Get plugin info\nstrutex plugins info provider my_provider\n\n# Refresh plugin cache\nstrutex plugins refresh\n</code></pre>"},{"location":"tutorial-custom-plugins/#entry-points-package-distribution","title":"Entry Points (Package Distribution)","text":"<p>Distribute your plugin as a package:</p> <pre><code># pyproject.toml\n[project.entry-points.\"strutex.providers\"]\nmy_provider = \"my_package.providers:MyCustomProvider\"\n\n[project.entry-points.\"strutex.extractors\"]\nxml = \"my_package.extractors:XMLExtractor\"\n</code></pre> <p>After <code>pip install my_package</code>, the plugins are automatically discovered!</p>"},{"location":"tutorial-custom-plugins/#best-practices","title":"Best Practices","text":"Practice Why Set <code>name</code> in class definition Clear identification Add <code>priority</code> and <code>cost</code> Enables smart chain selection Implement <code>health_check</code> Enables availability checks Add <code>version</code> For compatibility tracking Use type hints Better IDE support Add docstrings Shows in <code>plugins info</code>"},{"location":"tutorial-custom-plugins/#full-example-azure-openai-provider","title":"Full Example: Azure OpenAI Provider","text":"<pre><code>from strutex.plugins.base import Provider\nfrom typing import Any, Optional\nimport os\n\nclass AzureOpenAIProvider(Provider, name=\"azure_openai\"):\n    \"\"\"Azure OpenAI provider for enterprise deployments.\"\"\"\n\n    priority = 30\n    cost = 0.01\n    version = \"1.0.0\"\n\n    def __init__(\n        self,\n        api_key: Optional[str] = None,\n        endpoint: Optional[str] = None,\n        deployment: str = \"gpt-4\",\n        api_version: str = \"2024-02-01\"\n    ):\n        self.api_key = api_key or os.getenv(\"AZURE_OPENAI_API_KEY\")\n        self.endpoint = endpoint or os.getenv(\"AZURE_OPENAI_ENDPOINT\")\n        self.deployment = deployment\n        self.api_version = api_version\n\n    def process(\n        self,\n        file_path: str,\n        prompt: str,\n        schema: Any,\n        mime_type: str,\n        **kwargs\n    ) -&gt; dict:\n        from openai import AzureOpenAI\n\n        client = AzureOpenAI(\n            api_key=self.api_key,\n            azure_endpoint=self.endpoint,\n            api_version=self.api_version\n        )\n\n        # Read file and convert to base64 for images/PDFs\n        # ... implementation ...\n\n        response = client.chat.completions.create(\n            model=self.deployment,\n            messages=[{\"role\": \"user\", \"content\": prompt}],\n            response_format={\"type\": \"json_object\"}\n        )\n\n        import json\n        return json.loads(response.choices[0].message.content)\n\n    def health_check(self) -&gt; bool:\n        return bool(self.api_key and self.endpoint)\n</code></pre>"},{"location":"tutorial-custom-plugins/#next-steps","title":"Next Steps","text":"Want to... Go to... Learn hook system Hooks Reference See plugin API Plugin System Distribute package Entry Points <p> 5"},{"location":"tutorial-document-input/","title":"Working with File Uploads","text":"<p>Handle file paths, BytesIO streams, and HTTP uploads with DocumentInput.</p>"},{"location":"tutorial-document-input/#the-problem","title":"The Problem","text":"<p>Your application might receive documents from different sources:</p> <pre><code># From file system\nfile_path = \"/path/to/invoice.pdf\"\n\n# From HTTP upload (Flask/FastAPI)\nuploaded_file = request.files[\"document\"]\nfile_bytes = uploaded_file.read()\n\n# From cloud storage\nblob = bucket.get_blob(\"invoice.pdf\")\ncontent = blob.download_as_bytes()\n</code></pre> <p><code>DocumentProcessor.process()</code> expects a file path. How do you handle in-memory bytes?</p>"},{"location":"tutorial-document-input/#documentinput-unified-interface","title":"DocumentInput: Unified Interface","text":"<p><code>DocumentInput</code> provides a consistent interface for all input sources:</p> <pre><code>from strutex import DocumentInput, DocumentProcessor, GeminiProvider\nfrom pathlib import Path\nimport io\n\n# From file path (string)\ndoc = DocumentInput(\"invoice.pdf\")\n\n# From Path object\ndoc = DocumentInput(Path(\"invoice.pdf\"))\n\n# From BytesIO\nbytes_data = io.BytesIO(pdf_bytes)\ndoc = DocumentInput(bytes_data, filename=\"upload.pdf\")\n</code></pre>"},{"location":"tutorial-document-input/#using-with-documentprocessor","title":"Using with DocumentProcessor","text":"<p>Use the <code>as_file_path()</code> context manager:</p> <pre><code>from strutex import DocumentInput, DocumentProcessor, GeminiProvider\n\nprocessor = DocumentProcessor(provider=GeminiProvider())\n\n# Works with file path\ndoc = DocumentInput(\"invoice.pdf\")\nwith doc.as_file_path() as path:\n    result = processor.process(path, \"Extract\", schema=MySchema)\n\n# Works with BytesIO\ndoc = DocumentInput(io.BytesIO(pdf_bytes), filename=\"upload.pdf\")\nwith doc.as_file_path() as path:\n    # Temp file is created automatically\n    result = processor.process(path, \"Extract\", schema=MySchema)\n# Temp file is cleaned up automatically\n</code></pre>"},{"location":"tutorial-document-input/#flask-example","title":"Flask Example","text":"<pre><code>from flask import Flask, request, jsonify\nfrom strutex import DocumentInput, DocumentProcessor, GeminiProvider\nfrom pydantic import BaseModel\n\napp = Flask(__name__)\nprocessor = DocumentProcessor(provider=GeminiProvider())\n\nclass Invoice(BaseModel):\n    vendor: str\n    total: float\n    date: str\n\n@app.route(\"/extract\", methods=[\"POST\"])\ndef extract_invoice():\n    # Get uploaded file\n    uploaded = request.files[\"document\"]\n\n    # Create DocumentInput from bytes\n    doc = DocumentInput(\n        io.BytesIO(uploaded.read()),\n        filename=uploaded.filename\n    )\n\n    # Process\n    with doc.as_file_path() as path:\n        result = processor.process(path, \"Extract invoice\", model=Invoice)\n\n    return jsonify(result.model_dump())\n</code></pre>"},{"location":"tutorial-document-input/#fastapi-example","title":"FastAPI Example","text":"<pre><code>from fastapi import FastAPI, UploadFile\nfrom strutex import DocumentInput, DocumentProcessor, GeminiProvider\nfrom pydantic import BaseModel\nimport io\n\napp = FastAPI()\nprocessor = DocumentProcessor(provider=GeminiProvider())\n\nclass Invoice(BaseModel):\n    vendor: str\n    total: float\n    date: str\n\n@app.post(\"/extract\")\nasync def extract_invoice(file: UploadFile):\n    # Read file content\n    content = await file.read()\n\n    # Create DocumentInput\n    doc = DocumentInput(\n        io.BytesIO(content),\n        filename=file.filename\n    )\n\n    # Process\n    with doc.as_file_path() as path:\n        result = processor.process(path, \"Extract invoice\", model=Invoice)\n\n    return result.model_dump()\n</code></pre>"},{"location":"tutorial-document-input/#documentinput-properties","title":"DocumentInput Properties","text":"<pre><code>from strutex import DocumentInput\n\ndoc = DocumentInput(\"invoice.pdf\")\n\n# Check source type\nprint(doc.is_file_path)  # True for file paths, False for BytesIO\nprint(doc.path)          # Original path (or None for BytesIO)\nprint(doc.filename)      # \"invoice.pdf\"\n\n# Get raw bytes\ncontent = doc.get_bytes()\n\n# Get MIME type\nmime_type = doc.get_mime_type()  # \"application/pdf\"\n</code></pre>"},{"location":"tutorial-document-input/#mime-type-detection","title":"MIME Type Detection","text":"<p><code>DocumentInput</code> automatically detects MIME types:</p> <pre><code>doc = DocumentInput(io.BytesIO(data), filename=\"report.pdf\")\nprint(doc.get_mime_type())  # \"application/pdf\"\n\ndoc = DocumentInput(io.BytesIO(data), filename=\"scan.png\")\nprint(doc.get_mime_type())  # \"image/png\"\n\ndoc = DocumentInput(io.BytesIO(data), filename=\"data.xlsx\")\nprint(doc.get_mime_type())  # \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n\n# Override MIME type explicitly\ndoc = DocumentInput(io.BytesIO(data), filename=\"file.bin\", mime_type=\"application/pdf\")\n</code></pre>"},{"location":"tutorial-document-input/#temp-file-lifecycle","title":"Temp File Lifecycle","text":"<p>When using BytesIO, <code>as_file_path()</code> creates a temporary file:</p> <pre><code>doc = DocumentInput(io.BytesIO(pdf_bytes), filename=\"upload.pdf\")\n\nwith doc.as_file_path() as path:\n    # Temp file exists here\n    print(path)  # /tmp/strutex_abc123.pdf\n\n    # Process the file\n    result = processor.process(path, \"Extract\", schema=MySchema)\n\n# Temp file is automatically deleted here\n</code></pre> <p>Benefits:</p> <ul> <li>No manual cleanup needed</li> <li>Works with any processor/extractor</li> <li>Preserves file extension for MIME detection</li> </ul>"},{"location":"tutorial-document-input/#cloud-storage-examples","title":"Cloud Storage Examples","text":""},{"location":"tutorial-document-input/#aws-s3","title":"AWS S3","text":"<pre><code>import boto3\nimport io\nfrom strutex import DocumentInput, DocumentProcessor\n\ns3 = boto3.client(\"s3\")\nprocessor = DocumentProcessor(provider=provider)\n\n# Download from S3\nresponse = s3.get_object(Bucket=\"my-bucket\", Key=\"invoice.pdf\")\ncontent = response[\"Body\"].read()\n\n# Create DocumentInput\ndoc = DocumentInput(io.BytesIO(content), filename=\"invoice.pdf\")\n\nwith doc.as_file_path() as path:\n    result = processor.process(path, \"Extract\", schema=MySchema)\n</code></pre>"},{"location":"tutorial-document-input/#google-cloud-storage","title":"Google Cloud Storage","text":"<pre><code>from google.cloud import storage\nimport io\nfrom strutex import DocumentInput, DocumentProcessor\n\nclient = storage.Client()\nbucket = client.bucket(\"my-bucket\")\nblob = bucket.blob(\"invoice.pdf\")\n\n# Download\ncontent = blob.download_as_bytes()\n\n# Process\ndoc = DocumentInput(io.BytesIO(content), filename=\"invoice.pdf\")\n\nwith doc.as_file_path() as path:\n    result = processor.process(path, \"Extract\", schema=MySchema)\n</code></pre>"},{"location":"tutorial-document-input/#best-practices","title":"Best Practices","text":"Practice Why Always use <code>as_file_path()</code> context manager Ensures temp files are cleaned up Provide <code>filename</code> for BytesIO Enables MIME detection Reuse <code>DocumentInput</code> if processing multiple times Avoids re-reading bytes Set explicit <code>mime_type</code> for unknown extensions Prevents detection failures"},{"location":"tutorial-document-input/#next-steps","title":"Next Steps","text":"Want to... Go to... Use with LangChain Integrations Add batch processing Batch &amp; Async Create custom plugins Custom Plugins"},{"location":"tutorial-error-handling/","title":"Error Handling","text":"<p>Handle errors gracefully and debug extraction issues.</p>"},{"location":"tutorial-error-handling/#common-errors","title":"Common Errors","text":""},{"location":"tutorial-error-handling/#filenotfounderror","title":"FileNotFoundError","text":"<pre><code>from strutex import DocumentProcessor, GeminiProvider\n\nprocessor = DocumentProcessor(provider=GeminiProvider())\n\ntry:\n    result = processor.process(\"missing.pdf\", \"Extract\", schema=MySchema)\nexcept FileNotFoundError as e:\n    print(f\"File not found: {e}\")\n    # Handle: check path, download file, etc.\n</code></pre>"},{"location":"tutorial-error-handling/#valueerror-missing-schema","title":"ValueError (Missing Schema)","text":"<pre><code>try:\n    result = processor.process(\"doc.pdf\", \"Extract\")  # No schema!\nexcept ValueError as e:\n    print(f\"Invalid input: {e}\")\n    # Fix: provide schema= or model= argument\n</code></pre>"},{"location":"tutorial-error-handling/#api-errors","title":"API Errors","text":"<pre><code>from strutex.providers.base import ProviderError\n\ntry:\n    result = processor.process(\"doc.pdf\", \"Extract\", schema=MySchema)\nexcept ProviderError as e:\n    print(f\"Provider failed: {e}\")\n    # Handle: retry, switch provider, alert\n</code></pre>"},{"location":"tutorial-error-handling/#security-errors","title":"Security Errors","text":"<pre><code>from strutex.security import SecurityError\n\ntry:\n    result = processor.process(\"doc.pdf\", prompt, schema=MySchema)\nexcept SecurityError as e:\n    print(f\"Security violation: {e}\")\n    # Handle: log, reject request, sanitize input\n</code></pre>"},{"location":"tutorial-error-handling/#error-hook-for-global-handling","title":"Error Hook for Global Handling","text":"<pre><code>from strutex import DocumentProcessor, GeminiProvider\nimport logging\n\ndef global_error_handler(error, file_path, context):\n    \"\"\"Handle all extraction errors.\"\"\"\n    logging.error(f\"Extraction failed for {file_path}: {error}\")\n\n    # Option 1: Return fallback\n    return {\"extraction_failed\": True, \"error\": str(error)}\n\n    # Option 2: Re-raise (return None)\n    # return None\n\nprocessor = DocumentProcessor(\n    provider=GeminiProvider(),\n    on_error=global_error_handler\n)\n</code></pre>"},{"location":"tutorial-error-handling/#retry-strategies","title":"Retry Strategies","text":""},{"location":"tutorial-error-handling/#simple-retry","title":"Simple Retry","text":"<pre><code>import time\nfrom strutex import DocumentProcessor, GeminiProvider\n\ndef process_with_retry(processor, file_path, prompt, schema, max_retries=3):\n    for attempt in range(max_retries):\n        try:\n            return processor.process(file_path, prompt, schema=schema)\n        except Exception as e:\n            if attempt == max_retries - 1:\n                raise\n            wait = 2 ** attempt  # Exponential backoff\n            print(f\"Attempt {attempt + 1} failed, retrying in {wait}s...\")\n            time.sleep(wait)\n\nprocessor = DocumentProcessor(provider=GeminiProvider())\nresult = process_with_retry(processor, \"doc.pdf\", \"Extract\", MySchema)\n</code></pre>"},{"location":"tutorial-error-handling/#using-retryconfig","title":"Using RetryConfig","text":"<pre><code>from strutex import ProviderChain, RetryConfig\nfrom strutex import GeminiProvider, OpenAIProvider\n\n# Create chain with retry config\nchain = ProviderChain(\n    providers=[GeminiProvider(), OpenAIProvider()],\n    retry_config=RetryConfig(\n        max_retries=3,\n        backoff_factor=2.0,\n        retry_on=[ConnectionError, TimeoutError]\n    )\n)\n\nprocessor = DocumentProcessor(provider=chain)\n</code></pre>"},{"location":"tutorial-error-handling/#provider-fallback","title":"Provider Fallback","text":"<p>Fall back to another provider on failure:</p> <pre><code>from strutex import DocumentProcessor, ProviderChain\nfrom strutex import GeminiProvider, OpenAIProvider, OllamaProvider\n\n# Try providers in order\nchain = ProviderChain([\n    GeminiProvider(),      # Try first\n    OpenAIProvider(),      # Fall back\n    OllamaProvider(),      # Last resort (local)\n])\n\nprocessor = DocumentProcessor(provider=chain)\n\n# Automatically tries next provider on failure\nresult = processor.process(\"doc.pdf\", \"Extract\", schema=MySchema)\n</code></pre>"},{"location":"tutorial-error-handling/#debugging-extraction-issues","title":"Debugging Extraction Issues","text":""},{"location":"tutorial-error-handling/#enable-logging","title":"Enable Logging","text":"<pre><code>import logging\n\n# Enable debug logging\nlogging.basicConfig(level=logging.DEBUG)\nlogging.getLogger(\"strutex\").setLevel(logging.DEBUG)\n\nprocessor = DocumentProcessor(provider=GeminiProvider())\nresult = processor.process(\"doc.pdf\", \"Extract\", schema=MySchema)\n# See detailed logs\n</code></pre>"},{"location":"tutorial-error-handling/#inspect-raw-response","title":"Inspect Raw Response","text":"<pre><code># Add post-process hook to see raw result\n@processor.on_post_process\ndef debug_result(result, context):\n    print(f\"Raw result: {result}\")\n    print(f\"Context: {context}\")\n    return result\n</code></pre>"},{"location":"tutorial-error-handling/#check-provider-health","title":"Check Provider Health","text":"<pre><code>from strutex import GeminiProvider\n\nprovider = GeminiProvider()\n\nif provider.health_check():\n    print(\"Provider is healthy\")\nelse:\n    print(\"Provider unavailable\")\n</code></pre>"},{"location":"tutorial-error-handling/#common-issues-solutions","title":"Common Issues &amp; Solutions","text":"Issue Solution \"API key not found\" Set env var: <code>export GOOGLE_API_KEY=...</code> \"Rate limit exceeded\" Add retry with backoff, use caching \"Invalid JSON response\" Check prompt, use verify=True \"Schema validation failed\" Check field types, use Optional[] \"File too large\" Use chunking or switch to Claude \"Extraction timeout\" Increase timeout, use smaller model"},{"location":"tutorial-error-handling/#validation-errors","title":"Validation Errors","text":"<p>Handle validation failures separately:</p> <pre><code>from strutex.validators import ValidationChain, SchemaValidator, SumValidator\n\nchain = ValidationChain([SchemaValidator(), SumValidator()])\n\nresult = processor.process(\"invoice.pdf\", \"Extract\", schema=InvoiceSchema)\n\n# Validate separately\nis_valid, errors = chain.validate(result, InvoiceSchema)\n\nif not is_valid:\n    print(f\"Validation errors: {errors}\")\n    # Handle: log, alert, request human review\n</code></pre>"},{"location":"tutorial-error-handling/#error-recovery-in-batches","title":"Error Recovery in Batches","text":"<pre><code>from strutex import DocumentProcessor, GeminiProvider\n\nprocessor = DocumentProcessor(provider=GeminiProvider())\nfiles = [\"doc1.pdf\", \"doc2.pdf\", \"doc3.pdf\"]\n\nresults = []\nerrors = []\n\nfor file_path in files:\n    try:\n        result = processor.process(file_path, \"Extract\", schema=MySchema)\n        results.append({\"file\": file_path, \"data\": result})\n    except Exception as e:\n        errors.append({\"file\": file_path, \"error\": str(e)})\n\nprint(f\"Success: {len(results)}, Failed: {len(errors)}\")\n\n# Retry failed files with different provider\nif errors:\n    fallback = DocumentProcessor(provider=OpenAIProvider())\n    for err in errors:\n        try:\n            result = fallback.process(err[\"file\"], \"Extract\", schema=MySchema)\n            results.append({\"file\": err[\"file\"], \"data\": result})\n        except:\n            pass  # Truly failed\n</code></pre>"},{"location":"tutorial-error-handling/#next-steps","title":"Next Steps","text":"Want to... Go to... See real examples Use Cases Optimize prompts Prompt Engineering Add caching Caching"},{"location":"tutorial-hooks/","title":"Processing Hooks","text":"<p>Customize extraction behavior with pre/post processing hooks.</p>"},{"location":"tutorial-hooks/#what-are-hooks","title":"What Are Hooks?","text":"<p>Hooks let you run custom code at specific points in the extraction pipeline:</p> <pre><code>Document \u2192 [Pre-Process Hook] \u2192 LLM Extraction \u2192 [Post-Process Hook] \u2192 Result\n                                      \u2193\n                              [Error Hook] (on failure)\n</code></pre>"},{"location":"tutorial-hooks/#adding-hooks-via-constructor","title":"Adding Hooks via Constructor","text":"<pre><code>from strutex import DocumentProcessor, GeminiProvider\n\ndef log_before(file_path, prompt, schema, mime_type, context):\n    print(f\"Processing: {file_path}\")\n    return None  # Return None to keep original values\n\ndef add_metadata(result, context):\n    result[\"processed_at\"] = \"2024-01-01\"\n    result[\"processor_version\"] = \"1.0\"\n    return result\n\ndef handle_error(error, file_path, context):\n    print(f\"Error processing {file_path}: {error}\")\n    return None  # Return None to re-raise, or return fallback dict\n\nprocessor = DocumentProcessor(\n    provider=GeminiProvider(),\n    on_pre_process=log_before,\n    on_post_process=add_metadata,\n    on_error=handle_error\n)\n</code></pre>"},{"location":"tutorial-hooks/#adding-hooks-via-decorators","title":"Adding Hooks via Decorators","text":"<pre><code>from strutex import DocumentProcessor, GeminiProvider\nfrom datetime import datetime\n\nprocessor = DocumentProcessor(provider=GeminiProvider())\n\n@processor.on_pre_process\ndef log_start(file_path, prompt, schema, mime_type, context):\n    context[\"start_time\"] = datetime.now()\n    print(f\"Starting extraction: {file_path}\")\n\n@processor.on_post_process\ndef add_timing(result, context):\n    elapsed = datetime.now() - context[\"start_time\"]\n    result[\"extraction_time_seconds\"] = elapsed.total_seconds()\n    return result\n\n@processor.on_error\ndef fallback_handler(error, file_path, context):\n    # Return empty dict as fallback instead of raising\n    return {\"error\": str(error), \"file\": file_path}\n</code></pre>"},{"location":"tutorial-hooks/#pre-process-hook","title":"Pre-Process Hook","text":"<p>Runs before LLM extraction. Can modify inputs.</p> <pre><code>def pre_process(file_path, prompt, schema, mime_type, context):\n    \"\"\"\n    Args:\n        file_path: Path to document\n        prompt: Extraction prompt\n        schema: Schema being used\n        mime_type: Detected MIME type\n        context: Mutable dict for sharing data between hooks\n\n    Returns:\n        None - keep original values\n        dict - override values, e.g. {\"prompt\": \"Modified prompt\"}\n    \"\"\"\n    # Example: Add context to prompt based on file type\n    if mime_type == \"application/pdf\":\n        return {\"prompt\": prompt + \"\\nThis is a PDF document.\"}\n    return None\n</code></pre>"},{"location":"tutorial-hooks/#post-process-hook","title":"Post-Process Hook","text":"<p>Runs after successful extraction. Can modify result.</p> <pre><code>def post_process(result, context):\n    \"\"\"\n    Args:\n        result: Extracted dict from LLM\n        context: Context dict from pre-process\n\n    Returns:\n        Modified result dict (or original if unchanged)\n    \"\"\"\n    # Example: Normalize currency values\n    if \"total\" in result:\n        result[\"total\"] = round(result[\"total\"], 2)\n\n    # Example: Add audit trail\n    result[\"_source_file\"] = context.get(\"file_path\")\n\n    return result\n</code></pre>"},{"location":"tutorial-hooks/#error-hook","title":"Error Hook","text":"<p>Runs when extraction fails. Can provide fallback.</p> <pre><code>def error_handler(error, file_path, context):\n    \"\"\"\n    Args:\n        error: The exception that occurred\n        file_path: File being processed\n        context: Context dict\n\n    Returns:\n        None - re-raise the original error\n        dict - use as fallback result\n    \"\"\"\n    # Log to external service\n    logging.error(f\"Extraction failed: {error}\")\n\n    # Option 1: Return fallback\n    return {\"extraction_failed\": True, \"error\": str(error)}\n\n    # Option 2: Re-raise\n    return None\n</code></pre>"},{"location":"tutorial-hooks/#multiple-hooks","title":"Multiple Hooks","text":"<p>You can register multiple hooks of the same type:</p> <pre><code>@processor.on_post_process\ndef add_timestamp(result, context):\n    result[\"timestamp\"] = datetime.now().isoformat()\n    return result\n\n@processor.on_post_process\ndef validate_totals(result, context):\n    if result.get(\"total\", 0) &lt; 0:\n        result[\"_warning\"] = \"Negative total detected\"\n    return result\n\n# Both hooks run in order\n</code></pre>"},{"location":"tutorial-hooks/#real-world-examples","title":"Real-World Examples","text":""},{"location":"tutorial-hooks/#logging-monitoring","title":"Logging &amp; Monitoring","text":"<pre><code>import logging\nfrom datetime import datetime\n\n@processor.on_pre_process\ndef log_request(file_path, prompt, schema, mime_type, context):\n    context[\"request_id\"] = str(uuid.uuid4())\n    logging.info(f\"[{context['request_id']}] Starting: {file_path}\")\n\n@processor.on_post_process\ndef log_response(result, context):\n    logging.info(f\"[{context['request_id']}] Complete: {len(result)} fields\")\n    return result\n</code></pre>"},{"location":"tutorial-hooks/#data-normalization","title":"Data Normalization","text":"<pre><code>@processor.on_post_process\ndef normalize_invoice(result, context):\n    # Standardize date format\n    if \"date\" in result:\n        from dateutil import parser\n        result[\"date\"] = parser.parse(result[\"date\"]).strftime(\"%Y-%m-%d\")\n\n    # Ensure currency format\n    for field in [\"total\", \"subtotal\", \"tax\"]:\n        if field in result:\n            result[field] = round(float(result[field]), 2)\n\n    return result\n</code></pre>"},{"location":"tutorial-hooks/#next-steps","title":"Next Steps","text":"Want to... Go to... Add security checks Security Process in batches Batch Processing Use with LangChain Integrations"},{"location":"tutorial-integrations/","title":"Framework Integrations","text":"<p>Use strutex with LangChain, LlamaIndex, and other AI frameworks.</p> <p>[!WARNING] &gt; Experimental: These integrations may break with framework updates. LangChain, LlamaIndex, and Haystack evolve rapidly. Pin dependency versions.</p>"},{"location":"tutorial-integrations/#overview","title":"Overview","text":"<p>Strutex integrates with popular AI/ML frameworks for RAG pipelines:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     Your RAG Pipeline                        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Documents \u2192 [Strutex] \u2192 Structured JSON \u2192 Vector Store     \u2502\n\u2502                              \u2193                               \u2502\n\u2502                     Query \u2192 [LLM] \u2192 Answer                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"tutorial-integrations/#installation","title":"Installation","text":"<pre><code># LangChain integration\npip install strutex[langchain]\n\n# LlamaIndex integration\npip install strutex[llamaindex]\n\n# Both\npip install strutex[all]\n</code></pre>"},{"location":"tutorial-integrations/#langchain-integration","title":"LangChain Integration","text":""},{"location":"tutorial-integrations/#strutexloader","title":"StrutexLoader","text":"<p>Use as a LangChain document loader:</p> <pre><code>from strutex.integrations import StrutexLoader\nfrom strutex.schemas import INVOICE_US\n\n# Create loader\nloader = StrutexLoader(\n    file_path=\"invoice.pdf\",\n    schema=INVOICE_US,\n    provider=\"gemini\"\n)\n\n# Load documents\ndocuments = loader.load()\n\n# Use in LangChain pipeline\nprint(documents[0].page_content)  # JSON string\nprint(documents[0].metadata)       # {\"source\": \"invoice.pdf\", ...}\n</code></pre>"},{"location":"tutorial-integrations/#with-vector-store","title":"With Vector Store","text":"<pre><code>from strutex.integrations import StrutexLoader\nfrom strutex.schemas import INVOICE_US\nfrom langchain_community.vectorstores import Chroma\nfrom langchain_openai import OpenAIEmbeddings\n\n# Load and extract invoices\nloader = StrutexLoader(\"invoices/jan.pdf\", schema=INVOICE_US)\ndocs = loader.load()\n\n# Create vector store\nvectorstore = Chroma.from_documents(docs, OpenAIEmbeddings())\n\n# Query\nresults = vectorstore.similarity_search(\"highest total invoice\")\n</code></pre>"},{"location":"tutorial-integrations/#strutexoutputparser","title":"StrutexOutputParser","text":"<p>Validate LLM output with strutex schemas:</p> <pre><code>from strutex.integrations import StrutexOutputParser\nfrom pydantic import BaseModel\n\nclass InvoiceData(BaseModel):\n    vendor: str\n    total: float\n    date: str\n\nparser = StrutexOutputParser(\n    schema=InvoiceData,\n    validators=[\"schema\", \"sum\"]  # Use strutex validators\n)\n\n# Parse LLM response\nresult = parser.parse(llm_response_text)\nprint(result.vendor)  # Validated Pydantic model\n\n# Get format instructions for prompts\ninstructions = parser.get_format_instructions()\n</code></pre>"},{"location":"tutorial-integrations/#llamaindex-integration","title":"LlamaIndex Integration","text":""},{"location":"tutorial-integrations/#strutexreader","title":"StrutexReader","text":"<p>Use as a LlamaIndex document reader:</p> <pre><code>from strutex.integrations import StrutexReader\nfrom strutex.schemas import INVOICE_GENERIC\n\nreader = StrutexReader(\n    schema=INVOICE_GENERIC,\n    provider=\"openai\"\n)\n\n# Load data\ndocuments = reader.load_data(\"invoice.pdf\")\n\n# Build index\nfrom llama_index.core import VectorStoreIndex\nindex = VectorStoreIndex.from_documents(documents)\n\n# Query\nquery_engine = index.as_query_engine()\nresponse = query_engine.query(\"What was the total amount?\")\n</code></pre>"},{"location":"tutorial-integrations/#strutexnodeparser","title":"StrutexNodeParser","text":"<p>Keep structured documents as single nodes (prevents chunking):</p> <pre><code>from strutex.integrations import StrutexReader, StrutexNodeParser\n\nreader = StrutexReader(schema=MySchema)\ndocs = reader.load_data(\"complex_doc.pdf\")\n\n# Don't chunk structured JSON\nparser = StrutexNodeParser()\nnodes = parser.get_nodes_from_documents(docs)\n\n# Each document stays as one node\nprint(len(nodes))  # Same as len(docs)\n</code></pre>"},{"location":"tutorial-integrations/#full-rag-pipeline-example","title":"Full RAG Pipeline Example","text":"<pre><code>from strutex.integrations import StrutexLoader\nfrom strutex.schemas import INVOICE_US\nfrom langchain_community.vectorstores import Chroma\nfrom langchain_openai import OpenAIEmbeddings, ChatOpenAI\nfrom langchain.chains import RetrievalQA\nfrom pathlib import Path\n\n# 1. Load all invoices from directory\ndocuments = []\nfor pdf in Path(\"invoices/\").glob(\"*.pdf\"):\n    loader = StrutexLoader(str(pdf), schema=INVOICE_US)\n    documents.extend(loader.load())\n\nprint(f\"Loaded {len(documents)} invoices\")\n\n# 2. Create vector store\nvectorstore = Chroma.from_documents(\n    documents,\n    OpenAIEmbeddings()\n)\n\n# 3. Build QA chain\nqa = RetrievalQA.from_chain_type(\n    llm=ChatOpenAI(),\n    retriever=vectorstore.as_retriever()\n)\n\n# 4. Query your invoices\nanswer = qa.invoke(\"Which vendor had the highest total?\")\nprint(answer)\n\nanswer = qa.invoke(\"List all invoices from January\")\nprint(answer)\n</code></pre>"},{"location":"tutorial-integrations/#haystack-integration","title":"Haystack Integration","text":"<p>Use in Haystack 2.x pipelines:</p> <pre><code>from strutex.integrations import StrutexConverter\nfrom strutex.schemas import INVOICE_US\n\nconverter = StrutexConverter(schema=INVOICE_US)\nresult = converter.run(sources=[\"invoice.pdf\"])\n\ndocuments = result[\"documents\"]\n</code></pre>"},{"location":"tutorial-integrations/#unstructured-fallback","title":"Unstructured Fallback","text":"<p>Hybrid mode with consistent error handling:</p> <pre><code>from strutex.integrations import UnstructuredFallbackProcessor, ExtractionError\nfrom strutex.schemas import INVOICE_US\n\n# on_fallback options: \"raise\" (default), \"empty\", \"partial\"\nprocessor = UnstructuredFallbackProcessor(\n    schema=INVOICE_US,\n    provider=\"gemini\",\n    on_fallback=\"raise\"  # Fail loudly for consistent handling\n)\n\ntry:\n    result = processor.process(\"messy_doc.pdf\")\n    print(result[\"vendor_name\"])  # Always returns consistent dict shape\nexcept ExtractionError as e:\n    print(f\"Extraction failed: {e}\")\n    # Handle failure explicitly\n</code></pre> <p>Fallback modes:</p> Mode Behavior <code>\"raise\"</code> Raise <code>ExtractionError</code> on failure (recommended) <code>\"empty\"</code> Return empty dict matching schema <code>\"partial\"</code> Return empty dict with <code>_fallback=True</code> metadata"},{"location":"tutorial-integrations/#next-steps","title":"Next Steps","text":"Want to... Go to... Handle file uploads DocumentInput Create custom plugins Custom Plugins See built-in schemas Built-in Schemas"},{"location":"tutorial-prompts/","title":"Prompt Engineering","text":"<p>Write better prompts for more accurate extraction using the StructuredPrompt builder.</p>"},{"location":"tutorial-prompts/#the-structuredprompt-builder","title":"The StructuredPrompt Builder","text":"<p>Strutex provides a fluent API for building well-organized prompts:</p> <pre><code>from strutex.prompts import StructuredPrompt\n\nprompt = (\n    StructuredPrompt(\"You are an expert invoice data extractor.\")\n    .add_general_rule(\n        \"Strict data fidelity: do not invent values.\",\n        \"Use ISO date format: YYYY-MM-DD.\",\n        \"If a field is missing, return null.\"\n    )\n    .add_field_rule(\n        \"invoice_number\",\n        \"Must match format: INV-XXXX or similar.\",\n        \"Found at top of document.\",\n        critical=True\n    )\n    .add_field_rule(\n        \"total\",\n        \"Final amount after tax and discounts.\",\n        \"Must be numeric.\",\n        critical=True\n    )\n    .add_output_guideline(\n        \"Output valid JSON only.\",\n        \"No markdown formatting.\",\n        \"No code blocks.\"\n    )\n    .compile()\n)\n\nprint(prompt)\n</code></pre> <p>Output:</p> <pre><code>You are an expert invoice data extractor.\n\n### 1. General Principles\n- Strict data fidelity: do not invent values.\n- Use ISO date format: YYYY-MM-DD.\n- If a field is missing, return null.\n\n### 2. Field Rules\n\n**invoice_number**:\n- **CRITICAL**: Must match format: INV-XXXX or similar.\n- **CRITICAL**: Found at top of document.\n\n**total**:\n- **CRITICAL**: Final amount after tax and discounts.\n- **CRITICAL**: Must be numeric.\n\n### 3. Output Format\n- Output valid JSON only.\n- No markdown formatting.\n- No code blocks.\n</code></pre>"},{"location":"tutorial-prompts/#using-with-documentprocessor","title":"Using with DocumentProcessor","text":"<pre><code>from strutex import DocumentProcessor, GeminiProvider\nfrom strutex.prompts import StructuredPrompt\n\n# Build the prompt\nprompt = (\n    StructuredPrompt()\n    .add_general_rule(\"Extract all visible data.\", \"No guessing.\")\n    .add_field_rule(\"vendor_name\", \"Company issuing the invoice.\")\n    .add_field_rule(\"total\", \"Final amount due.\", critical=True)\n    .compile()\n)\n\n# Use with processor\nprocessor = DocumentProcessor(provider=GeminiProvider())\nresult = processor.process(\n    file_path=\"invoice.pdf\",\n    prompt=prompt,  # Use compiled prompt\n    model=Invoice\n)\n</code></pre>"},{"location":"tutorial-prompts/#structuredprompt-api","title":"StructuredPrompt API","text":""},{"location":"tutorial-prompts/#constructor","title":"Constructor","text":"<pre><code>prompt = StructuredPrompt(\n    persona=\"You are a highly accurate AI Data Extraction Assistant.\"\n)\n</code></pre>"},{"location":"tutorial-prompts/#add_general_rulerules","title":"add_general_rule(*rules)","text":"<p>Add high-level extraction principles:</p> <pre><code>prompt.add_general_rule(\n    \"No guessing: only extract visible data.\",\n    \"Dates must be in YYYY-MM-DD format.\",\n    \"Currency amounts should exclude symbols.\"\n)\n</code></pre>"},{"location":"tutorial-prompts/#add_field_rulefield_name-rules-criticalfalse","title":"add_field_rule(field_name, *rules, critical=False)","text":"<p>Add field-specific rules. Use <code>critical=True</code> to emphasize:</p> <pre><code>prompt.add_field_rule(\n    \"invoice_number\",\n    \"Usually at top-right of document.\",\n    \"Format: INV-XXXX or #XXXX.\",\n    critical=True  # Adds **CRITICAL** prefix\n)\n</code></pre>"},{"location":"tutorial-prompts/#add_output_guidelineguidelines","title":"add_output_guideline(*guidelines)","text":"<p>Specify output format requirements:</p> <pre><code>prompt.add_output_guideline(\n    \"Return valid JSON only.\",\n    \"No markdown code blocks.\",\n    \"No explanatory text.\"\n)\n</code></pre>"},{"location":"tutorial-prompts/#compile","title":"compile()","text":"<p>Build the final prompt string:</p> <pre><code>final_prompt = prompt.compile()\n# Or use directly: str(prompt)\n</code></pre>"},{"location":"tutorial-prompts/#from_schemaschema-auto-generate-from-pydantic","title":"from_schema(schema) \u2014 Auto-Generate from Pydantic","text":"<p>Create a prompt with field rules auto-generated from Pydantic Field descriptions:</p> <pre><code>from pydantic import BaseModel, Field\nfrom strutex.prompts import StructuredPrompt\n\nclass Invoice(BaseModel):\n    invoice_number: str = Field(description=\"Unique invoice ID\")\n    total: float = Field(description=\"Final amount due\")\n    tax: float = Field(default=0, description=\"Tax amount if applicable\")\n\n# Auto-generate field rules from schema\nprompt = StructuredPrompt.from_schema(Invoice)\n\n# Add additional rules\nprompt.add_general_rule(\"Use ISO dates\", \"No guessing\")\n\nprint(prompt.compile())\n</code></pre> <p>Output:</p> <pre><code>You are a highly accurate AI Data Extraction Assistant.\n\n### 1. General Principles\n- Use ISO dates\n- No guessing\n\n### 2. Field Rules\n\n**invoice_number**:\n- **CRITICAL**: Unique invoice ID\n\n**total**:\n- **CRITICAL**: Final amount due\n\n**tax**:\n- Tax amount if applicable\n\n### 3. Output Format\n- Output valid JSON only. No markdown.\n</code></pre> <p>Note: Required fields are automatically marked CRITICAL, optional fields are not.</p>"},{"location":"tutorial-prompts/#prompt-templates","title":"Prompt Templates","text":""},{"location":"tutorial-prompts/#invoice-template","title":"Invoice Template","text":"<pre><code>from strutex.prompts import StructuredPrompt\n\nINVOICE_PROMPT = (\n    StructuredPrompt(\"You are an expert invoice data extractor.\")\n    .add_general_rule(\n        \"Extract ALL visible data\u2014do not invent values.\",\n        \"Use ISO 8601 dates: YYYY-MM-DD.\",\n        \"For missing fields, return null.\",\n        \"Amounts should be numeric (no currency symbols).\"\n    )\n    .add_field_rule(\n        \"invoice_number\",\n        \"The unique invoice identifier.\",\n        \"Usually at top of document.\",\n        critical=True\n    )\n    .add_field_rule(\n        \"line_items\",\n        \"Extract ALL line items.\",\n        \"Each item needs: description, quantity, unit_price, total.\",\n        \"If item spans multiple lines, combine.\"\n    )\n    .add_field_rule(\n        \"total\",\n        \"Final amount after tax and discounts.\",\n        \"Verify: subtotal + tax - discount = total.\",\n        critical=True\n    )\n    .add_output_guideline(\"Valid JSON only. No markdown.\")\n    .compile()\n)\n</code></pre>"},{"location":"tutorial-prompts/#receipt-template","title":"Receipt Template","text":"<pre><code>RECEIPT_PROMPT = (\n    StructuredPrompt(\"You are a receipt OCR specialist.\")\n    .add_general_rule(\n        \"Handle low-quality scans gracefully.\",\n        \"Prices may be formatted as $X.XX or X.XX.\",\n        \"Skip separator lines (----, ====).\"\n    )\n    .add_field_rule(\n        \"store_name\",\n        \"Usually at the very top, often in large text.\"\n    )\n    .add_field_rule(\n        \"items\",\n        \"Each purchased item with name and price.\",\n        \"Quantity defaults to 1 if not shown.\"\n    )\n    .add_field_rule(\n        \"total\",\n        \"Final amount paid.\",\n        \"Usually at bottom, often labeled 'TOTAL' or 'AMOUNT DUE'.\",\n        critical=True\n    )\n    .compile()\n)\n</code></pre>"},{"location":"tutorial-prompts/#resume-template","title":"Resume Template","text":"<pre><code>RESUME_PROMPT = (\n    StructuredPrompt(\"You are an expert resume parser.\")\n    .add_general_rule(\n        \"Extract structured data from resume/CV.\",\n        \"Preserve original language for names and companies.\",\n        \"Dates should be YYYY-MM format.\"\n    )\n    .add_field_rule(\n        \"name\",\n        \"Full name, usually the largest text at top.\",\n        critical=True\n    )\n    .add_field_rule(\n        \"experience\",\n        \"List all work experience.\",\n        \"Each entry: company, title, start_date, end_date, responsibilities.\",\n        \"Current jobs have end_date = null.\"\n    )\n    .add_field_rule(\n        \"skills\",\n        \"Technical and soft skills as a list.\",\n        \"May be comma-separated, bulleted, or in a table.\"\n    )\n    .compile()\n)\n</code></pre>"},{"location":"tutorial-prompts/#handling-edge-cases","title":"Handling Edge Cases","text":""},{"location":"tutorial-prompts/#ambiguous-dates","title":"Ambiguous Dates","text":"<pre><code>prompt = (\n    StructuredPrompt()\n    .add_field_rule(\n        \"date\",\n        \"Convert to YYYY-MM-DD format.\",\n        \"If only month/year (e.g., 'March 2024'), use 01 for day.\",\n        \"If relative (e.g., 'Due in 30 days'), set to null.\"\n    )\n    .compile()\n)\n</code></pre>"},{"location":"tutorial-prompts/#missing-data","title":"Missing Data","text":"<pre><code>prompt = (\n    StructuredPrompt()\n    .add_general_rule(\n        \"For missing or unclear values:\",\n        \"- Use null for completely missing fields.\",\n        \"- Use empty string '' for blank fields that exist.\",\n        \"- NEVER invent data that isn't in the document.\"\n    )\n    .compile()\n)\n</code></pre>"},{"location":"tutorial-prompts/#multi-language-documents","title":"Multi-Language Documents","text":"<pre><code>prompt = (\n    StructuredPrompt()\n    .add_general_rule(\n        \"Document may contain multiple languages.\",\n        \"Extract names/companies in original language.\",\n        \"Normalize dates to YYYY-MM-DD regardless of format.\"\n    )\n    .compile()\n)\n</code></pre>"},{"location":"tutorial-prompts/#few-shot-examples","title":"Few-Shot Examples","text":"<p>Add examples for complex fields:</p> <pre><code>prompt = (\n    StructuredPrompt()\n    .add_field_rule(\n        \"vendor_name\",\n        \"Extract the vendor/seller company name.\",\n        \"Examples:\",\n        \"  - 'ACME Corp.' \u2192 'ACME Corp.'\",\n        \"  - 'From: Big Company LLC' \u2192 'Big Company LLC'\",\n        \"  - 'Invoice from ABC Inc.\\\\n123 Main St' \u2192 'ABC Inc.'\"\n    )\n    .compile()\n)\n</code></pre>"},{"location":"tutorial-prompts/#combining-with-schema-descriptions","title":"Combining with Schema Descriptions","text":"<p>Use Pydantic Field descriptions alongside StructuredPrompt:</p> <pre><code>from pydantic import BaseModel, Field\nfrom strutex.prompts import StructuredPrompt\n\nclass Invoice(BaseModel):\n    invoice_number: str = Field(\n        description=\"Unique invoice ID, starts with INV or #\"\n    )\n    total: float = Field(\n        description=\"Final amount after tax\"\n    )\n\nprompt = (\n    StructuredPrompt()\n    .add_general_rule(\"Use ISO dates.\", \"No guessing.\")\n    .add_field_rule(\"total\", \"Verify math: subtotal + tax = total.\", critical=True)\n    .compile()\n)\n\n# Both prompt AND schema descriptions guide the LLM\nresult = processor.process(\"invoice.pdf\", prompt, model=Invoice)\n</code></pre>"},{"location":"tutorial-prompts/#verification-prompts","title":"Verification Prompts","text":"<p>Customize the self-correction pass:</p> <pre><code>result = processor.process(\n    file_path=\"invoice.pdf\",\n    prompt=INVOICE_PROMPT,\n    model=Invoice,\n    verify=True,\n    verify_prompt=\"\"\"\n    Audit the extracted data against the document.\n\n    Check:\n    1. Do line item totals sum to subtotal?\n    2. Does subtotal + tax = total?\n    3. Are all visible line items captured?\n\n    Correct any errors and return the fixed JSON.\n    \"\"\"\n)\n</code></pre>"},{"location":"tutorial-prompts/#debugging-prompts","title":"Debugging Prompts","text":""},{"location":"tutorial-prompts/#see-the-final-prompt","title":"See the Final Prompt","text":"<pre><code>prompt = StructuredPrompt()\nprompt.add_general_rule(\"Rule 1\", \"Rule 2\")\nprompt.add_field_rule(\"total\", \"Must be numeric\", critical=True)\n\n# View the compiled prompt\nprint(prompt.compile())\n\n# Or check structure\nprint(repr(prompt))\n# StructuredPrompt(general_rules=2, field_rules=1, output_guidelines=0)\n</code></pre>"},{"location":"tutorial-prompts/#ab-test-prompts","title":"A/B Test Prompts","text":"<pre><code>prompts = [\n    StructuredPrompt().add_general_rule(\"Extract all data\").compile(),\n    StructuredPrompt().add_general_rule(\"Carefully extract all visible data\").compile(),\n]\n\nfor p in prompts:\n    result = processor.process(\"test.pdf\", p, model=Invoice)\n    print(f\"Prompt: {p[:50]}... \u2192 Total: {result.total}\")\n</code></pre>"},{"location":"tutorial-prompts/#best-practices","title":"Best Practices","text":"Practice Why Use <code>StructuredPrompt</code> for complex prompts Clear organization Mark critical fields LLM pays more attention Specify date/number formats Consistent output Add examples for tricky fields Better accuracy Keep persona relevant Sets context Use <code>verify=True</code> for critical data Catches mistakes"},{"location":"tutorial-prompts/#next-steps","title":"Next Steps","text":"Want to... Go to... See complete examples Use Cases Add validation Validation Handle errors Error Handling"},{"location":"tutorial-providers/","title":"Switching Providers","text":"<p>Learn to configure and use different LLM providers for extraction.</p>"},{"location":"tutorial-providers/#creating-provider-instances","title":"Creating Provider Instances","text":"<p>The recommended way to use providers is to create instances directly:</p> <pre><code>from strutex import DocumentProcessor\nfrom strutex import GeminiProvider, OpenAIProvider, AnthropicProvider\n\n# Create a provider instance\nprovider = GeminiProvider(\n    api_key=\"your-api-key\",  # Or uses GOOGLE_API_KEY env var\n    model=\"gemini-2.0-flash\"\n)\n\n# Use it with the processor\nprocessor = DocumentProcessor(provider=provider)\n\nresult = processor.process(\"invoice.pdf\", \"Extract data\", schema=MySchema)\n</code></pre>"},{"location":"tutorial-providers/#all-available-providers","title":"All Available Providers","text":""},{"location":"tutorial-providers/#geminiprovider-google","title":"GeminiProvider (Google)","text":"<pre><code>from strutex import GeminiProvider\n\nprovider = GeminiProvider(\n    api_key=\"your-key\",          # Or GOOGLE_API_KEY env var\n    model=\"gemini-2.0-flash\",    # Default model\n)\n\n# Access provider info\nprint(provider.name)    # \"gemini\"\nprint(provider.model)   # \"gemini-2.0-flash\"\n</code></pre>"},{"location":"tutorial-providers/#openaiprovider","title":"OpenAIProvider","text":"<pre><code>from strutex import OpenAIProvider\n\nprovider = OpenAIProvider(\n    api_key=\"sk-...\",            # Or OPENAI_API_KEY env var\n    model=\"gpt-4o\",              # Default: gpt-4o-mini\n)\n</code></pre>"},{"location":"tutorial-providers/#anthropicprovider-claude","title":"AnthropicProvider (Claude)","text":"<pre><code>from strutex import AnthropicProvider\n\nprovider = AnthropicProvider(\n    api_key=\"your-key\",                      # Or ANTHROPIC_API_KEY env var\n    model=\"claude-sonnet-4-20250514\",    # Default\n)\n</code></pre>"},{"location":"tutorial-providers/#ollamaprovider-local","title":"OllamaProvider (Local)","text":"<pre><code>from strutex import OllamaProvider\n\nprovider = OllamaProvider(\n    model=\"llama3\",\n    base_url=\"http://localhost:11434\"  # Default Ollama URL\n)\n</code></pre>"},{"location":"tutorial-providers/#groqprovider-fast","title":"GroqProvider (Fast)","text":"<pre><code>from strutex import GroqProvider\n\nprovider = GroqProvider(\n    api_key=\"your-key\",          # Or GROQ_API_KEY env var\n    model=\"llama-3.3-70b-versatile\"\n)\n</code></pre>"},{"location":"tutorial-providers/#langdockprovider-enterprise","title":"LangdockProvider (Enterprise)","text":"<pre><code>from strutex import LangdockProvider\n\nprovider = LangdockProvider(\n    api_key=\"your-key\",\n    model=\"gpt-4o\",\n    region=\"eu\"  # EU or US region\n)\n</code></pre>"},{"location":"tutorial-providers/#choosing-a-provider","title":"Choosing a Provider","text":"Need Provider Why Privacy/Air-gapped <code>OllamaProvider</code> Runs locally Speed <code>GroqProvider</code> Fastest inference Quality <code>OpenAIProvider</code> / <code>AnthropicProvider</code> Best accuracy Cost efficiency <code>GeminiProvider</code> Free tier, low cost Long documents <code>AnthropicProvider</code> 200K context Enterprise/EU <code>LangdockProvider</code> GDPR compliant"},{"location":"tutorial-providers/#provider-chains","title":"Provider Chains","text":"<p>Fall back gracefully between providers:</p> <pre><code>from strutex import DocumentProcessor, ProviderChain, RetryConfig\nfrom strutex import GeminiProvider, OpenAIProvider, OllamaProvider\n\n# Create providers\ngemini = GeminiProvider(model=\"gemini-2.0-flash\")\nopenai = OpenAIProvider(model=\"gpt-4o\")\nollama = OllamaProvider(model=\"llama3\")\n\n# Chain them: try in order, fall back on failure\nchain = ProviderChain(\n    providers=[ollama, gemini, openai],  # Try local first\n    retry_config=RetryConfig(max_retries=2)\n)\n\nprocessor = DocumentProcessor(provider=chain)\n</code></pre>"},{"location":"tutorial-providers/#pre-built-chains","title":"Pre-built Chains","text":"<pre><code>from strutex import local_first_chain, cost_optimized_chain\n\n# Try local Ollama first, fall back to cloud\nchain = local_first_chain(\n    local_model=\"llama3\",\n    cloud_provider=\"gemini\"\n)\n\n# Try cheapest providers first\nchain = cost_optimized_chain([\"groq\", \"gemini\", \"openai\"])\n\nprocessor = DocumentProcessor(provider=chain)\n</code></pre>"},{"location":"tutorial-providers/#hybridprovider-auto-select","title":"HybridProvider (Auto-Select)","text":"<p>Automatically choose provider based on document:</p> <pre><code>from strutex import HybridProvider, HybridStrategy\nfrom strutex import GeminiProvider, AnthropicProvider\n\nhybrid = HybridProvider(\n    providers={\n        \"default\": GeminiProvider(),\n        \"long_document\": AnthropicProvider(),  # For docs &gt; 50 pages\n    },\n    strategy=HybridStrategy.DOCUMENT_SIZE\n)\n\nprocessor = DocumentProcessor(provider=hybrid)\n</code></pre>"},{"location":"tutorial-providers/#accessing-provider-name","title":"Accessing Provider Name","text":"<p>After creating a processor, you can access the provider name:</p> <pre><code>processor = DocumentProcessor(provider=GeminiProvider())\nprint(processor.provider_name)  # \"gemini\"\n</code></pre>"},{"location":"tutorial-providers/#environment-variables","title":"Environment Variables","text":"<p>Each provider checks for its API key in environment variables:</p> <pre><code># Set in your shell or .env file\nexport GOOGLE_API_KEY=\"your-gemini-key\"\nexport OPENAI_API_KEY=\"your-openai-key\"\nexport ANTHROPIC_API_KEY=\"your-anthropic-key\"\nexport GROQ_API_KEY=\"your-groq-key\"\n</code></pre> <pre><code># Then create provider without explicit key\nprovider = GeminiProvider()  # Uses GOOGLE_API_KEY\n</code></pre>"},{"location":"tutorial-providers/#next-steps","title":"Next Steps","text":"Want to... Go to... Add validation rules Adding Validation Configure caching Caching Add hooks Processing Hooks"},{"location":"tutorial-quickstart/","title":"Quickstart","text":"<p>Extract structured data from your first document in 5 minutes.</p>"},{"location":"tutorial-quickstart/#installation","title":"Installation","text":"<pre><code>pip install strutex\n</code></pre>"},{"location":"tutorial-quickstart/#your-first-extraction","title":"Your First Extraction","text":"<pre><code>from strutex import DocumentProcessor\nfrom strutex.schemas import INVOICE_US\n\n# Create processor\nprocessor = DocumentProcessor(provider=\"gemini\")  # or \"openai\", \"anthropic\"\n\n# Extract structured data\nresult = processor.process(\n    file_path=\"invoice.pdf\",\n    prompt=\"Extract invoice details\",\n    schema=INVOICE_US\n)\n\n# Use the result\nprint(f\"Vendor: {result['vendor_name']}\")\nprint(f\"Total: ${result['total']}\")\nprint(f\"Date: {result['date']}\")\n</code></pre> <p>That's it! You've extracted structured JSON from a document.</p>"},{"location":"tutorial-quickstart/#what-just-happened","title":"What Just Happened?","text":"<ol> <li>DocumentProcessor \u2014 The main engine that handles extraction</li> <li>INVOICE_US \u2014 A built-in schema defining what fields to extract</li> <li>process() \u2014 Sends the document to an LLM and validates the result</li> </ol>"},{"location":"tutorial-quickstart/#next-steps","title":"Next Steps","text":"Want to... Go to... Define your own schema Your First Schema Try different providers Switching Providers Add data validation Adding Validation"},{"location":"tutorial-quickstart/#troubleshooting","title":"Troubleshooting","text":"<p>\"API key not found\"</p> <pre><code>export GOOGLE_API_KEY=\"your-key\"  # For Gemini\nexport OPENAI_API_KEY=\"your-key\"  # For OpenAI\n</code></pre> <p>\"File not found\"</p> <pre><code># Use absolute path\nresult = processor.process(\"/full/path/to/invoice.pdf\", ...)\n</code></pre>"},{"location":"tutorial-schema/","title":"Your First Schema","text":"<p>Learn to define custom schemas for your specific documents.</p>"},{"location":"tutorial-schema/#why-custom-schemas","title":"Why Custom Schemas?","text":"<p>Built-in schemas like <code>INVOICE_US</code> are great for standard documents. But your documents might have:</p> <ul> <li>Custom fields (e.g., <code>reference_number</code>, <code>department_code</code>)</li> <li>Different structure (e.g., multiple addresses)</li> <li>Domain-specific data (e.g., medical codes, legal citations)</li> </ul>"},{"location":"tutorial-schema/#option-1-pydantic-models-recommended","title":"Option 1: Pydantic Models (Recommended)","text":"<p>The cleanest way to define schemas:</p> <pre><code>from pydantic import BaseModel\nfrom typing import List, Optional\nfrom strutex import DocumentProcessor\n\n# Define your schema\nclass LineItem(BaseModel):\n    description: str\n    quantity: int\n    unit_price: float\n    total: float\n\nclass PurchaseOrder(BaseModel):\n    po_number: str\n    vendor: str\n    ship_to: str\n    order_date: str\n    items: List[LineItem]\n    subtotal: float\n    tax: Optional[float] = None\n    total: float\n\n# Use it\nprocessor = DocumentProcessor(provider=\"gemini\")\nresult = processor.process(\n    file_path=\"purchase_order.pdf\",\n    prompt=\"Extract all purchase order details\",\n    model=PurchaseOrder  # Note: 'model' not 'schema'\n)\n\n# Result is a validated Pydantic model\nprint(f\"PO#: {result.po_number}\")\nfor item in result.items:\n    print(f\"  - {item.description}: ${item.total}\")\n</code></pre>"},{"location":"tutorial-schema/#option-2-schema-types-no-pydantic","title":"Option 2: Schema Types (No Pydantic)","text":"<p>If you prefer not to use Pydantic:</p> <pre><code>from strutex import DocumentProcessor, Object, String, Number, Array\n\n# Define schema using strutex types\norder_schema = Object(\n    description=\"Purchase Order\",\n    properties={\n        \"po_number\": String(description=\"Purchase order number\"),\n        \"vendor\": String(description=\"Vendor name\"),\n        \"total\": Number(description=\"Total amount\"),\n        \"items\": Array(\n            items=Object(properties={\n                \"description\": String(),\n                \"quantity\": Number(),\n                \"price\": Number()\n            })\n        )\n    }\n)\n\n# Use it\nresult = processor.process(\n    file_path=\"order.pdf\",\n    prompt=\"Extract purchase order\",\n    schema=order_schema  # Note: 'schema' not 'model'\n)\n\n# Result is a dict\nprint(result[\"po_number\"])\n</code></pre>"},{"location":"tutorial-schema/#schema-best-practices","title":"Schema Best Practices","text":"Do Don't Use descriptive field names Use abbreviations (<code>amt</code> \u2192 <code>amount</code>) Add <code>description</code> to complex fields Leave descriptions empty Use <code>Optional</code> for fields that may be missing Require everything Keep nesting shallow (3 levels max) Create deeply nested structures"},{"location":"tutorial-schema/#field-types-reference","title":"Field Types Reference","text":"Pydantic Type Strutex Type Use For <code>str</code> <code>String()</code> Text, IDs, names <code>int</code> <code>Integer()</code> Counts, quantities <code>float</code> <code>Number()</code> Prices, percentages <code>bool</code> <code>Boolean()</code> Yes/no fields <code>List[T]</code> <code>Array(items=T)</code> Line items, tags <code>Optional[T]</code> nullable=True Fields that may be missing"},{"location":"tutorial-schema/#next-steps","title":"Next Steps","text":"Want to... Go to... Try different LLM providers Switching Providers Add validation rules Adding Validation See real-world schemas Built-in Schemas"},{"location":"tutorial-security/","title":"Input Sanitization","text":"<p>Clean and validate inputs to reduce prompt injection risks.</p> <p>[!WARNING] &gt; Honest disclaimer: These are sanitization tools, not a complete security solution. Syntactic cleaning (whitespace, HTML removal) does NOT prevent semantic prompt injection. A sophisticated attacker can craft prompts that bypass pattern-based detection. Use these as defense-in-depth, not as your only protection.</p>"},{"location":"tutorial-security/#what-it-does-and-doesnt","title":"What It Does (and Doesn't)","text":"Feature Protects Against Does NOT Protect Against <code>PromptSanitizer</code> Malformed input, control chars, excessively long input Semantic jailbreaks <code>InjectionDetector</code> Common injection phrases Novel/obfuscated injections <code>PIIRedactor</code> Accidental PII exposure Intentional data exfiltration"},{"location":"tutorial-security/#sanitization-chain","title":"Sanitization Chain","text":"<pre><code>from strutex import DocumentProcessor, GeminiProvider\nfrom strutex.security import SanitizationChain, InjectionDetector, PromptSanitizer\n\n# Create sanitization chain\nsanitizers = SanitizationChain([\n    PromptSanitizer(remove_html=True, max_length=10000),\n    InjectionDetector()\n])\n\nprocessor = DocumentProcessor(\n    provider=GeminiProvider(),\n    security=sanitizers  # Still uses 'security' param for backwards compat\n)\n\nresult = processor.process(\"invoice.pdf\", prompt, schema=MySchema)\n</code></pre>"},{"location":"tutorial-security/#promptsanitizer","title":"PromptSanitizer","text":"<p>Cleans input before sending to LLM:</p> <pre><code>from strutex.security import PromptSanitizer\n\nsanitizer = PromptSanitizer(\n    remove_html=True,           # Strip HTML tags\n    remove_control_chars=True,  # Strip \\x00, etc.\n    collapse_whitespace=True,   # Normalize spaces\n    max_length=10000            # Truncate long input\n)\n</code></pre>"},{"location":"tutorial-security/#injectiondetector","title":"InjectionDetector","text":"<p>Pattern-based detection of common injection attempts:</p> <pre><code>from strutex.security import InjectionDetector\n\ndetector = InjectionDetector(\n    patterns=[\n        r\"ignore previous instructions\",\n        r\"disregard all\",\n        r\"you are now\",\n        r\"forget everything\",\n    ]\n)\n\n# Raises SanitizationError if pattern matches\n</code></pre> <p>[!CAUTION] Pattern matching is easily bypassed. Attackers can use typos, Unicode lookalikes, or rephrasing to evade detection. Don't rely on this alone.</p>"},{"location":"tutorial-security/#piiredactor","title":"PIIRedactor","text":"<p>Redact sensitive data from outputs:</p> <pre><code>from strutex.security import PIIRedactor\n\nredactor = PIIRedactor(\n    patterns={\n        \"ssn\": r\"\\d{3}-\\d{2}-\\d{4}\",\n        \"credit_card\": r\"\\d{4}[- ]?\\d{4}[- ]?\\d{4}[- ]?\\d{4}\",\n        \"email\": r\"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}\",\n    },\n    replacement=\"[REDACTED]\"\n)\n\n# {\"ssn\": \"123-45-6789\"} \u2192 {\"ssn\": \"[REDACTED]\"}\n</code></pre>"},{"location":"tutorial-security/#best-practices","title":"Best Practices","text":"Scenario Recommendation User-provided prompts <code>PromptSanitizer</code> + length limits Untrusted documents Don't extract prompts from documents Sensitive output <code>PIIRedactor</code> as defense-in-depth High security needs Human review of outputs"},{"location":"tutorial-security/#what-you-should-actually-do","title":"What You Should Actually Do","text":"<ol> <li>Don't trust LLM output \u2014 Validate with Pydantic schemas</li> <li>Limit prompt sources \u2014 Don't let users write arbitrary prompts</li> <li>Log everything \u2014 Audit trail for incident response</li> <li>Set output length limits \u2014 Prevent exfiltration via verbose output</li> <li>Use structured extraction \u2014 Schema constraints limit attack surface</li> </ol>"},{"location":"tutorial-security/#error-handling","title":"Error Handling","text":"<pre><code>from strutex.security import SanitizationError\n\ntry:\n    result = processor.process(\"doc.pdf\", user_prompt, schema=MySchema)\nexcept SanitizationError as e:\n    print(f\"Input rejected: {e}\")\n    # Log attempt, don't process\n</code></pre>"},{"location":"tutorial-security/#next-steps","title":"Next Steps","text":"Want to... Go to... Process in batches Batch Processing Handle errors Error Handling"},{"location":"tutorial-streaming/","title":"Streaming","text":"<p>Get real-time feedback during extraction for better UX.</p>"},{"location":"tutorial-streaming/#why-streaming","title":"Why Streaming?","text":"<p>For large documents, extraction can take 10-30 seconds. Streaming provides:</p> <ul> <li>Progress feedback \u2014 Users see something is happening</li> <li>Early results \u2014 Partial data before completion</li> <li>Cancellation \u2014 Stop extraction mid-way</li> </ul>"},{"location":"tutorial-streaming/#basic-streaming","title":"Basic Streaming","text":"<p>Use the <code>stream</code> parameter:</p> <pre><code>from strutex import DocumentProcessor, GeminiProvider\n\nprocessor = DocumentProcessor(provider=GeminiProvider())\n\n# Stream extraction\nfor chunk in processor.stream(\n    file_path=\"large_document.pdf\",\n    prompt=\"Extract all sections\",\n    schema=MySchema\n):\n    print(chunk, end=\"\", flush=True)\n</code></pre>"},{"location":"tutorial-streaming/#streaming-with-callbacks","title":"Streaming with Callbacks","text":"<p>Get structured updates during extraction:</p> <pre><code>from strutex import DocumentProcessor, GeminiProvider\n\ndef on_chunk(chunk: str, context: dict):\n    \"\"\"Called for each streamed chunk.\"\"\"\n    print(f\"Received: {chunk[:50]}...\")\n\ndef on_complete(result: dict, context: dict):\n    \"\"\"Called when extraction completes.\"\"\"\n    print(f\"Complete! Got {len(result)} fields\")\n\nprocessor = DocumentProcessor(provider=GeminiProvider())\n\nresult = processor.stream(\n    file_path=\"document.pdf\",\n    prompt=\"Extract data\",\n    schema=MySchema,\n    on_chunk=on_chunk,\n    on_complete=on_complete\n)\n</code></pre>"},{"location":"tutorial-streaming/#streaming-in-web-apps","title":"Streaming in Web Apps","text":""},{"location":"tutorial-streaming/#fastapi-with-sse","title":"FastAPI with SSE","text":"<pre><code>from fastapi import FastAPI\nfrom fastapi.responses import StreamingResponse\nfrom strutex import DocumentProcessor, GeminiProvider\n\napp = FastAPI()\nprocessor = DocumentProcessor(provider=GeminiProvider())\n\n@app.get(\"/extract/stream\")\nasync def stream_extraction(file_path: str):\n    async def generate():\n        for chunk in processor.stream(file_path, \"Extract\", schema=MySchema):\n            yield f\"data: {chunk}\\n\\n\"\n        yield \"data: [DONE]\\n\\n\"\n\n    return StreamingResponse(\n        generate(),\n        media_type=\"text/event-stream\"\n    )\n</code></pre>"},{"location":"tutorial-streaming/#javascript-client","title":"JavaScript Client","text":"<pre><code>const eventSource = new EventSource(\"/extract/stream?file_path=doc.pdf\");\n\neventSource.onmessage = (event) =&gt; {\n  if (event.data === \"[DONE]\") {\n    eventSource.close();\n    console.log(\"Extraction complete\");\n  } else {\n    document.getElementById(\"output\").innerHTML += event.data;\n  }\n};\n</code></pre>"},{"location":"tutorial-streaming/#progress-tracking","title":"Progress Tracking","text":"<p>Track extraction progress for progress bars:</p> <pre><code>from strutex import DocumentProcessor, GeminiProvider\n\nprocessor = DocumentProcessor(provider=GeminiProvider())\n\ntotal_chars = 0\nestimated_total = 5000  # Estimate based on document size\n\nfor chunk in processor.stream(\"doc.pdf\", \"Extract\", schema=MySchema):\n    total_chars += len(chunk)\n    progress = min(total_chars / estimated_total * 100, 99)\n    print(f\"\\rProgress: {progress:.0f}%\", end=\"\")\n\nprint(\"\\rProgress: 100%\")\n</code></pre>"},{"location":"tutorial-streaming/#async-streaming","title":"Async Streaming","text":"<p>Use async streaming for better performance:</p> <pre><code>import asyncio\nfrom strutex import DocumentProcessor, GeminiProvider\n\nprocessor = DocumentProcessor(provider=GeminiProvider())\n\nasync def stream_extract():\n    async for chunk in processor.astream(\n        file_path=\"document.pdf\",\n        prompt=\"Extract data\",\n        schema=MySchema\n    ):\n        print(chunk, end=\"\", flush=True)\n\nasyncio.run(stream_extract())\n</code></pre>"},{"location":"tutorial-streaming/#provider-support","title":"Provider Support","text":"Provider Streaming Support GeminiProvider \u2705 Full OpenAIProvider \u2705 Full AnthropicProvider \u2705 Full OllamaProvider \u2705 Full GroqProvider \u26a0\ufe0f Limited ProviderChain \u274c No"},{"location":"tutorial-streaming/#best-practices","title":"Best Practices","text":"Practice Why Use streaming for docs &gt; 5 pages Better UX for long operations Show loading indicator initially Stream may take 1-2s to start Handle connection drops Implement retry on disconnect Buffer chunks on server Don't send every character"},{"location":"tutorial-streaming/#next-steps","title":"Next Steps","text":"Want to... Go to... Handle errors Error Handling See use cases Use Cases Optimize prompts Prompt Engineering"},{"location":"tutorial-use-cases/","title":"Use Cases","text":"<p>Complete working examples for common document types.</p>"},{"location":"tutorial-use-cases/#invoice-extraction","title":"Invoice Extraction","text":""},{"location":"tutorial-use-cases/#schema","title":"Schema","text":"<pre><code>from pydantic import BaseModel\nfrom typing import List, Optional\n\nclass LineItem(BaseModel):\n    description: str\n    quantity: int\n    unit_price: float\n    total: float\n\nclass Invoice(BaseModel):\n    invoice_number: str\n    vendor_name: str\n    vendor_address: Optional[str] = None\n    customer_name: str\n    customer_address: Optional[str] = None\n    date: str\n    due_date: Optional[str] = None\n    items: List[LineItem]\n    subtotal: float\n    tax: Optional[float] = None\n    discount: Optional[float] = None\n    total: float\n    payment_terms: Optional[str] = None\n</code></pre>"},{"location":"tutorial-use-cases/#extraction","title":"Extraction","text":"<pre><code>from strutex import DocumentProcessor, GeminiProvider, MemoryCache\n\nprocessor = DocumentProcessor(\n    provider=GeminiProvider(),\n    cache=MemoryCache(ttl=3600)\n)\n\nresult = processor.process(\n    file_path=\"invoice.pdf\",\n    prompt=\"\"\"\n    Extract all invoice details including:\n    - Invoice number and dates\n    - Vendor and customer information\n    - All line items with quantities and prices\n    - Subtotal, tax, and total\n    \"\"\",\n    model=Invoice,\n    verify=True  # Self-correction for accuracy\n)\n\nprint(f\"Invoice #{result.invoice_number}\")\nprint(f\"Vendor: {result.vendor_name}\")\nprint(f\"Total: ${result.total:.2f}\")\nfor item in result.items:\n    print(f\"  - {item.description}: ${item.total:.2f}\")\n</code></pre>"},{"location":"tutorial-use-cases/#or-use-built-in-schema","title":"Or Use Built-in Schema","text":"<pre><code>from strutex.schemas import INVOICE_US\n\nresult = processor.process(\n    file_path=\"invoice.pdf\",\n    prompt=\"Extract invoice details\",\n    schema=INVOICE_US\n)\n</code></pre>"},{"location":"tutorial-use-cases/#receipt-extraction","title":"Receipt Extraction","text":""},{"location":"tutorial-use-cases/#schema_1","title":"Schema","text":"<pre><code>from pydantic import BaseModel\nfrom typing import List, Optional\n\nclass PurchasedItem(BaseModel):\n    name: str\n    quantity: int = 1\n    price: float\n\nclass Receipt(BaseModel):\n    store_name: str\n    store_address: Optional[str] = None\n    date: str\n    time: Optional[str] = None\n    items: List[PurchasedItem]\n    subtotal: float\n    tax: float\n    total: float\n    payment_method: Optional[str] = None\n    card_last_four: Optional[str] = None\n</code></pre>"},{"location":"tutorial-use-cases/#extraction_1","title":"Extraction","text":"<pre><code>from strutex import DocumentProcessor, GeminiProvider\n\nprocessor = DocumentProcessor(provider=GeminiProvider())\n\nresult = processor.process(\n    file_path=\"receipt.jpg\",  # Works with images!\n    prompt=\"\"\"\n    Extract receipt details:\n    - Store name and address\n    - Date and time\n    - All purchased items with prices\n    - Tax and total\n    - Payment method\n    \"\"\",\n    model=Receipt\n)\n\nprint(f\"Store: {result.store_name}\")\nprint(f\"Date: {result.date}\")\nprint(f\"Total: ${result.total:.2f}\")\n</code></pre>"},{"location":"tutorial-use-cases/#resumecv-extraction","title":"Resume/CV Extraction","text":""},{"location":"tutorial-use-cases/#schema_2","title":"Schema","text":"<pre><code>from pydantic import BaseModel\nfrom typing import List, Optional\n\nclass Education(BaseModel):\n    institution: str\n    degree: str\n    field: str\n    graduation_year: Optional[int] = None\n    gpa: Optional[float] = None\n\nclass Experience(BaseModel):\n    company: str\n    title: str\n    start_date: str\n    end_date: Optional[str] = None  # None = current\n    responsibilities: List[str]\n\nclass Resume(BaseModel):\n    name: str\n    email: str\n    phone: Optional[str] = None\n    location: Optional[str] = None\n    summary: Optional[str] = None\n    skills: List[str]\n    education: List[Education]\n    experience: List[Experience]\n    certifications: Optional[List[str]] = None\n    languages: Optional[List[str]] = None\n</code></pre>"},{"location":"tutorial-use-cases/#extraction_2","title":"Extraction","text":"<pre><code>from strutex import DocumentProcessor, GeminiProvider\n\nprocessor = DocumentProcessor(provider=GeminiProvider())\n\nresult = processor.process(\n    file_path=\"resume.pdf\",\n    prompt=\"\"\"\n    Extract all resume information:\n    - Contact details\n    - Professional summary\n    - Skills (as a list)\n    - Education history\n    - Work experience with responsibilities\n    - Certifications and languages\n    \"\"\",\n    model=Resume\n)\n\nprint(f\"Candidate: {result.name}\")\nprint(f\"Email: {result.email}\")\nprint(f\"Skills: {', '.join(result.skills[:5])}...\")\nprint(f\"Experience: {len(result.experience)} positions\")\n</code></pre>"},{"location":"tutorial-use-cases/#purchase-order-extraction","title":"Purchase Order Extraction","text":""},{"location":"tutorial-use-cases/#schema_3","title":"Schema","text":"<pre><code>from pydantic import BaseModel\nfrom typing import List, Optional\n\nclass POLineItem(BaseModel):\n    sku: Optional[str] = None\n    description: str\n    quantity: int\n    unit_price: float\n    total: float\n\nclass PurchaseOrder(BaseModel):\n    po_number: str\n    date: str\n    vendor_name: str\n    vendor_address: Optional[str] = None\n    ship_to_address: str\n    bill_to_address: Optional[str] = None\n    items: List[POLineItem]\n    subtotal: float\n    shipping: Optional[float] = None\n    tax: Optional[float] = None\n    total: float\n    delivery_date: Optional[str] = None\n    payment_terms: Optional[str] = None\n</code></pre>"},{"location":"tutorial-use-cases/#extraction_3","title":"Extraction","text":"<pre><code>result = processor.process(\n    file_path=\"purchase_order.pdf\",\n    prompt=\"Extract purchase order details\",\n    model=PurchaseOrder,\n    verify=True\n)\n\nprint(f\"PO#: {result.po_number}\")\nprint(f\"Vendor: {result.vendor_name}\")\nprint(f\"Total: ${result.total:.2f}\")\n</code></pre>"},{"location":"tutorial-use-cases/#medical-records","title":"Medical Records","text":""},{"location":"tutorial-use-cases/#schema_4","title":"Schema","text":"<pre><code>from pydantic import BaseModel\nfrom typing import List, Optional\n\nclass Medication(BaseModel):\n    name: str\n    dosage: str\n    frequency: str\n    start_date: Optional[str] = None\n\nclass MedicalRecord(BaseModel):\n    patient_name: str\n    date_of_birth: Optional[str] = None\n    visit_date: str\n    provider_name: str\n    diagnosis: List[str]\n    medications: List[Medication]\n    notes: Optional[str] = None\n    follow_up: Optional[str] = None\n</code></pre>"},{"location":"tutorial-use-cases/#extraction-with-security","title":"Extraction with Security","text":"<pre><code>from strutex import DocumentProcessor, GeminiProvider\nfrom strutex.security import SecurityChain, PIIRedactor\n\n# Add PII redaction for HIPAA compliance\nsecurity = SecurityChain([PIIRedactor()])\n\nprocessor = DocumentProcessor(\n    provider=GeminiProvider(),\n    security=security\n)\n\nresult = processor.process(\n    file_path=\"medical_record.pdf\",\n    prompt=\"Extract medical visit information\",\n    model=MedicalRecord\n)\n\n# PII is automatically redacted\n</code></pre>"},{"location":"tutorial-use-cases/#batch-processing-multiple-types","title":"Batch Processing Multiple Types","text":"<pre><code>from strutex import DocumentProcessor, GeminiProvider\nfrom pathlib import Path\n\nprocessor = DocumentProcessor(provider=GeminiProvider())\n\n# Schema mapping\nSCHEMAS = {\n    \"invoice\": Invoice,\n    \"receipt\": Receipt,\n    \"resume\": Resume,\n}\n\ndef process_document(file_path: str, doc_type: str):\n    schema = SCHEMAS.get(doc_type)\n    if not schema:\n        raise ValueError(f\"Unknown document type: {doc_type}\")\n\n    return processor.process(\n        file_path=file_path,\n        prompt=f\"Extract all {doc_type} information\",\n        model=schema\n    )\n\n# Process different documents\ninvoice = process_document(\"invoice.pdf\", \"invoice\")\nreceipt = process_document(\"receipt.jpg\", \"receipt\")\nresume = process_document(\"cv.pdf\", \"resume\")\n</code></pre>"},{"location":"tutorial-use-cases/#next-steps","title":"Next Steps","text":"Want to... Go to... Optimize prompts Prompt Engineering Add validation Validation Handle errors Error Handling"},{"location":"tutorial-validation/","title":"Adding Validation","text":"<p>Learn to validate extracted data for accuracy and consistency.</p>"},{"location":"tutorial-validation/#why-validate","title":"Why Validate?","text":"<p>LLMs can make mistakes:</p> <ul> <li>Math errors \u2014 totals don't add up</li> <li>Date formatting \u2014 inconsistent formats</li> <li>Missing required fields \u2014 schema not enforced</li> <li>Hallucinations \u2014 data invented from nothing</li> </ul> <p>Validation catches these before they reach your application.</p>"},{"location":"tutorial-validation/#built-in-validators","title":"Built-in Validators","text":""},{"location":"tutorial-validation/#schemavalidator-always-active","title":"SchemaValidator (Always Active)","text":"<p>Validates that output matches your schema structure:</p> <pre><code>from strutex import DocumentProcessor\nfrom pydantic import BaseModel\n\nclass Invoice(BaseModel):\n    invoice_number: str\n    total: float\n\nprocessor = DocumentProcessor(provider=\"gemini\")\nresult = processor.process(\"invoice.pdf\", \"Extract\", model=Invoice)\n# \u2705 Schema validation happens automatically\n</code></pre>"},{"location":"tutorial-validation/#sumvalidator","title":"SumValidator","text":"<p>Checks that line items add up to totals:</p> <pre><code>from strutex import DocumentProcessor\nfrom strutex.validators import ValidationChain, SchemaValidator, SumValidator\n\n# Create validation chain\nvalidators = ValidationChain([\n    SchemaValidator(),\n    SumValidator()  # Checks: sum(items.price) == total\n])\n\n# The SumValidator will flag if totals don't match\n# useful for invoices, receipts, purchase orders\n</code></pre>"},{"location":"tutorial-validation/#datevalidator","title":"DateValidator","text":"<p>Ensures dates are valid and consistent:</p> <pre><code>from strutex.validators import DateValidator\n\nvalidators = ValidationChain([\n    SchemaValidator(),\n    DateValidator()  # Checks date format validity\n])\n</code></pre>"},{"location":"tutorial-validation/#verification-loop-self-correction","title":"Verification Loop (Self-Correction)","text":"<p>Let the LLM audit its own work:</p> <pre><code>result = processor.process(\n    file_path=\"invoice.pdf\",\n    prompt=\"Extract invoice\",\n    model=Invoice,\n    verify=True  # \ud83d\udd04 LLM reviews and corrects errors\n)\n</code></pre> <p>How it works:</p> <ol> <li>First pass: Extract data</li> <li>Second pass: LLM reviews extraction against document</li> <li>Returns corrected result if errors found</li> </ol> <p>This catches ~30% more errors at 2x API cost.</p>"},{"location":"tutorial-validation/#custom-validation","title":"Custom Validation","text":"<p>Add your own business logic:</p> <pre><code>from strutex import DocumentProcessor\n\ndef validate_invoice(result, context):\n    errors = []\n\n    # Check PO number format\n    if not result.get(\"po_number\", \"\").startswith(\"PO-\"):\n        errors.append(\"PO number must start with 'PO-'\")\n\n    # Check date is not in future\n    from datetime import datetime\n    if result.get(\"date\"):\n        inv_date = datetime.strptime(result[\"date\"], \"%Y-%m-%d\")\n        if inv_date &gt; datetime.now():\n            errors.append(\"Invoice date cannot be in the future\")\n\n    if errors:\n        result[\"_validation_warnings\"] = errors\n\n    return result\n\n# Register as post-process hook\nprocessor = DocumentProcessor(\n    provider=\"gemini\",\n    on_post_process=validate_invoice\n)\n</code></pre>"},{"location":"tutorial-validation/#validation-strategies","title":"Validation Strategies","text":"Scenario Strategy Invoices/receipts <code>SumValidator</code> + <code>verify=True</code> Dates matter <code>DateValidator</code> Critical data All validators + custom rules High volume <code>SchemaValidator</code> only (fast) Compliance Custom hooks for business rules"},{"location":"tutorial-validation/#error-handling","title":"Error Handling","text":"<pre><code>from strutex.validators import ValidationChain, SchemaValidator, SumValidator\n\nchain = ValidationChain([SchemaValidator(), SumValidator()])\n\n# Validate manually\nis_valid, errors = chain.validate(result, schema)\n\nif not is_valid:\n    print(f\"Validation failed: {errors}\")\n    # Handle errors...\n</code></pre>"},{"location":"tutorial-validation/#next-steps","title":"Next Steps","text":"Want to... Go to... Learn about caching Caching Add security checks Security Layer Use in RAG pipelines Integrations"},{"location":"validators/","title":"Validators","text":"<p>Validate LLM output for correctness and data quality.</p>"},{"location":"validators/#overview","title":"Overview","text":"<p>Validators check extracted data against rules and can be composed into chains.</p> <pre><code>from strutex import SchemaValidator, SumValidator, ValidationChain\n\nchain = ValidationChain([\n    SchemaValidator(),\n    SumValidator(tolerance=0.01),\n])\n\nresult = chain.validate(data, schema)\nif not result.valid:\n    print(result.issues)\n</code></pre>"},{"location":"validators/#built-in-validators","title":"Built-in Validators","text":""},{"location":"validators/#schemavalidator","title":"SchemaValidator","text":"<p>Ensures output structure matches expected schema.</p> <pre><code>from strutex import SchemaValidator, Object, String, Number\n\nschema = Object(properties={\n    \"invoice_number\": String(),\n    \"total\": Number(),\n})\n\nvalidator = SchemaValidator()\nresult = validator.validate(data, schema)\n</code></pre> <p>Checks:</p> <ul> <li>Required fields are present</li> <li>Field types match (string, number, boolean, array, object)</li> <li>Nested objects validated recursively</li> </ul>"},{"location":"validators/#sumvalidator","title":"SumValidator","text":"<p>Verifies line items sum to stated total.</p> <pre><code>from strutex import SumValidator\n\nvalidator = SumValidator(\n    items_field=\"line_items\",\n    amount_field=\"price\",\n    total_field=\"grand_total\",\n    tolerance=0.01\n)\n\nresult = validator.validate({\n    \"line_items\": [{\"price\": 10.00}, {\"price\": 20.00}],\n    \"grand_total\": 30.00\n})\n# result.valid == True\n</code></pre>"},{"location":"validators/#datevalidator","title":"DateValidator","text":"<p>Validates date formats and ranges.</p> <pre><code>from strutex import DateValidator\n\nvalidator = DateValidator(\n    date_fields=[\"invoice_date\", \"due_date\"],\n    min_year=2020,\n    max_year=2030\n)\n\nresult = validator.validate({\n    \"invoice_date\": \"2024-01-15\",\n    \"due_date\": \"2024-02-15\"\n})\n</code></pre> <p>Accepted formats: ISO, European (DD.MM.YYYY), US (MM/DD/YYYY)</p>"},{"location":"validators/#validation-chains","title":"Validation Chains","text":"<p>Compose multiple validators:</p> <pre><code>from strutex import ValidationChain, SchemaValidator, SumValidator, DateValidator\n\nchain = ValidationChain([\n    SchemaValidator(strict=True),\n    SumValidator(tolerance=0.01),\n    DateValidator(),\n], strict=True)  # Stop on first failure\n\nresult = chain.validate(data, schema)\n\nprint(result.valid)   # True/False\nprint(result.issues)  # List of error messages\nprint(result.data)    # Possibly modified data\n</code></pre> <p>Modes:</p> <ul> <li><code>strict=True</code> \u2014 Stop on first failure</li> <li><code>strict=False</code> \u2014 Collect all issues</li> </ul>"},{"location":"validators/#creating-custom-validators","title":"Creating Custom Validators","text":"<pre><code>from strutex.plugins import Validator, ValidationResult\n\nclass EmailValidator(Validator, name=\"email\"):\n    priority = 50\n\n    def validate(self, data, schema=None):\n        issues = []\n        email = data.get(\"email\", \"\")\n\n        if email and \"@\" not in email:\n            issues.append(f\"Invalid email: {email}\")\n\n        return ValidationResult(\n            valid=len(issues) == 0,\n            data=data,\n            issues=issues\n        )\n</code></pre>"},{"location":"validators/#api-reference","title":"API Reference","text":"<p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p>"},{"location":"validators/#strutex.validators.SchemaValidator","title":"<code>SchemaValidator(strict: bool = False)</code>","text":"<p>               Bases: <code>Validator</code></p> <p>Validates that extracted data matches the expected schema structure.</p> <p>Checks: - Required fields are present - Field types match (string, number, boolean, array, object) - Nested objects are validated recursively</p> ATTRIBUTE DESCRIPTION <code>strict</code> <p>If True, fail on extra fields not in schema</p> <p> </p> <p>Initialize the schema validator.</p> PARAMETER DESCRIPTION <code>strict</code> <p>If True, reject data with fields not in schema</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>strutex/validators/schema.py</code> <pre><code>def __init__(self, strict: bool = False):\n    \"\"\"\n    Initialize the schema validator.\n\n    Args:\n        strict: If True, reject data with fields not in schema\n    \"\"\"\n    self.strict = strict\n</code></pre>"},{"location":"validators/#strutex.validators.SchemaValidator.validate","title":"<code>validate(data: Dict[str, Any], schema: Optional[Schema] = None) -&gt; ValidationResult</code>","text":"<p>Validate data against a schema.</p> PARAMETER DESCRIPTION <code>data</code> <p>The extracted data to validate</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>schema</code> <p>The expected schema structure</p> <p> TYPE: <code>Optional[Schema]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValidationResult</code> <p>ValidationResult with validation status and any issues</p> Source code in <code>strutex/validators/schema.py</code> <pre><code>def validate(self, data: Dict[str, Any], schema: Optional[Schema] = None) -&gt; ValidationResult:\n    \"\"\"\n    Validate data against a schema.\n\n    Args:\n        data: The extracted data to validate\n        schema: The expected schema structure\n\n    Returns:\n        ValidationResult with validation status and any issues\n    \"\"\"\n    if schema is None:\n        return ValidationResult(valid=True, data=data)\n\n    issues = []\n    self._validate_value(data, schema, \"\", issues)\n\n    return ValidationResult(\n        valid=len(issues) == 0,\n        data=data,\n        issues=issues\n    )\n</code></pre>"},{"location":"validators/#strutex.validators.SumValidator","title":"<code>SumValidator(items_field: str = 'items', amount_field: str = 'amount', total_field: str = 'total', tolerance: float = 0.01)</code>","text":"<p>               Bases: <code>Validator</code></p> <p>Validates that line item amounts sum to the stated total.</p> <p>Common use case: Invoice validation where item totals should  match the invoice total.</p> ATTRIBUTE DESCRIPTION <code>items_field</code> <p>Field name containing the list of items</p> <p> </p> <code>amount_field</code> <p>Field name in each item containing the amount</p> <p> </p> <code>total_field</code> <p>Field name containing the expected total</p> <p> </p> <code>tolerance</code> <p>Acceptable difference (for floating point comparison)</p> <p> </p> <p>Initialize the sum validator.</p> PARAMETER DESCRIPTION <code>items_field</code> <p>Name of the field containing line items</p> <p> TYPE: <code>str</code> DEFAULT: <code>'items'</code> </p> <code>amount_field</code> <p>Name of the amount field in each item</p> <p> TYPE: <code>str</code> DEFAULT: <code>'amount'</code> </p> <code>total_field</code> <p>Name of the total field</p> <p> TYPE: <code>str</code> DEFAULT: <code>'total'</code> </p> <code>tolerance</code> <p>Maximum acceptable difference</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.01</code> </p> Source code in <code>strutex/validators/sum.py</code> <pre><code>def __init__(\n    self,\n    items_field: str = \"items\",\n    amount_field: str = \"amount\",\n    total_field: str = \"total\",\n    tolerance: float = 0.01\n):\n    \"\"\"\n    Initialize the sum validator.\n\n    Args:\n        items_field: Name of the field containing line items\n        amount_field: Name of the amount field in each item\n        total_field: Name of the total field\n        tolerance: Maximum acceptable difference\n    \"\"\"\n    self.items_field = items_field\n    self.amount_field = amount_field\n    self.total_field = total_field\n    self.tolerance = tolerance\n</code></pre>"},{"location":"validators/#strutex.validators.SumValidator.validate","title":"<code>validate(data: Dict[str, Any], schema=None) -&gt; ValidationResult</code>","text":"<p>Validate that line items sum to the total.</p> PARAMETER DESCRIPTION <code>data</code> <p>The extracted data to validate</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>schema</code> <p>Not used by this validator</p> <p> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValidationResult</code> <p>ValidationResult indicating if sums match</p> Source code in <code>strutex/validators/sum.py</code> <pre><code>def validate(self, data: Dict[str, Any], schema=None) -&gt; ValidationResult:\n    \"\"\"\n    Validate that line items sum to the total.\n\n    Args:\n        data: The extracted data to validate\n        schema: Not used by this validator\n\n    Returns:\n        ValidationResult indicating if sums match\n    \"\"\"\n    issues = []\n\n    # Get items and total\n    items = data.get(self.items_field, [])\n    total = data.get(self.total_field)\n\n    # Skip if required fields are missing\n    if not items or total is None:\n        return ValidationResult(valid=True, data=data)\n\n    # Calculate sum of items\n    try:\n        items_sum = sum(\n            float(item.get(self.amount_field, 0)) \n            for item in items \n            if isinstance(item, dict)\n        )\n    except (TypeError, ValueError) as e:\n        issues.append(f\"Could not calculate sum: {e}\")\n        return ValidationResult(valid=False, data=data, issues=issues)\n\n    # Compare with tolerance\n    try:\n        total_float = float(total)\n    except (TypeError, ValueError):\n        issues.append(f\"Total field is not a number: {total}\")\n        return ValidationResult(valid=False, data=data, issues=issues)\n\n    difference = abs(items_sum - total_float)\n\n    if difference &gt; self.tolerance:\n        issues.append(\n            f\"Sum mismatch: items sum to {items_sum:.2f}, \"\n            f\"but total is {total_float:.2f} \"\n            f\"(difference: {difference:.2f})\"\n        )\n        return ValidationResult(valid=False, data=data, issues=issues)\n\n    return ValidationResult(valid=True, data=data)\n</code></pre>"},{"location":"validators/#strutex.validators.DateValidator","title":"<code>DateValidator(date_fields: Optional[List[str]] = None, formats: Optional[List[str]] = None, min_year: int = 1900, max_year: int = 2100)</code>","text":"<p>               Bases: <code>Validator</code></p> <p>Validates date fields for format and range.</p> <p>Checks: - Date strings match expected formats - Dates are within acceptable range - Optional normalization to ISO format</p> ATTRIBUTE DESCRIPTION <code>date_fields</code> <p>List of field names to validate</p> <p> </p> <code>formats</code> <p>Accepted date formats (strptime patterns)</p> <p> </p> <code>min_date</code> <p>Minimum acceptable date</p> <p> </p> <code>max_date</code> <p>Maximum acceptable date</p> <p> </p> <p>Initialize the date validator.</p> PARAMETER DESCRIPTION <code>date_fields</code> <p>Field names to validate (None = auto-detect)</p> <p> TYPE: <code>Optional[List[str]]</code> DEFAULT: <code>None</code> </p> <code>formats</code> <p>Accepted date formats</p> <p> TYPE: <code>Optional[List[str]]</code> DEFAULT: <code>None</code> </p> <code>min_year</code> <p>Minimum acceptable year</p> <p> TYPE: <code>int</code> DEFAULT: <code>1900</code> </p> <code>max_year</code> <p>Maximum acceptable year</p> <p> TYPE: <code>int</code> DEFAULT: <code>2100</code> </p> Source code in <code>strutex/validators/date.py</code> <pre><code>def __init__(\n    self,\n    date_fields: Optional[List[str]] = None,\n    formats: Optional[List[str]] = None,\n    min_year: int = 1900,\n    max_year: int = 2100,\n):\n    \"\"\"\n    Initialize the date validator.\n\n    Args:\n        date_fields: Field names to validate (None = auto-detect)\n        formats: Accepted date formats\n        min_year: Minimum acceptable year\n        max_year: Maximum acceptable year\n    \"\"\"\n    self.date_fields = date_fields\n    self.formats = formats or self.DEFAULT_FORMATS\n    self.min_year = min_year\n    self.max_year = max_year\n</code></pre>"},{"location":"validators/#strutex.validators.DateValidator.validate","title":"<code>validate(data: Dict[str, Any], schema=None) -&gt; ValidationResult</code>","text":"<p>Validate date fields in the data.</p> PARAMETER DESCRIPTION <code>data</code> <p>The extracted data to validate</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>schema</code> <p>Not used by this validator</p> <p> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValidationResult</code> <p>ValidationResult with validation status</p> Source code in <code>strutex/validators/date.py</code> <pre><code>def validate(self, data: Dict[str, Any], schema=None) -&gt; ValidationResult:\n    \"\"\"\n    Validate date fields in the data.\n\n    Args:\n        data: The extracted data to validate\n        schema: Not used by this validator\n\n    Returns:\n        ValidationResult with validation status\n    \"\"\"\n    issues = []\n\n    # Determine which fields to check\n    if self.date_fields:\n        fields_to_check = self.date_fields\n    else:\n        # Auto-detect: look for fields with \"date\" in the name\n        fields_to_check = [\n            k for k in data.keys() \n            if \"date\" in k.lower()\n        ]\n\n    for field in fields_to_check:\n        value = data.get(field)\n        if value is None or value == \"\":\n            continue\n\n        if not isinstance(value, str):\n            continue\n\n        # Try to parse the date\n        parsed_date = None\n        for fmt in self.formats:\n            try:\n                parsed_date = datetime.strptime(value, fmt)\n                break\n            except ValueError:\n                continue\n\n        if parsed_date is None:\n            issues.append(f\"{field}: invalid date format '{value}'\")\n            continue\n\n        # Check year range\n        if parsed_date.year &lt; self.min_year:\n            issues.append(f\"{field}: year {parsed_date.year} is before {self.min_year}\")\n        elif parsed_date.year &gt; self.max_year:\n            issues.append(f\"{field}: year {parsed_date.year} is after {self.max_year}\")\n\n    return ValidationResult(\n        valid=len(issues) == 0,\n        data=data,\n        issues=issues\n    )\n</code></pre>"},{"location":"validators/#strutex.validators.ValidationChain","title":"<code>ValidationChain(validators: List[Validator], strict: bool = True)</code>","text":"<p>Composes multiple validators into a sequential chain.</p> <p>Validators run in order. If any validator fails (in strict mode), the chain stops and returns the failure. In lenient mode, all validators run and issues are collected.</p> Example <pre><code>chain = ValidationChain([\n    SchemaValidator(),\n    SumValidator(tolerance=0.01),\n    DateValidator(date_fields=[\"invoice_date\"]),\n])\n\nresult = chain.validate(data, schema)\nif not result.valid:\n    print(result.issues)\n</code></pre> <p>Initialize the validation chain.</p> PARAMETER DESCRIPTION <code>validators</code> <p>List of validators to run in order</p> <p> TYPE: <code>List[Validator]</code> </p> <code>strict</code> <p>If True, stop on first failure. If False, collect all issues.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>strutex/validators/chain.py</code> <pre><code>def __init__(\n    self,\n    validators: List[Validator],\n    strict: bool = True\n):\n    \"\"\"\n    Initialize the validation chain.\n\n    Args:\n        validators: List of validators to run in order\n        strict: If True, stop on first failure. If False, collect all issues.\n    \"\"\"\n    self.validators = validators\n    self.strict = strict\n</code></pre>"},{"location":"validators/#strutex.validators.ValidationChain.add","title":"<code>add(validator: Validator) -&gt; ValidationChain</code>","text":"<p>Add a validator to the chain.</p> PARAMETER DESCRIPTION <code>validator</code> <p>The validator to add</p> <p> TYPE: <code>Validator</code> </p> RETURNS DESCRIPTION <code>ValidationChain</code> <p>Self for method chaining</p> Source code in <code>strutex/validators/chain.py</code> <pre><code>def add(self, validator: Validator) -&gt; \"ValidationChain\":\n    \"\"\"\n    Add a validator to the chain.\n\n    Args:\n        validator: The validator to add\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    self.validators.append(validator)\n    return self\n</code></pre>"},{"location":"validators/#strutex.validators.ValidationChain.validate","title":"<code>validate(data: Dict[str, Any], schema=None) -&gt; ValidationResult</code>","text":"<p>Run all validators in the chain.</p> PARAMETER DESCRIPTION <code>data</code> <p>The data to validate</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>schema</code> <p>Optional schema to pass to validators</p> <p> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValidationResult</code> <p>Combined ValidationResult from all validators</p> Source code in <code>strutex/validators/chain.py</code> <pre><code>def validate(\n    self,\n    data: Dict[str, Any],\n    schema=None\n) -&gt; ValidationResult:\n    \"\"\"\n    Run all validators in the chain.\n\n    Args:\n        data: The data to validate\n        schema: Optional schema to pass to validators\n\n    Returns:\n        Combined ValidationResult from all validators\n    \"\"\"\n    all_issues: List[str] = []\n    current_data = data\n\n    for validator in self.validators:\n        result = validator.validate(current_data, schema)\n\n        if not result.valid:\n            all_issues.extend(result.issues)\n\n            if self.strict:\n                return ValidationResult(\n                    valid=False,\n                    data=current_data,\n                    issues=all_issues\n                )\n\n        # Use possibly modified data for next validator\n        current_data = result.data\n\n    return ValidationResult(\n        valid=len(all_issues) == 0,\n        data=current_data,\n        issues=all_issues\n    )\n</code></pre>"},{"location":"verification/","title":"Verification &amp; Self-Correction","text":"<p>Strutex v0.8.0 introduces Verification, a powerful mechanism to improve extraction accuracy by using the LLM to audit and correct its own work.</p>"},{"location":"verification/#overview","title":"Overview","text":"<p>Extraction errors can happen, especially with complex documents. The Verification feature runs a two-step workflow:</p> <ol> <li>Extraction: The document is processed normally to generate structured JSON.</li> <li>Audit: The result from step 1 is fed back to the LLM (or a different model) along with the original document. The model acts as a \"strict auditor\" to check for discrepancies and fix them.</li> </ol> <p>This \"Reflexion\" pattern significantly reduces hallucinations and missing fields.</p>"},{"location":"verification/#usage","title":"Usage","text":""},{"location":"verification/#automatic-verification","title":"Automatic Verification","text":"<p>The simplest way to use verification is to pass <code>verify=True</code> to the <code>process</code> (or <code>aprocess</code>) method.</p> <pre><code>from strutex import DocumentProcessor\nfrom strutex.schemas import INVOICE_US\n\nprocessor = DocumentProcessor()\n\nresult = processor.process(\n    file_path=\"invoice.pdf\",\n    prompt=\"Extract invoice data\",\n    schema=INVOICE_US,\n    verify=True  # \ud83d\udc48 Enables self-correction loop\n)\n</code></pre>"},{"location":"verification/#manual-verification","title":"Manual Verification","text":"<p>You can also run verification on a result you already have (e.g., from a previous run or a different system).</p> <pre><code>previous_result = {\n    \"invoice_number\": \"INV-001\",\n    \"total\": 500.00  # Suspicious value\n}\n\nverified_result = processor.verify(\n    file_path=\"invoice.pdf\",\n    result=previous_result,\n    schema=INVOICE_US\n)\n</code></pre>"},{"location":"verification/#async-support","title":"Async Support","text":"<p>Verification is fully supported in async workflows:</p> <pre><code>result = await processor.aprocess(\n    ...,\n    verify=True\n)\n\n# Or manually:\nresult = await processor.averify(...)\n</code></pre>"},{"location":"verification/#configuration","title":"Configuration","text":""},{"location":"verification/#custom-verification-prompt","title":"Custom Verification Prompt","text":"<p>By default, Strutex uses a generic \"strict auditor\" system prompt. You can customize this to look for specific errors.</p> <pre><code>result = processor.process(\n    ...,\n    verify=True,\n    verify_prompt=\"Check strictly that the 'total' matches the sum of line items.\"\n)\n</code></pre>"},{"location":"verification/#performance-cost","title":"Performance &amp; Cost","text":"<p>Enabling verification doubles the number of LLM calls (1 extraction + 1 verification). This increases:</p> <ul> <li>Latency: Expect roughly 2x processing time.</li> <li>Cost: Expect roughly 2x token usage.</li> </ul> <p>Usage Tracking</p> <p>With <code>verify=True</code>, usage statistics (tokens/cost) in the returned result only reflect the verification pass. If you need total cost tracking, ensure you are logging usage from your quota manager or provider dashboard.</p>"},{"location":"verification/#best-practices","title":"Best Practices","text":"<ul> <li>Use <code>verify=True</code> for critical data fields where accuracy is paramount (e.g. financial totals).</li> <li>For high-volume low-value documents, you might skip verification to save costs.</li> <li>Consider using a faster/cheaper model for extraction and a stronger model for verification (currently requires manual 2-step calls).</li> </ul>"}]}