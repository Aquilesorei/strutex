{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Strutex","text":"<p>Python AI PDF Utilities \u2014 Extract structured JSON from documents using LLMs.</p>"},{"location":"#features","title":"Features","text":"<ul> <li> Quick Setup</li> </ul> <p>Install with pip and extract data from PDFs in minutes.</p> <p> Getting Started</p> <ul> <li> Fully Pluggable</li> </ul> <p>Every component is a plugin. Swap providers, add validators.</p> <p> Plugin System</p> <ul> <li> Security Layer</li> </ul> <p>Protect against prompt injection with built-in sanitizers.</p> <p> Security</p> <ul> <li> Pydantic Support</li> </ul> <p>Use Pydantic models for type-safe extractions.</p> <p> Pydantic</p>"},{"location":"#quick-example","title":"Quick Example","text":"With SchemaWith Pydantic <pre><code>from strutex import DocumentProcessor, Object, String, Number\n\nschema = Object(properties={\n    \"invoice_number\": String(description=\"Invoice ID\"),\n    \"total\": Number(description=\"Total amount\")\n})\n\nprocessor = DocumentProcessor(provider=\"gemini\")\nresult = processor.process(\"invoice.pdf\", \"Extract invoice data\", schema)\n\nprint(result[\"invoice_number\"])  # \"INV-2024-001\"\n</code></pre> <pre><code>from pydantic import BaseModel\nfrom strutex import DocumentProcessor\n\nclass Invoice(BaseModel):\n    invoice_number: str\n    total: float\n\nprocessor = DocumentProcessor(provider=\"gemini\")\nresult = processor.process(\"invoice.pdf\", \"Extract data\", model=Invoice)\n\n# result is a validated Invoice instance!\nprint(result.invoice_number)\n</code></pre>"},{"location":"#architecture","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     DocumentProcessor                        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502 Security \u2502\u2192 \u2502 Extractor\u2502\u2192 \u2502 Provider \u2502\u2192 \u2502Validator \u2502    \u2502\n\u2502  \u2502  Chain   \u2502  \u2502  Plugin  \u2502  \u2502  Plugin  \u2502  \u2502  Plugin  \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2502         \u2193            \u2193            \u2193            \u2193            \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u2502\n\u2502  \u2502              Plugin Registry                        \u2502    \u2502\n\u2502  \u2502   @register(\"provider\") / @register(\"validator\")  \u2502    \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"Feature Description Plugin System Register custom providers, validators, postprocessors Security Layer Input sanitization, prompt injection detection Pydantic Support Type-safe extractions with automatic validation Structured Prompts Build organized prompts with the fluent API Multi-Provider Gemini, OpenAI, Anthropic (extensible)"},{"location":"api-reference/","title":"API Reference","text":"<p>Complete reference for all public APIs.</p>"},{"location":"api-reference/#documentprocessor","title":"DocumentProcessor","text":"<p>options: show_root_heading: true members: - init - process</p>"},{"location":"api-reference/#strutex.processor.DocumentProcessor","title":"<code>DocumentProcessor(provider: Union[str, Provider] = 'gemini', model_name: str = 'gemini-2.5-flash', api_key: Optional[str] = None, security: Optional[SecurityPlugin] = None, on_pre_process: Optional[PreProcessCallback] = None, on_post_process: Optional[PostProcessCallback] = None, on_error: Optional[ErrorCallback] = None)</code>","text":"<p>Main document processing class for extracting structured data from documents.</p> <p>The <code>DocumentProcessor</code> orchestrates document extraction using pluggable providers, with optional security layer and Pydantic model support. It automatically detects file types, applies security checks, and validates output against schemas.</p> ATTRIBUTE DESCRIPTION <code>security</code> <p>Optional security plugin/chain for input/output validation.</p> <p> </p> Example <p>Basic usage with schema:</p> <pre><code>from strutex import DocumentProcessor, Object, String, Number\n\nschema = Object(properties={\n    \"invoice_number\": String(),\n    \"total\": Number()\n})\n\nprocessor = DocumentProcessor(provider=\"gemini\")\nresult = processor.process(\"invoice.pdf\", \"Extract data\", schema)\nprint(result[\"invoice_number\"])\n</code></pre> <p>With callbacks:</p> <pre><code>processor = DocumentProcessor(\n    provider=\"gemini\",\n    on_post_process=lambda result, ctx: {**result, \"processed\": True}\n)\n</code></pre> <p>With decorator:</p> <pre><code>processor = DocumentProcessor()\n\n@processor.on_post_process\ndef add_timestamp(result, context):\n    result[\"timestamp\"] = datetime.now().isoformat()\n    return result\n</code></pre> <p>Initialize the document processor.</p> PARAMETER DESCRIPTION <code>provider</code> <p>Provider name (e.g., \"gemini\", \"openai\") or a <code>Provider</code> instance.</p> <p> TYPE: <code>Union[str, Provider]</code> DEFAULT: <code>'gemini'</code> </p> <code>model_name</code> <p>LLM model name to use (only when provider is a string).</p> <p> TYPE: <code>str</code> DEFAULT: <code>'gemini-2.5-flash'</code> </p> <code>api_key</code> <p>API key for the provider. Falls back to environment variables (e.g., <code>GOOGLE_API_KEY</code> for Gemini).</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>security</code> <p>Optional <code>SecurityPlugin</code> or <code>SecurityChain</code> for input/output validation. Security is opt-in.</p> <p> TYPE: <code>Optional[SecurityPlugin]</code> DEFAULT: <code>None</code> </p> <code>on_pre_process</code> <p>Callback called before processing. Receives (file_path, prompt, schema, mime_type, context) and can return a dict with modified values.</p> <p> TYPE: <code>Optional[PreProcessCallback]</code> DEFAULT: <code>None</code> </p> <code>on_post_process</code> <p>Callback called after processing. Receives (result, context) and can return a modified result dict.</p> <p> TYPE: <code>Optional[PostProcessCallback]</code> DEFAULT: <code>None</code> </p> <code>on_error</code> <p>Callback called on error. Receives (error, file_path, context) and can return a fallback result or None to propagate the error.</p> <p> TYPE: <code>Optional[ErrorCallback]</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>If the specified provider is not found in the registry.</p> Example <pre><code># Using callbacks\nprocessor = DocumentProcessor(\n    provider=\"gemini\",\n    on_post_process=lambda result, ctx: normalize_dates(result)\n)\n</code></pre> Source code in <code>strutex/processor.py</code> <pre><code>def __init__(\n    self,\n    provider: Union[str, Provider] = \"gemini\",\n    model_name: str = \"gemini-2.5-flash\",\n    api_key: Optional[str] = None,\n    security: Optional[SecurityPlugin] = None,\n    on_pre_process: Optional[PreProcessCallback] = None,\n    on_post_process: Optional[PostProcessCallback] = None,\n    on_error: Optional[ErrorCallback] = None,\n):\n    \"\"\"\n    Initialize the document processor.\n\n    Args:\n        provider: Provider name (e.g., \"gemini\", \"openai\") or a\n            [`Provider`][strutex.plugins.base.Provider] instance.\n        model_name: LLM model name to use (only when provider is a string).\n        api_key: API key for the provider. Falls back to environment variables\n            (e.g., `GOOGLE_API_KEY` for Gemini).\n        security: Optional [`SecurityPlugin`][strutex.plugins.base.SecurityPlugin]\n            or [`SecurityChain`][strutex.security.chain.SecurityChain] for\n            input/output validation. Security is opt-in.\n        on_pre_process: Callback called before processing. Receives\n            (file_path, prompt, schema, mime_type, context) and can return\n            a dict with modified values.\n        on_post_process: Callback called after processing. Receives\n            (result, context) and can return a modified result dict.\n        on_error: Callback called on error. Receives (error, file_path, context)\n            and can return a fallback result or None to propagate the error.\n\n    Raises:\n        ValueError: If the specified provider is not found in the registry.\n\n    Example:\n        ```python\n        # Using callbacks\n        processor = DocumentProcessor(\n            provider=\"gemini\",\n            on_post_process=lambda result, ctx: normalize_dates(result)\n        )\n        ```\n    \"\"\"\n    self.security = security\n\n    # Hook storage: callbacks first, then decorated hooks\n    self._pre_process_hooks: List[PreProcessCallback] = []\n    self._post_process_hooks: List[PostProcessCallback] = []\n    self._error_hooks: List[ErrorCallback] = []\n\n    # Pluggy integration\n    self._hook_plugin: Optional[_CallbackHookPlugin] = None\n    self._hook_plugin_registered = False\n\n    # Add initial callbacks if provided\n    if on_pre_process:\n        self._pre_process_hooks.append(on_pre_process)\n    if on_post_process:\n        self._post_process_hooks.append(on_post_process)\n    if on_error:\n        self._error_hooks.append(on_error)\n\n    # Resolve provider\n    if isinstance(provider, str):\n        self.provider_name = provider.lower()\n\n        # Try to get from registry\n        provider_cls = PluginRegistry.get(\"provider\", self.provider_name)\n\n        if provider_cls:\n            self._provider = provider_cls(api_key=api_key, model=model_name)\n        else:\n            # Fallback for backward compatibility\n            if self.provider_name in (\"google\", \"gemini\"):\n                from .providers.gemini import GeminiProvider\n                self._provider = GeminiProvider(api_key=api_key, model=model_name)\n            else:\n                raise ValueError(f\"Unknown provider: {provider}. Available: {list(PluginRegistry.list('provider').keys())}\")\n    else:\n        # Provider instance passed directly\n        self._provider = provider\n        # Try to get name from provider instance\n        self.provider_name = getattr(provider, 'name', type(provider).__name__)\n</code></pre>"},{"location":"api-reference/#strutex.processor.DocumentProcessor.__del__","title":"<code>__del__()</code>","text":"<p>Unregister hooks when processor is garbage collected.</p> Source code in <code>strutex/processor.py</code> <pre><code>def __del__(self):\n    \"\"\"Unregister hooks when processor is garbage collected.\"\"\"\n    if self._hook_plugin_registered and self._hook_plugin:\n        try:\n            from .plugins.hooks import get_plugin_manager\n            pm = get_plugin_manager()\n            if pm:\n                pm.unregister(self._hook_plugin)\n        except Exception:\n            pass  # Ignore errors during cleanup\n</code></pre>"},{"location":"api-reference/#strutex.processor.DocumentProcessor.aprocess","title":"<code>aprocess(file_path: str, prompt: str, schema: Optional[Schema] = None, model: Optional[Type] = None, security: Optional[Union[SecurityPlugin, bool]] = None, verify: bool = False, **kwargs) -&gt; Any</code>  <code>async</code>","text":"<p>Async version of <code>process</code>.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>Absolute path to the source file</p> <p> TYPE: <code>str</code> </p> <code>prompt</code> <p>Extraction instruction</p> <p> TYPE: <code>str</code> </p> <code>schema</code> <p>Schema definition</p> <p> TYPE: <code>Optional[Schema]</code> DEFAULT: <code>None</code> </p> <code>model</code> <p>Pydantic model</p> <p> TYPE: <code>Optional[Type]</code> DEFAULT: <code>None</code> </p> <code>security</code> <p>Security configuration</p> <p> TYPE: <code>Optional[Union[SecurityPlugin, bool]]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Provider options</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>Extracted data or Pydantic instance</p> Source code in <code>strutex/processor.py</code> <pre><code>async def aprocess(\n    self,\n    file_path: str,\n    prompt: str,\n    schema: Optional[Schema] = None,\n    model: Optional[Type] = None,\n    security: Optional[Union[SecurityPlugin, bool]] = None,\n    verify: bool = False,\n    **kwargs\n) -&gt; Any:\n    \"\"\"\n    Async version of `process`.\n\n    Args:\n        file_path: Absolute path to the source file\n        prompt: Extraction instruction\n        schema: Schema definition\n        model: Pydantic model\n        security: Security configuration\n        **kwargs: Provider options\n\n    Returns:\n        Extracted data or Pydantic instance\n    \"\"\"\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"File not found: {file_path}\")\n\n    # Hooks currently run synchronously - in future we may add async hooks\n    self._ensure_hooks_registered()\n\n    # Handle Pydantic model\n    pydantic_model = None\n    if model is not None:\n        from .pydantic_support import pydantic_to_schema\n        schema = pydantic_to_schema(model)\n        pydantic_model = model\n\n    if schema is None:\n        raise ValueError(\"Either 'schema' or 'model' must be provided\")\n\n    mime_type = get_mime_type(file_path)\n\n    mime_type = get_mime_type(file_path)\n\n    # Create context for hooks\n    context: Dict[str, Any] = {\n        \"file_path\": file_path,\n        \"mime_type\": mime_type,\n        \"kwargs\": kwargs,\n    }\n\n    # Run pre-process hooks (sync)\n    from .plugins.hooks import call_hook\n    pre_results = call_hook(\n        \"pre_process\",\n        file_path=file_path,\n        prompt=prompt,\n        schema=schema,\n        mime_type=mime_type,\n        context=context\n    )\n    for hook_result in pre_results:\n        if hook_result and isinstance(hook_result, dict) and \"prompt\" in hook_result:\n            prompt = hook_result[\"prompt\"]\n\n    # Security\n    effective_security = self._resolve_security(security)\n    if effective_security:\n        input_result = effective_security.validate_input(prompt)\n        if not input_result.valid:\n            raise SecurityError(f\"Input rejected: {input_result.reason}\")\n        prompt = input_result.text or prompt\n\n    # Async Processing\n    try:\n        result = await self._provider.aprocess(\n            file_path=file_path,\n            prompt=prompt,\n            schema=schema,\n            mime_type=mime_type,\n            **kwargs\n        )\n    except Exception as e:\n        # Run error hooks (sync)\n        error_results = call_hook(\n            \"on_error\",\n            error=e,\n            file_path=file_path,\n            context=context\n        )\n        fallback = None\n        for hook_result in error_results:\n            if hook_result is not None:\n                fallback = hook_result\n                break\n\n        if fallback is not None:\n            result = fallback\n        else:\n            raise\n\n    # Security output\n    if effective_security and isinstance(result, dict):\n        output_result = effective_security.validate_output(result)\n        if not output_result.valid:\n            raise SecurityError(f\"Output rejected: {output_result.reason}\")\n        result = output_result.data or result\n\n    # Post-process (sync)\n    if isinstance(result, dict):\n        post_results = call_hook(\n            \"post_process\",\n            result=result,\n            context=context\n        )\n        for hook_result in post_results:\n            if hook_result is not None and isinstance(hook_result, dict):\n                result = hook_result\n\n    # Validation\n    if pydantic_model is not None:\n        from .pydantic_support import validate_with_pydantic\n        result = validate_with_pydantic(result, pydantic_model)\n\n    if verify:\n        result = await self.averify(file_path, result, schema=schema, model=model, **kwargs)\n\n    return result\n</code></pre>"},{"location":"api-reference/#strutex.processor.DocumentProcessor.aprocess_batch","title":"<code>aprocess_batch(file_paths: List[str], prompt: str, schema: Optional[Schema] = None, model: Optional[Type] = None, max_concurrency: int = 4, **kwargs) -&gt; BatchContext</code>  <code>async</code>","text":"<p>Async process multiple documents in parallel.</p> PARAMETER DESCRIPTION <code>file_paths</code> <p>List of file paths</p> <p> TYPE: <code>List[str]</code> </p> <code>prompt</code> <p>Extraction prompt</p> <p> TYPE: <code>str</code> </p> <code>schema</code> <p>Output schema</p> <p> TYPE: <code>Optional[Schema]</code> DEFAULT: <code>None</code> </p> <code>model</code> <p>Pydantic model</p> <p> TYPE: <code>Optional[Type]</code> DEFAULT: <code>None</code> </p> <code>max_concurrency</code> <p>Max concurrent async tasks</p> <p> TYPE: <code>int</code> DEFAULT: <code>4</code> </p> <code>**kwargs</code> <p>Provider options</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>BatchContext</code> <p>BatchContext containing results and stats</p> Source code in <code>strutex/processor.py</code> <pre><code>async def aprocess_batch(\n    self,\n    file_paths: List[str],\n    prompt: str,\n    schema: Optional[Schema] = None,\n    model: Optional[Type] = None,\n    max_concurrency: int = 4,\n    **kwargs\n) -&gt; BatchContext:\n    \"\"\"\n    Async process multiple documents in parallel.\n\n    Args:\n        file_paths: List of file paths\n        prompt: Extraction prompt\n        schema: Output schema\n        model: Pydantic model\n        max_concurrency: Max concurrent async tasks\n        **kwargs: Provider options\n\n    Returns:\n        BatchContext containing results and stats\n    \"\"\"\n    import asyncio\n    from .context import BatchContext\n\n    batch_ctx = BatchContext(total_documents=len(file_paths))\n    semaphore = asyncio.Semaphore(max_concurrency)\n\n    async def _aprocess_one(path: str):\n        async with semaphore:\n            try:\n                result = await self.aprocess(path, prompt, schema, model, **kwargs)\n                batch_ctx.add_result(path, result)\n            except Exception as e:\n                batch_ctx.add_error(path, e)\n\n    tasks = [_aprocess_one(path) for path in file_paths]\n    await asyncio.gather(*tasks)\n\n    return batch_ctx\n</code></pre>"},{"location":"api-reference/#strutex.processor.DocumentProcessor.averify","title":"<code>averify(file_path: str, result: Any, schema: Optional[Schema] = None, model: Optional[Type] = None, verify_prompt: Optional[str] = None, **kwargs) -&gt; Any</code>  <code>async</code>","text":"<p>Async version of verify.</p> Source code in <code>strutex/processor.py</code> <pre><code>async def averify(\n    self,\n    file_path: str,\n    result: Any,\n    schema: Optional[Schema] = None,\n    model: Optional[Type] = None,\n    verify_prompt: Optional[str] = None,\n    **kwargs\n) -&gt; Any:\n    \"\"\"Async version of verify.\"\"\"\n    import json\n\n    if verify_prompt is None:\n        verify_prompt = (\n            \"You are a strict data auditor. Your task is to verify the extracted data \"\n            \"against the document provided. \\n\"\n            \"Review the data below. If it contains errors or missing fields that exist \"\n            \"in the document, CORRECT them. If the data is correct, return it as is.\\n\"\n            \"Return the final validated JSON strictly adhering to the schema.\"\n        )\n\n    if hasattr(result, \"model_dump_json\"):\n        result_str = result.model_dump_json()\n    elif isinstance(result, dict):\n        result_str = json.dumps(result, default=str)\n    else:\n        result_str = str(result)\n\n    full_prompt = f\"{verify_prompt}\\n\\n[EXTRACTED DATA TO VERIFY]:\\n{result_str}\"\n\n    return await self.aprocess(\n        file_path=file_path,\n        prompt=full_prompt,\n        schema=schema,\n        model=model,\n        verify=False,\n        **kwargs\n    )\n</code></pre>"},{"location":"api-reference/#strutex.processor.DocumentProcessor.on_error","title":"<code>on_error(func: ErrorCallback) -&gt; ErrorCallback</code>","text":"<p>Decorator to register an error hook.</p> <p>The hook receives (error, file_path, context) and can return a fallback result dict. Return None to propagate the original error.</p> Example <pre><code>@processor.on_error\ndef handle_rate_limit(error, file_path, context):\n    if \"rate limit\" in str(error).lower():\n        return {\"error\": \"Rate limited, please retry\"}\n    return None  # Propagate other errors\n</code></pre> Source code in <code>strutex/processor.py</code> <pre><code>def on_error(self, func: ErrorCallback) -&gt; ErrorCallback:\n    \"\"\"\n    Decorator to register an error hook.\n\n    The hook receives (error, file_path, context) and can return a fallback\n    result dict. Return None to propagate the original error.\n\n    Example:\n        ```python\n        @processor.on_error\n        def handle_rate_limit(error, file_path, context):\n            if \"rate limit\" in str(error).lower():\n                return {\"error\": \"Rate limited, please retry\"}\n            return None  # Propagate other errors\n        ```\n    \"\"\"\n    self._error_hooks.append(func)\n    self._hook_plugin_registered = False  # Force re-registration\n    return func\n</code></pre>"},{"location":"api-reference/#strutex.processor.DocumentProcessor.on_post_process","title":"<code>on_post_process(func: PostProcessCallback) -&gt; PostProcessCallback</code>","text":"<p>Decorator to register a post-process hook.</p> <p>The hook receives (result, context) and can return a modified result dict.</p> Example <pre><code>@processor.on_post_process\ndef normalize_dates(result, context):\n    result[\"date\"] = parse_date(result.get(\"date\"))\n    return result\n</code></pre> Source code in <code>strutex/processor.py</code> <pre><code>def on_post_process(self, func: PostProcessCallback) -&gt; PostProcessCallback:\n    \"\"\"\n    Decorator to register a post-process hook.\n\n    The hook receives (result, context) and can return a modified result dict.\n\n    Example:\n        ```python\n        @processor.on_post_process\n        def normalize_dates(result, context):\n            result[\"date\"] = parse_date(result.get(\"date\"))\n            return result\n        ```\n    \"\"\"\n    self._post_process_hooks.append(func)\n    self._hook_plugin_registered = False  # Force re-registration\n    return func\n</code></pre>"},{"location":"api-reference/#strutex.processor.DocumentProcessor.on_pre_process","title":"<code>on_pre_process(func: PreProcessCallback) -&gt; PreProcessCallback</code>","text":"<p>Decorator to register a pre-process hook.</p> <p>The hook receives (file_path, prompt, schema, mime_type, context) and can return a dict with modified values for 'prompt' or other parameters.</p> Example <pre><code>@processor.on_pre_process\ndef add_instructions(file_path, prompt, schema, mime_type, context):\n    return {\"prompt\": prompt + \"\\nBe precise.\"}\n</code></pre> Source code in <code>strutex/processor.py</code> <pre><code>def on_pre_process(self, func: PreProcessCallback) -&gt; PreProcessCallback:\n    \"\"\"\n    Decorator to register a pre-process hook.\n\n    The hook receives (file_path, prompt, schema, mime_type, context) and\n    can return a dict with modified values for 'prompt' or other parameters.\n\n    Example:\n        ```python\n        @processor.on_pre_process\n        def add_instructions(file_path, prompt, schema, mime_type, context):\n            return {\"prompt\": prompt + \"\\\\nBe precise.\"}\n        ```\n    \"\"\"\n    self._pre_process_hooks.append(func)\n    self._hook_plugin_registered = False  # Force re-registration\n    return func\n</code></pre>"},{"location":"api-reference/#strutex.processor.DocumentProcessor.process","title":"<code>process(file_path: str, prompt: str, schema: Optional[Schema] = None, model: Optional[Type] = None, security: Optional[Union[SecurityPlugin, bool]] = None, verify: bool = False, **kwargs) -&gt; Any</code>","text":"<p>Process a document and extract structured data.</p> <p>This method automatically detects the file type, applies security validation (if enabled), sends the document to the LLM provider, and validates the output.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>Absolute path to the source file (PDF, Excel, or Image).</p> <p> TYPE: <code>str</code> </p> <code>prompt</code> <p>Natural language instruction for extraction.</p> <p> TYPE: <code>str</code> </p> <code>schema</code> <p>A [<code>Schema</code>][strutex.Schema] definition. Mutually exclusive with <code>model</code>.</p> <p> TYPE: <code>Optional[Schema]</code> DEFAULT: <code>None</code> </p> <code>model</code> <p>A Pydantic <code>BaseModel</code> class. Mutually exclusive with <code>schema</code>. If provided, returns a validated Pydantic instance.</p> <p> TYPE: <code>Optional[Type]</code> DEFAULT: <code>None</code> </p> <code>security</code> <p>Override security setting for this request. - <code>True</code>: Use default security chain - <code>False</code>: Disable security - <code>SecurityPlugin</code>: Use custom security instance</p> <p> TYPE: <code>Optional[Union[SecurityPlugin, bool]]</code> DEFAULT: <code>None</code> </p> <code>verify</code> <p>If <code>True</code>, enables self-correction loop where the LLM audits its own result.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>**kwargs</code> <p>Additional arguments passed to the provider (e.g. <code>temperature</code>).</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>Extracted data as a dict (if <code>schema</code> used) or Pydantic model (if <code>model</code> used). - <code>SecurityPlugin</code>: Use specific plugin - <code>None</code>: Use processor default</p> <code>verify</code> <p>If True, performs a second pass to verify and correct the result.</p> <p> TYPE: <code>Any</code> </p> <code>context</code> <p>Optional ProcessingContext for state tracking.</p> <p> TYPE: <code>Any</code> </p> <code>Any</code> <p>**kwargs: Additional provider-specific options.</p> RETURNS DESCRIPTION <code>Any</code> <p>Extracted data as a dictionary, or a Pydantic model instance if <code>model</code></p> <code>Any</code> <p>was provided.</p> RAISES DESCRIPTION <code>FileNotFoundError</code> <p>If <code>file_path</code> does not exist.</p> <code>ValueError</code> <p>If neither <code>schema</code> nor <code>model</code> is provided.</p> <code>SecurityError</code> <p>If security validation fails (input or output rejected).</p> Example <pre><code>result = processor.process(\n    file_path=\"invoice.pdf\",\n    prompt=\"Extract invoice number and total amount\",\n    schema=invoice_schema\n)\nprint(result[\"total\"])\n</code></pre> Source code in <code>strutex/processor.py</code> <pre><code>def process(\n    self,\n    file_path: str,\n    prompt: str,\n    schema: Optional[Schema] = None,\n    model: Optional[Type] = None,\n    security: Optional[Union[SecurityPlugin, bool]] = None,\n    verify: bool = False,\n    **kwargs\n) -&gt; Any:\n    \"\"\"\n    Process a document and extract structured data.\n\n    This method automatically detects the file type, applies security validation\n    (if enabled), sends the document to the LLM provider, and validates the output.\n\n    Args:\n        file_path: Absolute path to the source file (PDF, Excel, or Image).\n        prompt: Natural language instruction for extraction.\n        schema: A [`Schema`][strutex.Schema] definition. Mutually exclusive\n            with `model`.\n        model: A Pydantic `BaseModel` class. Mutually exclusive with `schema`.\n            If provided, returns a validated Pydantic instance.\n        security: Override security setting for this request.\n            - `True`: Use default security chain\n            - `False`: Disable security\n            - `SecurityPlugin`: Use custom security instance\n        verify: If `True`, enables self-correction loop where the LLM audits its own\n            result.\n        **kwargs: Additional arguments passed to the provider (e.g. `temperature`).\n\n    Returns:\n        Extracted data as a dict (if `schema` used) or Pydantic model (if `model` used).\n            - `SecurityPlugin`: Use specific plugin\n            - `None`: Use processor default\n        verify: If True, performs a second pass to verify and correct the result.\n        context: Optional ProcessingContext for state tracking.\n        **kwargs: Additional provider-specific options.\n\n    Returns:\n        Extracted data as a dictionary, or a Pydantic model instance if `model`\n        was provided.\n\n    Raises:\n        FileNotFoundError: If `file_path` does not exist.\n        ValueError: If neither `schema` nor `model` is provided.\n        SecurityError: If security validation fails (input or output rejected).\n\n    Example:\n        ```python\n        result = processor.process(\n            file_path=\"invoice.pdf\",\n            prompt=\"Extract invoice number and total amount\",\n            schema=invoice_schema\n        )\n        print(result[\"total\"])\n        ```\n    \"\"\"\n    if not os.path.exists(file_path):\n        raise FileNotFoundError(f\"File not found: {file_path}\")\n\n    # Ensure hooks are registered with pluggy\n    self._ensure_hooks_registered()\n\n    # Handle Pydantic model\n    pydantic_model = None\n    if model is not None:\n        from .pydantic_support import pydantic_to_schema\n        schema = pydantic_to_schema(model)\n        pydantic_model = model\n\n    if schema is None:\n        raise ValueError(\"Either 'schema' or 'model' must be provided\")\n\n    # Detect MIME type\n    mime_type = get_mime_type(file_path)\n\n    # Create context for hooks\n    context: Dict[str, Any] = {\n        \"file_path\": file_path,\n        \"mime_type\": mime_type,\n        \"kwargs\": kwargs,\n    }\n\n    # Run pre-process hooks via pluggy\n    from .plugins.hooks import call_hook\n    pre_results = call_hook(\n        \"pre_process\",\n        file_path=file_path,\n        prompt=prompt,\n        schema=schema,\n        mime_type=mime_type,\n        context=context\n    )\n    # Apply any prompt modifications from hooks\n    for hook_result in pre_results:\n        if hook_result and isinstance(hook_result, dict) and \"prompt\" in hook_result:\n            prompt = hook_result[\"prompt\"]\n\n    # Handle security\n    effective_security = self._resolve_security(security)\n\n    # Apply input security if enabled\n    if effective_security:\n        input_result = effective_security.validate_input(prompt)\n        if not input_result.valid:\n            raise SecurityError(f\"Input rejected: {input_result.reason}\")\n        prompt = input_result.text or prompt\n\n    # Process with provider (with error handling)\n    try:\n        result = self._provider.process(\n            file_path=file_path,\n            prompt=prompt,\n            schema=schema,\n            mime_type=mime_type,\n            **kwargs\n        )\n    except Exception as e:\n        # Run error hooks via pluggy\n        error_results = call_hook(\n            \"on_error\",\n            error=e,\n            file_path=file_path,\n            context=context\n        )\n        # Use first non-None fallback\n        fallback = None\n        for hook_result in error_results:\n            if hook_result is not None:\n                fallback = hook_result\n                break\n\n        if fallback is not None:\n            result = fallback\n        else:\n            raise  # Re-raise if no hook handled it\n\n    # Apply output security if enabled\n    if effective_security and isinstance(result, dict):\n        output_result = effective_security.validate_output(result)\n        if not output_result.valid:\n            raise SecurityError(f\"Output rejected: {output_result.reason}\")\n        result = output_result.data or result\n\n    # Run post-process hooks via pluggy\n    if isinstance(result, dict):\n        post_results = call_hook(\n            \"post_process\",\n            result=result,\n            context=context\n        )\n        # Apply modifications from hooks\n        for hook_result in post_results:\n            if hook_result is not None and isinstance(hook_result, dict):\n                result = hook_result\n\n    # Validate with Pydantic if model was provided\n    if pydantic_model is not None:\n        from .pydantic_support import validate_with_pydantic\n        result = validate_with_pydantic(result, pydantic_model)\n\n    # Optional Verification Step\n    if verify:\n        result = self.verify(file_path, result, schema=schema, model=model, **kwargs)\n\n    return result\n</code></pre>"},{"location":"api-reference/#strutex.processor.DocumentProcessor.process_batch","title":"<code>process_batch(file_paths: List[str], prompt: str, schema: Optional[Schema] = None, model: Optional[Type] = None, max_workers: int = 4, **kwargs) -&gt; BatchContext</code>","text":"<p>Process multiple documents in parallel using threads.</p> PARAMETER DESCRIPTION <code>file_paths</code> <p>List of file paths to process</p> <p> TYPE: <code>List[str]</code> </p> <code>prompt</code> <p>Extraction prompt</p> <p> TYPE: <code>str</code> </p> <code>schema</code> <p>Output schema</p> <p> TYPE: <code>Optional[Schema]</code> DEFAULT: <code>None</code> </p> <code>model</code> <p>Pydantic model</p> <p> TYPE: <code>Optional[Type]</code> DEFAULT: <code>None</code> </p> <code>max_workers</code> <p>Number of concurrent threads</p> <p> TYPE: <code>int</code> DEFAULT: <code>4</code> </p> <code>**kwargs</code> <p>Provider options</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>BatchContext</code> <p>BatchContext containing results and stats</p> Source code in <code>strutex/processor.py</code> <pre><code>def process_batch(\n    self,\n    file_paths: List[str],\n    prompt: str,\n    schema: Optional[Schema] = None,\n    model: Optional[Type] = None,\n    max_workers: int = 4,\n    **kwargs\n) -&gt; BatchContext:\n    \"\"\"\n    Process multiple documents in parallel using threads.\n\n    Args:\n        file_paths: List of file paths to process\n        prompt: Extraction prompt\n        schema: Output schema\n        model: Pydantic model\n        max_workers: Number of concurrent threads\n        **kwargs: Provider options\n\n    Returns:\n        BatchContext containing results and stats\n    \"\"\"\n    import concurrent.futures\n    from .context import BatchContext\n\n    batch_ctx = BatchContext(total_documents=len(file_paths))\n\n    def _process_one(path: str):\n        try:\n            result = self.process(path, prompt, schema, model, **kwargs)\n            batch_ctx.add_result(path, result)\n        except Exception as e:\n            batch_ctx.add_error(path, e)\n\n    with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:\n        executor.map(_process_one, file_paths)\n\n    return batch_ctx\n</code></pre>"},{"location":"api-reference/#strutex.processor.DocumentProcessor.verify","title":"<code>verify(file_path: str, result: Any, schema: Optional[Schema] = None, model: Optional[Type] = None, verify_prompt: Optional[str] = None, **kwargs) -&gt; Any</code>","text":"<p>Verify the extracted result against the document.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>Path to the source document</p> <p> TYPE: <code>str</code> </p> <code>result</code> <p>The result to verify (dict or Pydantic model)</p> <p> TYPE: <code>Any</code> </p> <code>schema</code> <p>The schema used for extraction</p> <p> TYPE: <code>Optional[Schema]</code> DEFAULT: <code>None</code> </p> <code>model</code> <p>The Pydantic model used for extraction</p> <p> TYPE: <code>Optional[Type]</code> DEFAULT: <code>None</code> </p> <code>verify_prompt</code> <p>Optional custom verification prompt</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>**kwargs</code> <p>Provider options</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>Verified (and potentially corrected) result</p> Source code in <code>strutex/processor.py</code> <pre><code>def verify(\n    self,\n    file_path: str,\n    result: Any,\n    schema: Optional[Schema] = None,\n    model: Optional[Type] = None,\n    verify_prompt: Optional[str] = None,\n    **kwargs\n) -&gt; Any:\n    \"\"\"\n    Verify the extracted result against the document.\n\n    Args:\n        file_path: Path to the source document\n        result: The result to verify (dict or Pydantic model)\n        schema: The schema used for extraction\n        model: The Pydantic model used for extraction\n        verify_prompt: Optional custom verification prompt\n        **kwargs: Provider options\n\n    Returns:\n        Verified (and potentially corrected) result\n    \"\"\"\n    import json\n\n    # Prepare verification prompt\n    if verify_prompt is None:\n        verify_prompt = (\n            \"You are a strict data auditor. Your task is to verify the extracted data \"\n            \"against the document provided. \\n\"\n            \"Review the data below. If it contains errors or missing fields that exist \"\n            \"in the document, CORRECT them. If the data is correct, return it as is.\\n\"\n            \"Return the final validated JSON strictly adhering to the schema.\"\n        )\n\n    # Serialize result for prompt\n    if hasattr(result, \"model_dump_json\"):\n        result_str = result.model_dump_json()\n    elif isinstance(result, dict):\n        result_str = json.dumps(result, default=str)\n    else:\n        result_str = str(result)\n\n    full_prompt = f\"{verify_prompt}\\n\\n[EXTRACTED DATA TO VERIFY]:\\n{result_str}\"\n\n    # Call process recursively but disable verification to avoid loop\n    return self.process(\n        file_path=file_path,\n        prompt=full_prompt,\n        schema=schema,\n        model=model,\n        verify=False,\n        **kwargs\n    )\n</code></pre>"},{"location":"api-reference/#schema-types","title":"Schema Types","text":"<p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p>"},{"location":"api-reference/#strutex.types.String","title":"<code>String(description: str = None, nullable: bool = False)</code>","text":"<p>               Bases: <code>Schema</code></p> Source code in <code>strutex/types.py</code> <pre><code>def __init__(self, description: str = None, nullable: bool = False):\n    super().__init__(Type.STRING, description=description, nullable=nullable)\n</code></pre>"},{"location":"api-reference/#strutex.types.Number","title":"<code>Number(description: str = None, nullable: bool = False)</code>","text":"<p>               Bases: <code>Schema</code></p> Source code in <code>strutex/types.py</code> <pre><code>def __init__(self, description: str = None, nullable: bool = False):\n    super().__init__(Type.NUMBER, description=description, nullable=nullable)\n</code></pre>"},{"location":"api-reference/#strutex.types.Integer","title":"<code>Integer(description: str = None, nullable: bool = False)</code>","text":"<p>               Bases: <code>Schema</code></p> Source code in <code>strutex/types.py</code> <pre><code>def __init__(self, description: str = None, nullable: bool = False):\n    super().__init__(Type.INTEGER, description=description, nullable=nullable)\n</code></pre>"},{"location":"api-reference/#strutex.types.Boolean","title":"<code>Boolean(description: str = None, nullable: bool = False)</code>","text":"<p>               Bases: <code>Schema</code></p> Source code in <code>strutex/types.py</code> <pre><code>def __init__(self, description: str = None, nullable: bool = False):\n    super().__init__(Type.BOOLEAN, description=description, nullable=nullable)\n</code></pre>"},{"location":"api-reference/#strutex.types.Array","title":"<code>Array(items: Schema, description: str = None, nullable: bool = False)</code>","text":"<p>               Bases: <code>Schema</code></p> <p>Represents a list of items. :param items: The Schema definition for the items inside the array.</p> Source code in <code>strutex/types.py</code> <pre><code>def __init__(self, items: Schema, description: str = None, nullable: bool = False):\n    \"\"\"\n    Represents a list of items.\n    :param items: The Schema definition for the items inside the array.\n    \"\"\"\n    super().__init__(Type.ARRAY, items=items, description=description, nullable=nullable)\n</code></pre>"},{"location":"api-reference/#strutex.types.Object","title":"<code>Object(properties: Dict[str, Schema], description: str = None, required: Optional[List[str]] = None, nullable: bool = False)</code>","text":"<p>               Bases: <code>Schema</code></p> <p>Represents a nested object (dictionary).</p> <p>:param properties: Dictionary mapping field names to Schema objects. :param required: List of keys that are mandatory.                  If None, ALL properties are assumed required.                  Pass [] explicitly if no fields are required.</p> Source code in <code>strutex/types.py</code> <pre><code>def __init__(\n        self,\n        properties: Dict[str, Schema],\n        description: str = None,\n        required: Optional[List[str]] = None,\n        nullable: bool = False\n):\n    \"\"\"\n    Represents a nested object (dictionary).\n\n    :param properties: Dictionary mapping field names to Schema objects.\n    :param required: List of keys that are mandatory.\n                     If None, ALL properties are assumed required.\n                     Pass [] explicitly if no fields are required.\n    \"\"\"\n    # Smart Default: If 'required' is missing, assume strict mode (all fields required)\n    if required is None:\n        calculated_required = list(properties.keys())\n    else:\n        calculated_required = required\n\n    super().__init__(\n        Type.OBJECT,\n        properties=properties,\n        description=description,\n        required=calculated_required,\n        nullable=nullable\n    )\n</code></pre>"},{"location":"api-reference/#plugin-system","title":"Plugin System","text":"<p>options: show_root_heading: true members: - register - get - list - discover</p> <p>options: show_root_heading: true</p>"},{"location":"api-reference/#strutex.plugins.registry.PluginRegistry","title":"<code>PluginRegistry</code>","text":"<p>Central registry for all plugin types with lazy loading.</p> <p>Plugins are stored as EntryPoint objects and only loaded when first accessed via get(). This improves startup time and avoids importing unused dependencies.</p> Usage"},{"location":"api-reference/#strutex.plugins.registry.PluginRegistry--get-a-plugin-loads-on-first-access","title":"Get a plugin (loads on first access)","text":"<p>cls = PluginRegistry.get(\"provider\", \"gemini\")</p>"},{"location":"api-reference/#strutex.plugins.registry.PluginRegistry--list-all-plugins-does-not-load-them","title":"List all plugins (does not load them)","text":"<p>all_providers = PluginRegistry.list(\"provider\")</p>"},{"location":"api-reference/#strutex.plugins.registry.PluginRegistry--force-discovery-from-entry-points","title":"Force discovery from entry points","text":"<p>count = PluginRegistry.discover()</p>"},{"location":"api-reference/#strutex.plugins.registry.PluginRegistry.clear","title":"<code>clear(plugin_type: Optional[str] = None) -&gt; None</code>  <code>classmethod</code>","text":"<p>Clear registered plugins.</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>If provided, only clear this type. Otherwise clear all.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef clear(cls, plugin_type: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Clear registered plugins.\n\n    Args:\n        plugin_type: If provided, only clear this type. Otherwise clear all.\n    \"\"\"\n    if plugin_type:\n        cls._entry_points.pop(plugin_type, None)\n        cls._loaded.pop(plugin_type, None)\n        cls._manual.pop(plugin_type, None)\n    else:\n        cls._entry_points.clear()\n        cls._loaded.clear()\n        cls._manual.clear()\n        cls._discovered = False\n</code></pre>"},{"location":"api-reference/#strutex.plugins.registry.PluginRegistry.discover","title":"<code>discover(group_prefix: str = 'strutex', force: bool = False) -&gt; int</code>  <code>classmethod</code>","text":"<p>Discover and register plugins from entry points.</p> <p>Scans for entry points matching the pattern: - strutex.providers - strutex.validators - strutex.postprocessors - strutex.security - etc.</p> <p>Entry points are stored for lazy loading - they are not imported until first use via get().</p> PARAMETER DESCRIPTION <code>group_prefix</code> <p>Entry point group prefix (default: \"strutex\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'strutex'</code> </p> <code>force</code> <p>Force re-discovery even if already discovered</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>int</code> <p>Number of entry points discovered</p> <p>Example pyproject.toml:     [project.entry-points.\"strutex.providers\"]     my_provider = \"my_package:MyProvider\"</p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef discover(cls, group_prefix: str = \"strutex\", force: bool = False) -&gt; int:\n    \"\"\"\n    Discover and register plugins from entry points.\n\n    Scans for entry points matching the pattern:\n    - strutex.providers\n    - strutex.validators\n    - strutex.postprocessors\n    - strutex.security\n    - etc.\n\n    Entry points are stored for lazy loading - they are not imported\n    until first use via get().\n\n    Args:\n        group_prefix: Entry point group prefix (default: \"strutex\")\n        force: Force re-discovery even if already discovered\n\n    Returns:\n        Number of entry points discovered\n\n    Example pyproject.toml:\n        [project.entry-points.\"strutex.providers\"]\n        my_provider = \"my_package:MyProvider\"\n    \"\"\"\n    if cls._discovered and not force:\n        return sum(len(eps) for eps in cls._entry_points.values())\n\n    discovered = 0\n\n    # Get entry_points function\n    if sys.version_info &gt;= (3, 10):\n        from importlib.metadata import entry_points\n    else:\n        try:\n            from importlib_metadata import entry_points\n        except ImportError:\n            cls._discovered = True\n            return 0\n\n    # Get all entry point groups\n    try:\n        all_eps = entry_points()\n\n        # Get group names that match our prefix\n        if hasattr(all_eps, 'groups'):\n            # Python 3.12+ style\n            groups = [g for g in all_eps.groups if g.startswith(f\"{group_prefix}.\")]\n        elif hasattr(all_eps, 'keys'):\n            # Python 3.9-3.11 style (dict-like)\n            groups = [g for g in all_eps.keys() if g.startswith(f\"{group_prefix}.\")]\n        else:\n            groups = []\n    except Exception:\n        cls._discovered = True\n        return 0\n\n    for group in groups:\n        # Extract plugin type from group name\n        # e.g., \"strutex.providers\" -&gt; \"provider\"\n        plugin_type = group.replace(f\"{group_prefix}.\", \"\").rstrip(\"s\")\n\n        if plugin_type not in cls._entry_points:\n            cls._entry_points[plugin_type] = {}\n\n        try:\n            # Get entry points for this group\n            if hasattr(all_eps, 'select'):\n                eps = all_eps.select(group=group)\n            else:\n                eps = all_eps.get(group, [])\n\n            for ep in eps:\n                # Store entry point for lazy loading\n                cls._entry_points[plugin_type][ep.name.lower()] = ep\n                discovered += 1\n\n        except Exception:\n            pass\n\n    cls._discovered = True\n    return discovered\n</code></pre>"},{"location":"api-reference/#strutex.plugins.registry.PluginRegistry.get","title":"<code>get(plugin_type: str, name: str) -&gt; Optional[Type]</code>  <code>classmethod</code>","text":"<p>Get a registered plugin class by type and name.</p> <p>If the plugin is registered via entry point and not yet loaded, it will be loaded on first access (lazy loading).</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>Type of plugin</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name of the plugin</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Optional[Type]</code> <p>The plugin class, or None if not found</p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef get(cls, plugin_type: str, name: str) -&gt; Optional[Type]:\n    \"\"\"\n    Get a registered plugin class by type and name.\n\n    If the plugin is registered via entry point and not yet loaded,\n    it will be loaded on first access (lazy loading).\n\n    Args:\n        plugin_type: Type of plugin\n        name: Name of the plugin\n\n    Returns:\n        The plugin class, or None if not found\n    \"\"\"\n    name_lower = name.lower()\n\n    # Ensure discovery has run\n    if not cls._discovered:\n        cls.discover()\n\n    # Check loaded cache first\n    if name_lower in cls._loaded.get(plugin_type, {}):\n        return cls._loaded[plugin_type][name_lower]\n\n    # Check manual registrations\n    if name_lower in cls._manual.get(plugin_type, {}):\n        return cls._manual[plugin_type][name_lower]\n\n    # Try to lazy load from entry point\n    ep = cls._entry_points.get(plugin_type, {}).get(name_lower)\n    if ep is not None:\n        plugin_cls = cls._load_entry_point(ep, plugin_type, name_lower)\n        if plugin_cls is not None:\n            return plugin_cls\n\n    return None\n</code></pre>"},{"location":"api-reference/#strutex.plugins.registry.PluginRegistry.get_plugin_info","title":"<code>get_plugin_info(plugin_type: str, name: str) -&gt; Optional[Dict[str, Any]]</code>  <code>classmethod</code>","text":"<p>Get metadata about a plugin without necessarily loading it.</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>Type of plugin</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name of the plugin</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Optional[Dict[str, Any]]</code> <p>Dict with plugin info, or None if not found</p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef get_plugin_info(cls, plugin_type: str, name: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"\n    Get metadata about a plugin without necessarily loading it.\n\n    Args:\n        plugin_type: Type of plugin\n        name: Name of the plugin\n\n    Returns:\n        Dict with plugin info, or None if not found\n    \"\"\"\n    name_lower = name.lower()\n\n    if not cls._discovered:\n        cls.discover()\n\n    # Check if loaded\n    if name_lower in cls._loaded.get(plugin_type, {}):\n        plugin_cls = cls._loaded[plugin_type][name_lower]\n        return {\n            \"name\": name_lower,\n            \"version\": getattr(plugin_cls, \"strutex_plugin_version\", \"unknown\"),\n            \"priority\": getattr(plugin_cls, \"priority\", 50),\n            \"cost\": getattr(plugin_cls, \"cost\", 1.0),\n            \"capabilities\": getattr(plugin_cls, \"capabilities\", []),\n            \"loaded\": True,\n            \"healthy\": cls._check_health(plugin_cls),\n        }\n\n    # Check entry point\n    ep = cls._entry_points.get(plugin_type, {}).get(name_lower)\n    if ep is not None:\n        return {\n            \"name\": name_lower,\n            \"entry_point\": f\"{ep.group}:{ep.name}\",\n            \"loaded\": False,\n            \"healthy\": None,  # Unknown until loaded\n        }\n\n    return None\n</code></pre>"},{"location":"api-reference/#strutex.plugins.registry.PluginRegistry.get_sorted","title":"<code>get_sorted(plugin_type: str, reverse: bool = True) -&gt; List[Tuple[str, Type]]</code>  <code>classmethod</code>","text":"<p>Get all plugins of a type sorted by priority.</p> <p>Useful for waterfall selection where you want to try higher-priority plugins first.</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>Type of plugin</p> <p> TYPE: <code>str</code> </p> <code>reverse</code> <p>If True (default), higher priority first</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>List[Tuple[str, Type]]</code> <p>List of (name, class) tuples sorted by priority</p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef get_sorted(cls, plugin_type: str, reverse: bool = True) -&gt; List[Tuple[str, Type]]:\n    \"\"\"\n    Get all plugins of a type sorted by priority.\n\n    Useful for waterfall selection where you want to try\n    higher-priority plugins first.\n\n    Args:\n        plugin_type: Type of plugin\n        reverse: If True (default), higher priority first\n\n    Returns:\n        List of (name, class) tuples sorted by priority\n    \"\"\"\n    plugins = cls.list(plugin_type)\n    return sorted(\n        plugins.items(),\n        key=lambda x: getattr(x[1], 'priority', 50),\n        reverse=reverse\n    )\n</code></pre>"},{"location":"api-reference/#strutex.plugins.registry.PluginRegistry.list","title":"<code>list(plugin_type: str) -&gt; Dict[str, Type]</code>  <code>classmethod</code>","text":"<p>List all plugins of a given type.</p> <p>Note: This loads all plugins of the type. Use list_names() for a lightweight listing without loading.</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>Type of plugin</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Dict[str, Type]</code> <p>Dictionary mapping names to plugin classes</p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef list(cls, plugin_type: str) -&gt; Dict[str, Type]:\n    \"\"\"\n    List all plugins of a given type.\n\n    Note: This loads all plugins of the type. Use list_names()\n    for a lightweight listing without loading.\n\n    Args:\n        plugin_type: Type of plugin\n\n    Returns:\n        Dictionary mapping names to plugin classes\n    \"\"\"\n    if not cls._discovered:\n        cls.discover()\n\n    result = {}\n\n    # Get all names from entry points and manual registrations\n    all_names = set()\n    all_names.update(cls._entry_points.get(plugin_type, {}).keys())\n    all_names.update(cls._manual.get(plugin_type, {}).keys())\n    all_names.update(cls._loaded.get(plugin_type, {}).keys())\n\n    # Load each plugin\n    for name in all_names:\n        plugin_cls = cls.get(plugin_type, name)\n        if plugin_cls is not None:\n            result[name] = plugin_cls\n\n    return result\n</code></pre>"},{"location":"api-reference/#strutex.plugins.registry.PluginRegistry.list_names","title":"<code>list_names(plugin_type: str) -&gt; List[str]</code>  <code>classmethod</code>","text":"<p>List names of all plugins of a given type without loading them.</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>Type of plugin</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>List[str]</code> <p>List of plugin names</p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef list_names(cls, plugin_type: str) -&gt; List[str]:\n    \"\"\"\n    List names of all plugins of a given type without loading them.\n\n    Args:\n        plugin_type: Type of plugin\n\n    Returns:\n        List of plugin names\n    \"\"\"\n    if not cls._discovered:\n        cls.discover()\n\n    names = set()\n    names.update(cls._entry_points.get(plugin_type, {}).keys())\n    names.update(cls._manual.get(plugin_type, {}).keys())\n    names.update(cls._loaded.get(plugin_type, {}).keys())\n\n    return sorted(names)\n</code></pre>"},{"location":"api-reference/#strutex.plugins.registry.PluginRegistry.list_types","title":"<code>list_types() -&gt; List[str]</code>  <code>classmethod</code>","text":"<p>List all registered plugin types.</p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef list_types(cls) -&gt; List[str]:\n    \"\"\"List all registered plugin types.\"\"\"\n    if not cls._discovered:\n        cls.discover()\n\n    types = set()\n    types.update(cls._entry_points.keys())\n    types.update(cls._manual.keys())\n    types.update(cls._loaded.keys())\n\n    return sorted(types)\n</code></pre>"},{"location":"api-reference/#strutex.plugins.registry.PluginRegistry.register","title":"<code>register(plugin_type: str, name: str, plugin_cls: Type) -&gt; None</code>  <code>classmethod</code>","text":"<p>Register a plugin class manually.</p> <p>This is used by the @register decorator for backwards compatibility. Prefer using entry points in pyproject.toml for new plugins.</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>Type of plugin (e.g., \"provider\", \"security\", \"validator\")</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Unique name for this plugin</p> <p> TYPE: <code>str</code> </p> <code>plugin_cls</code> <p>The plugin class to register</p> <p> TYPE: <code>Type</code> </p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef register(cls, plugin_type: str, name: str, plugin_cls: Type) -&gt; None:\n    \"\"\"\n    Register a plugin class manually.\n\n    This is used by the @register decorator for backwards compatibility.\n    Prefer using entry points in pyproject.toml for new plugins.\n\n    Args:\n        plugin_type: Type of plugin (e.g., \"provider\", \"security\", \"validator\")\n        name: Unique name for this plugin\n        plugin_cls: The plugin class to register\n    \"\"\"\n    if plugin_type not in cls._manual:\n        cls._manual[plugin_type] = {}\n\n    cls._manual[plugin_type][name.lower()] = plugin_cls\n\n    # Also add to loaded cache\n    if plugin_type not in cls._loaded:\n        cls._loaded[plugin_type] = {}\n    cls._loaded[plugin_type][name.lower()] = plugin_cls\n</code></pre>"},{"location":"api-reference/#strutex.plugins.registry.register","title":"<code>register(plugin_type: str, name: Optional[str] = None) -&gt; Callable[[Type], Type]</code>","text":"<p>Decorator to register a plugin class at runtime.</p> <p>Use this decorator for: - Runtime/dynamic registration based on config - Prototyping plugins without packaging - Plugins in the same codebase (not installed separately) - Conditional loading based on environment or feature flags</p> <p>For distributable third-party plugin packages, use entry points in pyproject.toml instead.</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>Type of plugin (e.g., \"provider\", \"security\", \"validator\")</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Optional name. If not provided, uses lowercase class name.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Usage <p>@register(\"provider\") class MyProvider(Provider):     ...</p> <p>@register(\"provider\", name=\"custom_name\") class AnotherProvider(Provider):     ...</p> See Also <p>Entry points in pyproject.toml for distributable packages:</p> <pre><code>[project.entry-points.\"strutex.providers\"]\nmy_provider = \"my_package:MyProvider\"\n</code></pre> Source code in <code>strutex/plugins/registry.py</code> <pre><code>def register(\n    plugin_type: str,\n    name: Optional[str] = None,\n) -&gt; Callable[[Type], Type]:\n    \"\"\"\n    Decorator to register a plugin class at runtime.\n\n    Use this decorator for:\n    - Runtime/dynamic registration based on config\n    - Prototyping plugins without packaging\n    - Plugins in the same codebase (not installed separately)\n    - Conditional loading based on environment or feature flags\n\n    For distributable third-party plugin packages, use entry points\n    in pyproject.toml instead.\n\n    Args:\n        plugin_type: Type of plugin (e.g., \"provider\", \"security\", \"validator\")\n        name: Optional name. If not provided, uses lowercase class name.\n\n    Usage:\n        @register(\"provider\")\n        class MyProvider(Provider):\n            ...\n\n        @register(\"provider\", name=\"custom_name\")\n        class AnotherProvider(Provider):\n            ...\n\n    See Also:\n        Entry points in pyproject.toml for distributable packages:\n\n            [project.entry-points.\"strutex.providers\"]\n            my_provider = \"my_package:MyProvider\"\n    \"\"\"\n    def decorator(cls: Type) -&gt; Type:\n        plugin_name = name if name else cls.__name__.lower()\n        PluginRegistry.register(plugin_type, plugin_name, cls)\n        return cls\n\n    return decorator\n</code></pre>"},{"location":"api-reference/#base-classes","title":"Base Classes","text":"<p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p>"},{"location":"api-reference/#strutex.plugins.base.Provider","title":"<code>Provider</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for LLM providers.</p> <p>All providers must implement the process method to handle document extraction via their specific LLM API.</p> <p>Subclassing auto-registers the plugin. Use class arguments to customize:</p> <pre><code>class MyProvider(Provider, name=\"custom\", priority=90):\n    ...\n</code></pre> ATTRIBUTE DESCRIPTION <code>strutex_plugin_version</code> <p>API version for compatibility checks</p> <p> TYPE: <code>str</code> </p> <code>priority</code> <p>Ordering priority (0-100, higher = preferred)</p> <p> TYPE: <code>int</code> </p> <code>cost</code> <p>Cost hint for optimization (lower = cheaper)</p> <p> TYPE: <code>float</code> </p> <code>capabilities</code> <p>List of supported features</p> <p> TYPE: <code>List[str]</code> </p>"},{"location":"api-reference/#strutex.plugins.base.Provider.aprocess","title":"<code>aprocess(file_path: str, prompt: str, schema: Schema, mime_type: str, **kwargs) -&gt; Any</code>  <code>async</code>","text":"<p>Async version of process. Override for true async support. Default implementation calls sync version.</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>async def aprocess(\n    self,\n    file_path: str,\n    prompt: str,\n    schema: Schema,\n    mime_type: str,\n    **kwargs\n) -&gt; Any:\n    \"\"\"\n    Async version of process. Override for true async support.\n    Default implementation calls sync version.\n    \"\"\"\n    return self.process(file_path, prompt, schema, mime_type, **kwargs)\n</code></pre>"},{"location":"api-reference/#strutex.plugins.base.Provider.has_capability","title":"<code>has_capability(capability: str) -&gt; bool</code>","text":"<p>Check if this provider has a specific capability.</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>def has_capability(self, capability: str) -&gt; bool:\n    \"\"\"Check if this provider has a specific capability.\"\"\"\n    return capability.lower() in [c.lower() for c in self.capabilities]\n</code></pre>"},{"location":"api-reference/#strutex.plugins.base.Provider.health_check","title":"<code>health_check() -&gt; bool</code>  <code>classmethod</code>","text":"<p>Check if this provider is healthy and ready to use.</p> <p>Override in subclasses for custom health checks (e.g., API connectivity).</p> RETURNS DESCRIPTION <code>bool</code> <p>True if healthy, False otherwise</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>@classmethod\ndef health_check(cls) -&gt; bool:\n    \"\"\"\n    Check if this provider is healthy and ready to use.\n\n    Override in subclasses for custom health checks (e.g., API connectivity).\n\n    Returns:\n        True if healthy, False otherwise\n    \"\"\"\n    return True\n</code></pre>"},{"location":"api-reference/#strutex.plugins.base.Provider.process","title":"<code>process(file_path: str, prompt: str, schema: Schema, mime_type: str, **kwargs) -&gt; Any</code>  <code>abstractmethod</code>","text":"<p>Process a document and extract structured data.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>Path to the document file</p> <p> TYPE: <code>str</code> </p> <code>prompt</code> <p>Extraction prompt/instructions</p> <p> TYPE: <code>str</code> </p> <code>schema</code> <p>Expected output schema</p> <p> TYPE: <code>Schema</code> </p> <code>mime_type</code> <p>MIME type of the file</p> <p> TYPE: <code>str</code> </p> <code>**kwargs</code> <p>Provider-specific options</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>Extracted data matching the schema</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>@abstractmethod\ndef process(\n    self,\n    file_path: str,\n    prompt: str,\n    schema: Schema,\n    mime_type: str,\n    **kwargs\n) -&gt; Any:\n    \"\"\"\n    Process a document and extract structured data.\n\n    Args:\n        file_path: Path to the document file\n        prompt: Extraction prompt/instructions\n        schema: Expected output schema\n        mime_type: MIME type of the file\n        **kwargs: Provider-specific options\n\n    Returns:\n        Extracted data matching the schema\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/#strutex.plugins.base.Validator","title":"<code>Validator</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for output validators.</p> <p>Validators check extracted data for correctness and can optionally fix issues.</p> <p>Subclassing auto-registers the plugin.</p> ATTRIBUTE DESCRIPTION <code>strutex_plugin_version</code> <p>API version for compatibility checks</p> <p> TYPE: <code>str</code> </p> <code>priority</code> <p>Ordering priority in validation chain</p> <p> TYPE: <code>int</code> </p>"},{"location":"api-reference/#strutex.plugins.base.Validator.health_check","title":"<code>health_check() -&gt; bool</code>  <code>classmethod</code>","text":"<p>Check if this validator is healthy and ready.</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>@classmethod\ndef health_check(cls) -&gt; bool:\n    \"\"\"Check if this validator is healthy and ready.\"\"\"\n    return True\n</code></pre>"},{"location":"api-reference/#strutex.plugins.base.Validator.validate","title":"<code>validate(data: Dict[str, Any], schema: Optional[Schema] = None) -&gt; ValidationResult</code>  <code>abstractmethod</code>","text":"<p>Validate extracted data.</p> PARAMETER DESCRIPTION <code>data</code> <p>The extracted data to validate</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>schema</code> <p>Optional schema to validate against</p> <p> TYPE: <code>Optional[Schema]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValidationResult</code> <p>ValidationResult with status and any issues</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>@abstractmethod\ndef validate(self, data: Dict[str, Any], schema: Optional[Schema] = None) -&gt; \"ValidationResult\":\n    \"\"\"\n    Validate extracted data.\n\n    Args:\n        data: The extracted data to validate\n        schema: Optional schema to validate against\n\n    Returns:\n        ValidationResult with status and any issues\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/#strutex.plugins.base.Postprocessor","title":"<code>Postprocessor</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for data postprocessors.</p> <p>Postprocessors transform extracted data (e.g., normalize dates, convert currencies, standardize units).</p> <p>Subclassing auto-registers the plugin.</p> ATTRIBUTE DESCRIPTION <code>strutex_plugin_version</code> <p>API version for compatibility checks</p> <p> TYPE: <code>str</code> </p> <code>priority</code> <p>Ordering priority in postprocessing pipeline</p> <p> TYPE: <code>int</code> </p>"},{"location":"api-reference/#strutex.plugins.base.Postprocessor.health_check","title":"<code>health_check() -&gt; bool</code>  <code>classmethod</code>","text":"<p>Check if this postprocessor is healthy and ready.</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>@classmethod\ndef health_check(cls) -&gt; bool:\n    \"\"\"Check if this postprocessor is healthy and ready.\"\"\"\n    return True\n</code></pre>"},{"location":"api-reference/#strutex.plugins.base.Postprocessor.process","title":"<code>process(data: Dict[str, Any]) -&gt; Dict[str, Any]</code>  <code>abstractmethod</code>","text":"<p>Process/transform the extracted data.</p> PARAMETER DESCRIPTION <code>data</code> <p>The data to transform</p> <p> TYPE: <code>Dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>Dict[str, Any]</code> <p>Transformed data</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>@abstractmethod\ndef process(self, data: Dict[str, Any]) -&gt; Dict[str, Any]:\n    \"\"\"\n    Process/transform the extracted data.\n\n    Args:\n        data: The data to transform\n\n    Returns:\n        Transformed data\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api-reference/#strutex.plugins.base.SecurityPlugin","title":"<code>SecurityPlugin</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for security plugins.</p> <p>Security plugins can validate/sanitize input before sending to the LLM and validate output before returning to the user.</p> <p>Subclassing auto-registers the plugin.</p> ATTRIBUTE DESCRIPTION <code>strutex_plugin_version</code> <p>API version for compatibility checks</p> <p> TYPE: <code>str</code> </p> <code>priority</code> <p>Ordering priority in security chain</p> <p> TYPE: <code>int</code> </p>"},{"location":"api-reference/#strutex.plugins.base.SecurityPlugin.health_check","title":"<code>health_check() -&gt; bool</code>  <code>classmethod</code>","text":"<p>Check if this security plugin is healthy and ready.</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>@classmethod\ndef health_check(cls) -&gt; bool:\n    \"\"\"Check if this security plugin is healthy and ready.\"\"\"\n    return True\n</code></pre>"},{"location":"api-reference/#strutex.plugins.base.SecurityPlugin.validate_input","title":"<code>validate_input(text: str) -&gt; SecurityResult</code>","text":"<p>Validate/sanitize input text before sending to LLM.</p> PARAMETER DESCRIPTION <code>text</code> <p>The input text (prompt + document content)</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>SecurityResult</code> <p>SecurityResult with sanitized text or rejection</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>def validate_input(self, text: str) -&gt; \"SecurityResult\":\n    \"\"\"\n    Validate/sanitize input text before sending to LLM.\n\n    Args:\n        text: The input text (prompt + document content)\n\n    Returns:\n        SecurityResult with sanitized text or rejection\n    \"\"\"\n    return SecurityResult(valid=True, text=text)\n</code></pre>"},{"location":"api-reference/#strutex.plugins.base.SecurityPlugin.validate_output","title":"<code>validate_output(data: Dict[str, Any]) -&gt; SecurityResult</code>","text":"<p>Validate output data before returning to user.</p> PARAMETER DESCRIPTION <code>data</code> <p>The extracted data</p> <p> TYPE: <code>Dict[str, Any]</code> </p> RETURNS DESCRIPTION <code>SecurityResult</code> <p>SecurityResult with clean data or rejection</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>def validate_output(self, data: Dict[str, Any]) -&gt; \"SecurityResult\":\n    \"\"\"\n    Validate output data before returning to user.\n\n    Args:\n        data: The extracted data\n\n    Returns:\n        SecurityResult with clean data or rejection\n    \"\"\"\n    return SecurityResult(valid=True, data=data)\n</code></pre>"},{"location":"api-reference/#security","title":"Security","text":"<p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p>"},{"location":"api-reference/#strutex.security.chain.SecurityChain","title":"<code>SecurityChain(plugins: List[SecurityPlugin])</code>","text":"<p>               Bases: <code>SecurityPlugin</code></p> <p>Chains multiple security plugins together.</p> <p>Runs each plugin in sequence. If any plugin rejects, the chain stops.</p> Usage <p>chain = SecurityChain([     InputSanitizer(collapse_whitespace=True),     PromptInjectionDetector(), ]) result = chain.validate_input(text)</p> PARAMETER DESCRIPTION <code>plugins</code> <p>List of security plugins to run in order</p> <p> TYPE: <code>List[SecurityPlugin]</code> </p> Source code in <code>strutex/security/chain.py</code> <pre><code>def __init__(self, plugins: List[SecurityPlugin]):\n    \"\"\"\n    Args:\n        plugins: List of security plugins to run in order\n    \"\"\"\n    self.plugins = plugins\n</code></pre>"},{"location":"api-reference/#strutex.security.chain.SecurityChain.add","title":"<code>add(plugin: SecurityPlugin) -&gt; SecurityChain</code>","text":"<p>Add a plugin to the chain. Returns self for chaining.</p> Source code in <code>strutex/security/chain.py</code> <pre><code>def add(self, plugin: SecurityPlugin) -&gt; \"SecurityChain\":\n    \"\"\"Add a plugin to the chain. Returns self for chaining.\"\"\"\n    self.plugins.append(plugin)\n    return self\n</code></pre>"},{"location":"api-reference/#strutex.security.chain.SecurityChain.validate_input","title":"<code>validate_input(text: str) -&gt; SecurityResult</code>","text":"<p>Run all plugins' input validation in sequence.</p> Source code in <code>strutex/security/chain.py</code> <pre><code>def validate_input(self, text: str) -&gt; SecurityResult:\n    \"\"\"Run all plugins' input validation in sequence.\"\"\"\n    current_text = text\n\n    for plugin in self.plugins:\n        result = plugin.validate_input(current_text)\n        if not result.valid:\n            return result\n        # Use possibly-sanitized text for next plugin\n        if result.text is not None:\n            current_text = result.text\n\n    return SecurityResult(valid=True, text=current_text)\n</code></pre>"},{"location":"api-reference/#strutex.security.chain.SecurityChain.validate_output","title":"<code>validate_output(data: Dict[str, Any]) -&gt; SecurityResult</code>","text":"<p>Run all plugins' output validation in sequence.</p> Source code in <code>strutex/security/chain.py</code> <pre><code>def validate_output(self, data: Dict[str, Any]) -&gt; SecurityResult:\n    \"\"\"Run all plugins' output validation in sequence.\"\"\"\n    current_data = data\n\n    for plugin in self.plugins:\n        result = plugin.validate_output(current_data)\n        if not result.valid:\n            return result\n        # Use possibly-modified data for next plugin\n        if result.data is not None:\n            current_data = result.data\n\n    return SecurityResult(valid=True, data=current_data)\n</code></pre>"},{"location":"api-reference/#strutex.security.sanitizer.InputSanitizer","title":"<code>InputSanitizer(collapse_whitespace: bool = True, normalize_unicode: bool = True, remove_invisible: bool = True, max_length: Optional[int] = None)</code>","text":"<p>               Bases: <code>SecurityPlugin</code></p> <p>Sanitizes input text to prevent various attacks.</p> <p>Features: - Collapse excessive whitespace - Normalize Unicode characters - Remove invisible characters - Limit input length</p> Usage <p>sanitizer = InputSanitizer(collapse_whitespace=True, max_length=50000) result = sanitizer.validate_input(text)</p> Source code in <code>strutex/security/sanitizer.py</code> <pre><code>def __init__(\n    self,\n    collapse_whitespace: bool = True,\n    normalize_unicode: bool = True,\n    remove_invisible: bool = True,\n    max_length: Optional[int] = None\n):\n    self.collapse_whitespace = collapse_whitespace\n    self.normalize_unicode = normalize_unicode\n    self.remove_invisible = remove_invisible\n    self.max_length = max_length\n</code></pre>"},{"location":"api-reference/#strutex.security.sanitizer.InputSanitizer.validate_input","title":"<code>validate_input(text: str) -&gt; SecurityResult</code>","text":"<p>Sanitize the input text.</p> Source code in <code>strutex/security/sanitizer.py</code> <pre><code>def validate_input(self, text: str) -&gt; SecurityResult:\n    \"\"\"Sanitize the input text.\"\"\"\n    sanitized = text\n\n    # Normalize Unicode (NFC form)\n    if self.normalize_unicode:\n        sanitized = unicodedata.normalize(\"NFC\", sanitized)\n\n    # Remove invisible characters (zero-width, etc.)\n    if self.remove_invisible:\n        # Remove zero-width characters and other invisibles\n        invisible_pattern = r'[\\u200b\\u200c\\u200d\\u2060\\u2061\\u2062\\u2063\\u2064\\ufeff]'\n        sanitized = re.sub(invisible_pattern, '', sanitized)\n\n    # Collapse whitespace (multiple spaces/newlines \u2192 single)\n    if self.collapse_whitespace:\n        # Collapse multiple spaces to single\n        sanitized = re.sub(r' {2,}', ' ', sanitized)\n        # Collapse multiple newlines to double (preserve paragraphs)\n        sanitized = re.sub(r'\\n{3,}', '\\n\\n', sanitized)\n        # Remove trailing whitespace per line\n        sanitized = re.sub(r' +$', '', sanitized, flags=re.MULTILINE)\n\n    # Enforce max length\n    if self.max_length and len(sanitized) &gt; self.max_length:\n        return SecurityResult(\n            valid=False,\n            text=None,\n            reason=f\"Input exceeds maximum length of {self.max_length} characters\"\n        )\n\n    return SecurityResult(valid=True, text=sanitized)\n</code></pre>"},{"location":"api-reference/#strutex.security.injection.PromptInjectionDetector","title":"<code>PromptInjectionDetector(strict: bool = False, additional_patterns: List[Tuple[str, str]] = None, block_on_detection: bool = True)</code>","text":"<p>               Bases: <code>SecurityPlugin</code></p> <p>Detects common prompt injection patterns.</p> <p>Checks for: - Direct instruction overrides (\"ignore previous instructions\") - Role manipulation (\"you are now\", \"pretend to be\") - Delimiter attacks (markdown, XML-style tags) - Encoding attacks (base64 instructions)</p> Usage <p>detector = PromptInjectionDetector(strict=True) result = detector.validate_input(text)</p> PARAMETER DESCRIPTION <code>strict</code> <p>If True, use stricter matching</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>additional_patterns</code> <p>Extra (pattern, category) tuples to check</p> <p> TYPE: <code>List[Tuple[str, str]]</code> DEFAULT: <code>None</code> </p> <code>block_on_detection</code> <p>If True, reject input on detection. If False, just warn.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>strutex/security/injection.py</code> <pre><code>def __init__(\n    self,\n    strict: bool = False,\n    additional_patterns: List[Tuple[str, str]] = None,\n    block_on_detection: bool = True\n):\n    \"\"\"\n    Args:\n        strict: If True, use stricter matching\n        additional_patterns: Extra (pattern, category) tuples to check\n        block_on_detection: If True, reject input on detection. If False, just warn.\n    \"\"\"\n    self.strict = strict\n    self.patterns = list(self.DEFAULT_PATTERNS)\n    if additional_patterns:\n        self.patterns.extend(additional_patterns)\n    self.block_on_detection = block_on_detection\n\n    # Compile patterns\n    flags = re.IGNORECASE\n    self._compiled = [(re.compile(p, flags), cat) for p, cat in self.patterns]\n</code></pre>"},{"location":"api-reference/#strutex.security.injection.PromptInjectionDetector.get_detections","title":"<code>get_detections(text: str) -&gt; List[dict]</code>","text":"<p>Get detailed detection information without blocking.</p> Source code in <code>strutex/security/injection.py</code> <pre><code>def get_detections(self, text: str) -&gt; List[dict]:\n    \"\"\"Get detailed detection information without blocking.\"\"\"\n    detections = []\n    for pattern, category in self._compiled:\n        matches = pattern.findall(text)\n        if matches:\n            detections.append({\n                \"category\": category,\n                \"pattern\": pattern.pattern,\n                \"matches\": matches[:5]  # Limit for safety\n            })\n    return detections\n</code></pre>"},{"location":"api-reference/#strutex.security.injection.PromptInjectionDetector.validate_input","title":"<code>validate_input(text: str) -&gt; SecurityResult</code>","text":"<p>Check for prompt injection patterns.</p> Source code in <code>strutex/security/injection.py</code> <pre><code>def validate_input(self, text: str) -&gt; SecurityResult:\n    \"\"\"Check for prompt injection patterns.\"\"\"\n    detections = []\n\n    for pattern, category in self._compiled:\n        matches = pattern.findall(text)\n        if matches:\n            detections.append({\n                \"category\": category,\n                \"pattern\": pattern.pattern,\n                \"count\": len(matches)\n            })\n\n    if detections:\n        if self.block_on_detection:\n            categories = list(set(d[\"category\"] for d in detections))\n            return SecurityResult(\n                valid=False,\n                text=None,\n                reason=f\"Potential prompt injection detected: {', '.join(categories)}\"\n            )\n        else:\n            # Allow but flag\n            return SecurityResult(\n                valid=True,\n                text=text,\n                reason=f\"Warning: potential injection patterns found\"\n            )\n\n    return SecurityResult(valid=True, text=text)\n</code></pre>"},{"location":"api-reference/#strutex.security.output.OutputValidator","title":"<code>OutputValidator(check_secrets: bool = True, check_prompt_leaks: bool = True, secret_patterns: Optional[List[tuple]] = None, block_on_detection: bool = True)</code>","text":"<p>               Bases: <code>SecurityPlugin</code></p> <p>Validates LLM output for security issues.</p> <p>Checks for: - Leaked API keys/secrets - Leaked system prompts - Suspicious executable patterns - PII exposure</p> Usage <p>validator = OutputValidator() result = validator.validate_output(data)</p> Source code in <code>strutex/security/output.py</code> <pre><code>def __init__(\n    self,\n    check_secrets: bool = True,\n    check_prompt_leaks: bool = True,\n    secret_patterns: Optional[List[tuple]] = None,\n    block_on_detection: bool = True\n):\n    self.check_secrets = check_secrets\n    self.check_prompt_leaks = check_prompt_leaks\n    self.block_on_detection = block_on_detection\n\n    # Compile patterns\n    patterns = secret_patterns or self.SECRET_PATTERNS\n    self._secret_patterns = [(re.compile(p, re.IGNORECASE), name) for p, name in patterns]\n    self._leak_patterns = [re.compile(p, re.IGNORECASE) for p in self.PROMPT_LEAK_PATTERNS]\n</code></pre>"},{"location":"api-reference/#strutex.security.output.OutputValidator.validate_output","title":"<code>validate_output(data: Dict[str, Any]) -&gt; SecurityResult</code>","text":"<p>Validate output data for security issues.</p> Source code in <code>strutex/security/output.py</code> <pre><code>def validate_output(self, data: Dict[str, Any]) -&gt; SecurityResult:\n    \"\"\"Validate output data for security issues.\"\"\"\n    issues = []\n\n    # Convert to string for pattern matching\n    text = self._flatten_to_text(data)\n\n    # Check for secrets\n    if self.check_secrets:\n        for pattern, secret_type in self._secret_patterns:\n            if pattern.search(text):\n                issues.append(f\"Potential {secret_type} detected in output\")\n\n    # Check for prompt leaks\n    if self.check_prompt_leaks:\n        for pattern in self._leak_patterns:\n            if pattern.search(text):\n                issues.append(\"Potential system prompt leak detected\")\n                break\n\n    if issues:\n        if self.block_on_detection:\n            return SecurityResult(\n                valid=False,\n                data=None,\n                reason=\"; \".join(issues)\n            )\n        else:\n            return SecurityResult(\n                valid=True,\n                data=data,\n                reason=f\"Warning: {'; '.join(issues)}\"\n            )\n\n    return SecurityResult(valid=True, data=data)\n</code></pre>"},{"location":"api-reference/#prompts","title":"Prompts","text":"<p>options: show_root_heading: true members: - init - add_general_rule - add_field_rule - add_output_guideline - compile</p>"},{"location":"api-reference/#strutex.prompts.builder.StructuredPrompt","title":"<code>StructuredPrompt(persona: str = 'You are a highly accurate AI Data Extraction Assistant.')</code>","text":"<p>Builder for organizing complex extraction prompts.</p> <p>Provides a fluent API for constructing well-structured prompts with general rules, field-specific rules, and output guidelines.</p> Usage <p>prompt = StructuredPrompt(\"You are an expert...\")</p> Example <p>prompt = ( ...     StructuredPrompt() ...     .add_general_rule( ...         \"Strict data fidelity: do not invent values.\",  ...         \"Dates must be in DD.MM.YYYY format.\" ...     ) ...     .add_field_rule( ...         \"artikelnummer\",  ...         \"Must be 8 digits.\",  ...         \"Ignore supplier codes.\", ...         critical=True ...     ) ...     .add_output_guideline(\"Return valid JSON.\") ...     .compile() ... )</p> <p>Initialize the prompt builder.</p> PARAMETER DESCRIPTION <code>persona</code> <p>The system persona/role description.</p> <p> TYPE: <code>str</code> DEFAULT: <code>'You are a highly accurate AI Data Extraction Assistant.'</code> </p> Source code in <code>strutex/prompts/builder.py</code> <pre><code>def __init__(self, persona: str = \"You are a highly accurate AI Data Extraction Assistant.\"):\n    \"\"\"\n    Initialize the prompt builder.\n\n    Args:\n        persona: The system persona/role description.\n    \"\"\"\n    self.persona = persona.strip()\n    self.general_rules: List[str] = []\n    self.field_rules: Dict[str, List[str]] = {}\n    self.output_guidelines: List[str] = []\n</code></pre>"},{"location":"api-reference/#strutex.prompts.builder.StructuredPrompt--variadic-arguments-allow-adding-multiple-rules-at-once","title":"Variadic arguments allow adding multiple rules at once","text":"<p>prompt.add_general_rule(\"No guessing\", \"Use ISO dates\") prompt.add_field_rule(\"total\", \"Exclude tax\", \"Must be numeric\", critical=True) final_string = prompt.compile()</p>"},{"location":"api-reference/#strutex.prompts.builder.StructuredPrompt.__str__","title":"<code>__str__() -&gt; str</code>","text":"<p>Allow using the prompt directly as a string.</p> Source code in <code>strutex/prompts/builder.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Allow using the prompt directly as a string.\"\"\"\n    return self.compile()\n</code></pre>"},{"location":"api-reference/#strutex.prompts.builder.StructuredPrompt.add_field_rule","title":"<code>add_field_rule(field_name: str, *rules: str, critical: bool = False) -&gt; StructuredPrompt</code>","text":"<p>Adds one or more rules specific to a single field.</p> PARAMETER DESCRIPTION <code>field_name</code> <p>The name of the field these rules apply to.</p> <p> TYPE: <code>str</code> </p> <code>*rules</code> <p>Variable number of rule strings.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> <code>critical</code> <p>If True, prefixes rules with CRITICAL.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>StructuredPrompt</code> <p>Self for method chaining.</p> Example <p>.add_field_rule(\"invoice_id\", \"Must be numeric\", \"8 digits\", critical=True)</p> Source code in <code>strutex/prompts/builder.py</code> <pre><code>def add_field_rule(self, field_name: str, *rules: str, critical: bool = False) -&gt; \"StructuredPrompt\":\n    \"\"\"\n    Adds one or more rules specific to a single field.\n\n    Args:\n        field_name: The name of the field these rules apply to.\n        *rules: Variable number of rule strings.\n        critical: If True, prefixes rules with **CRITICAL**.\n\n    Returns:\n        Self for method chaining.\n\n    Example:\n        .add_field_rule(\"invoice_id\", \"Must be numeric\", \"8 digits\", critical=True)\n    \"\"\"\n    if field_name not in self.field_rules:\n        self.field_rules[field_name] = []\n\n    prefix = \"**CRITICAL**: \" if critical else \"\"\n    for rule in rules:\n        self.field_rules[field_name].append(f\"{prefix}{rule}\")\n    return self\n</code></pre>"},{"location":"api-reference/#strutex.prompts.builder.StructuredPrompt.add_general_rule","title":"<code>add_general_rule(*rules: str) -&gt; StructuredPrompt</code>","text":"<p>Adds one or more high-level rules.</p> PARAMETER DESCRIPTION <code>*rules</code> <p>Variable number of rule strings.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>StructuredPrompt</code> <p>Self for method chaining.</p> Example <p>.add_general_rule(\"Rule 1\", \"Rule 2\", \"Rule 3\")</p> Source code in <code>strutex/prompts/builder.py</code> <pre><code>def add_general_rule(self, *rules: str) -&gt; \"StructuredPrompt\":\n    \"\"\"\n    Adds one or more high-level rules.\n\n    Args:\n        *rules: Variable number of rule strings.\n\n    Returns:\n        Self for method chaining.\n\n    Example:\n        .add_general_rule(\"Rule 1\", \"Rule 2\", \"Rule 3\")\n    \"\"\"\n    self.general_rules.extend(rules)\n    return self\n</code></pre>"},{"location":"api-reference/#strutex.prompts.builder.StructuredPrompt.add_output_guideline","title":"<code>add_output_guideline(*guidelines: str) -&gt; StructuredPrompt</code>","text":"<p>Adds formatting instructions for the output.</p> PARAMETER DESCRIPTION <code>*guidelines</code> <p>Variable number of guideline strings.</p> <p> TYPE: <code>str</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>StructuredPrompt</code> <p>Self for method chaining.</p> Example <p>.add_output_guideline(\"JSON only\", \"No markdown\", \"No comments\")</p> Source code in <code>strutex/prompts/builder.py</code> <pre><code>def add_output_guideline(self, *guidelines: str) -&gt; \"StructuredPrompt\":\n    \"\"\"\n    Adds formatting instructions for the output.\n\n    Args:\n        *guidelines: Variable number of guideline strings.\n\n    Returns:\n        Self for method chaining.\n\n    Example:\n        .add_output_guideline(\"JSON only\", \"No markdown\", \"No comments\")\n    \"\"\"\n    self.output_guidelines.extend(guidelines)\n    return self\n</code></pre>"},{"location":"api-reference/#strutex.prompts.builder.StructuredPrompt.compile","title":"<code>compile() -&gt; str</code>","text":"<p>Builds the final prompt string.</p> RETURNS DESCRIPTION <code>str</code> <p>The complete formatted prompt ready for LLM consumption.</p> Source code in <code>strutex/prompts/builder.py</code> <pre><code>def compile(self) -&gt; str:\n    \"\"\"\n    Builds the final prompt string.\n\n    Returns:\n        The complete formatted prompt ready for LLM consumption.\n    \"\"\"\n    parts = [self.persona, \"\"]\n\n    if self.general_rules:\n        parts.append(\"### 1. General Principles\")\n        parts.extend([f\"- {r}\" for r in self.general_rules])\n        parts.append(\"\")\n\n    if self.field_rules:\n        parts.append(\"### 2. Field Rules\")\n        for field, rules in self.field_rules.items():\n            parts.append(f\"\\n**{field}**:\")\n            parts.extend([f\"- {r}\" for r in rules])\n        parts.append(\"\")\n\n    parts.append(\"### 3. Output Format\")\n    if self.output_guidelines:\n        parts.extend([f\"- {r}\" for r in self.output_guidelines])\n    else:\n        parts.append(\"- Output valid JSON only. No markdown.\")\n\n    return \"\\n\".join(parts)\n</code></pre>"},{"location":"api-reference/#pydantic-support","title":"Pydantic Support","text":"<p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p>"},{"location":"api-reference/#strutex.pydantic_support.pydantic_to_schema","title":"<code>pydantic_to_schema(model: Type) -&gt; Schema</code>","text":"<p>Convert a Pydantic BaseModel to a strutex Schema.</p> PARAMETER DESCRIPTION <code>model</code> <p>A Pydantic BaseModel class</p> <p> TYPE: <code>Type</code> </p> RETURNS DESCRIPTION <code>Schema</code> <p>Equivalent strutex Schema (Object)</p> Example <p>from pydantic import BaseModel</p> <p>class Invoice(BaseModel):     invoice_number: str     total: float     items: list[LineItem]</p> <p>schema = pydantic_to_schema(Invoice)</p> Source code in <code>strutex/pydantic_support.py</code> <pre><code>def pydantic_to_schema(model: Type) -&gt; Schema:\n    \"\"\"\n    Convert a Pydantic BaseModel to a strutex Schema.\n\n    Args:\n        model: A Pydantic BaseModel class\n\n    Returns:\n        Equivalent strutex Schema (Object)\n\n    Example:\n        from pydantic import BaseModel\n\n        class Invoice(BaseModel):\n            invoice_number: str\n            total: float\n            items: list[LineItem]\n\n        schema = pydantic_to_schema(Invoice)\n    \"\"\"\n    try:\n        from pydantic import BaseModel\n        from pydantic.fields import FieldInfo\n    except ImportError:\n        raise ImportError(\"Pydantic is required for pydantic_to_schema. Install with: pip install pydantic\")\n\n    if not (inspect.isclass(model) and issubclass(model, BaseModel)):\n        raise TypeError(f\"Expected Pydantic BaseModel, got {type(model)}\")\n\n    properties = {}\n    required_fields = []\n\n    # Get model fields\n    for field_name, field_info in model.model_fields.items():\n        field_type = field_info.annotation\n        description = field_info.description\n\n        # Check if required\n        if field_info.is_required():\n            required_fields.append(field_name)\n\n        # Convert type to schema\n        properties[field_name] = _python_type_to_schema(\n            field_type, \n            description=description,\n            nullable=not field_info.is_required()\n        )\n\n    return Object(\n        properties=properties,\n        description=model.__doc__,\n        required=required_fields if required_fields else None\n    )\n</code></pre>"},{"location":"api-reference/#strutex.pydantic_support.validate_with_pydantic","title":"<code>validate_with_pydantic(data: Dict[str, Any], model: Type) -&gt; Any</code>","text":"<p>Validate extracted data against a Pydantic model.</p> PARAMETER DESCRIPTION <code>data</code> <p>Extracted dictionary data</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>model</code> <p>Pydantic BaseModel class to validate against</p> <p> TYPE: <code>Type</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>Validated Pydantic model instance</p> RAISES DESCRIPTION <code>ValidationError</code> <p>If validation fails</p> Source code in <code>strutex/pydantic_support.py</code> <pre><code>def validate_with_pydantic(data: Dict[str, Any], model: Type) -&gt; Any:\n    \"\"\"\n    Validate extracted data against a Pydantic model.\n\n    Args:\n        data: Extracted dictionary data\n        model: Pydantic BaseModel class to validate against\n\n    Returns:\n        Validated Pydantic model instance\n\n    Raises:\n        pydantic.ValidationError: If validation fails\n    \"\"\"\n    try:\n        from pydantic import BaseModel\n    except ImportError:\n        raise ImportError(\"Pydantic is required. Install with: pip install pydantic\")\n\n    if not (inspect.isclass(model) and issubclass(model, BaseModel)):\n        raise TypeError(f\"Expected Pydantic BaseModel, got {type(model)}\")\n\n    return model.model_validate(data)\n</code></pre>"},{"location":"api-reference/#exceptions","title":"Exceptions","text":"<p>options: show_root_heading: true</p>"},{"location":"api-reference/#strutex.processor.SecurityError","title":"<code>SecurityError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when security validation fails.</p> <p>This exception is raised when either input validation (e.g., prompt injection detected) or output validation (e.g., leaked secrets detected) fails.</p> ATTRIBUTE DESCRIPTION <code>message</code> <p>Description of the security failure.</p> <p> </p> Example <pre><code>from strutex.processor import SecurityError\n\ntry:\n    result = processor.process(file, prompt, schema, security=True)\nexcept SecurityError as e:\n    print(f\"Security check failed: {e}\")\n</code></pre>"},{"location":"cache/","title":"Caching","text":"<p>Reduce API costs and improve response times with strutex's caching system.</p>"},{"location":"cache/#quick-start","title":"Quick Start","text":"<pre><code>from strutex import DocumentProcessor, MemoryCache, CacheKey\nfrom strutex.schemas import INVOICE_US\n\n# Create cache\ncache = MemoryCache(max_size=100, ttl=3600)  # 1 hour TTL\n\n# Create processor\nprocessor = DocumentProcessor(provider=\"gemini\")\n\n# Check cache before calling API\nkey = CacheKey.create(\"invoice.pdf\", \"Extract invoice\", INVOICE_US, \"gemini\")\nresult = cache.get(key)\n\nif result is None:\n    # Not cached - call API\n    result = processor.process(\"invoice.pdf\", \"Extract invoice\", model=INVOICE_US)\n    cache.set(key, result)\n\nprint(f\"Invoice: {result}\")\n</code></pre>"},{"location":"cache/#cache-types","title":"Cache Types","text":""},{"location":"cache/#memorycache","title":"MemoryCache","text":"<p>Fast, in-memory LRU cache. Best for single-process applications.</p> <pre><code>from strutex import MemoryCache\n\ncache = MemoryCache(\n    max_size=100,   # Max entries (LRU eviction)\n    ttl=3600        # TTL in seconds (optional)\n)\n\n# Thread-safe operations\ncache.set(key, result)\nresult = cache.get(key)\n</code></pre> <p>Features:</p> <ul> <li>LRU eviction when max_size reached</li> <li>Optional TTL (time-to-live)</li> <li>Thread-safe</li> <li>Hit/miss statistics</li> </ul>"},{"location":"cache/#sqlitecache","title":"SQLiteCache","text":"<p>Persistent cache that survives restarts. Best for durability.</p> <pre><code>from strutex import SQLiteCache\n\ncache = SQLiteCache(\n    db_path=\"~/.cache/strutex/cache.db\",\n    ttl=86400,      # 24 hour TTL\n    max_size=1000   # Optional size limit\n)\n\n# Persists across restarts\ncache.set(key, result)\n</code></pre> <p>Features:</p> <ul> <li>Persistent storage</li> <li>Automatic table creation</li> <li>Lazy TTL cleanup</li> <li>Size limits with oldest-first eviction</li> </ul>"},{"location":"cache/#filecache","title":"FileCache","text":"<p>Simple JSON file cache. Best for debugging and portability.</p> <pre><code>from strutex import FileCache\n\ncache = FileCache(\n    cache_dir=\"~/.cache/strutex/files/\",\n    ttl=3600\n)\n\n# Each entry is a separate JSON file\ncache.set(key, result)  # Creates {hash}.json\n</code></pre> <p>Features:</p> <ul> <li>One JSON file per entry</li> <li>Easy to inspect/debug</li> <li>Portable across systems</li> </ul>"},{"location":"cache/#cachekey","title":"CacheKey","text":"<p>Cache keys are computed from:</p> <ul> <li>File content hash (SHA256 of file bytes)</li> <li>Prompt hash (SHA256 of prompt text)</li> <li>Schema hash (SHA256 of schema structure)</li> <li>Provider name</li> <li>Model name (optional)</li> </ul> <pre><code>from strutex import CacheKey\n\n# Create from extraction parameters\nkey = CacheKey.create(\n    file_path=\"invoice.pdf\",\n    prompt=\"Extract invoice details\",\n    schema=INVOICE_US,\n    provider=\"gemini\",\n    model=\"gemini-2.5-flash\"\n)\n\n# Key string: \"a1b2c3:d4e5f6:g7h8i9:gemini:gemini-2.5-flash\"\nprint(key.to_string())\n</code></pre> <p>Content-based Keys</p> <p>Keys are based on file content, not filename. Same file under different names = same cache entry.</p>"},{"location":"cache/#cache-statistics","title":"Cache Statistics","text":"<p>All caches provide statistics:</p> <pre><code>stats = cache.stats()\nprint(f\"Cache size: {stats['size']}\")\nprint(f\"Hit rate: {stats['hit_rate']}%\")\nprint(f\"Hits: {stats['hits']}, Misses: {stats['misses']}\")\n</code></pre> <p>MemoryCache stats:</p> <pre><code>{\n    \"type\": \"memory\",\n    \"size\": 42,\n    \"max_size\": 100,\n    \"hits\": 150,\n    \"misses\": 20,\n    \"hit_rate\": 88.24,\n    \"ttl\": 3600\n}\n</code></pre>"},{"location":"cache/#cache-maintenance","title":"Cache Maintenance","text":""},{"location":"cache/#clear-all-entries","title":"Clear all entries","text":"<pre><code>count = cache.clear()\nprint(f\"Cleared {count} entries\")\n</code></pre>"},{"location":"cache/#clean-up-expired-entries","title":"Clean up expired entries","text":"<pre><code>count = cache.cleanup_expired()\nprint(f\"Removed {count} expired entries\")\n</code></pre>"},{"location":"cache/#vacuum-sqlite-reclaim-disk-space","title":"Vacuum SQLite (reclaim disk space)","text":"<pre><code>sqlite_cache.vacuum()\n</code></pre>"},{"location":"cache/#wrapper-pattern","title":"Wrapper Pattern","text":"<p>Create a cached processor wrapper:</p> <pre><code>class CachedProcessor:\n    def __init__(self, processor, cache):\n        self.processor = processor\n        self.cache = cache\n\n    def process(self, file_path, prompt, schema, **kwargs):\n        # Generate cache key\n        provider = self.processor.provider.__class__.__name__\n        key = CacheKey.create(file_path, prompt, schema, provider)\n\n        # Try cache first\n        result = self.cache.get(key)\n        if result is not None:\n            return result\n\n        # Call API and cache result\n        result = self.processor.process(file_path, prompt, schema=schema, **kwargs)\n        self.cache.set(key, result)\n        return result\n\n# Usage\nprocessor = DocumentProcessor(provider=\"gemini\")\ncached = CachedProcessor(processor, MemoryCache(max_size=100))\nresult = cached.process(\"invoice.pdf\", \"Extract\", INVOICE_US)\n</code></pre>"},{"location":"cache/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Choose the right cache type:</p> </li> <li> <p><code>MemoryCache</code> for speed</p> </li> <li><code>SQLiteCache</code> for persistence</li> <li> <p><code>FileCache</code> for debugging</p> </li> <li> <p>Set appropriate TTLs:</p> </li> <li> <p>Short TTL for dynamic content</p> </li> <li> <p>Long TTL for static documents</p> </li> <li> <p>Monitor hit rates:</p> </li> <li> <p>Low hit rate = check key generation</p> </li> <li> <p>High miss rate = increase cache size</p> </li> <li> <p>Clean up regularly:</p> </li> <li> <p>Call <code>cleanup_expired()</code> periodically</p> </li> <li> <p>Use <code>vacuum()</code> for SQLite after deletes</p> </li> <li> <p>Don't cache errors:</p> </li> <li>Only cache successful results</li> <li>Let failed requests retry</li> </ol>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to strutex will be documented here.</p>"},{"location":"changelog/#v081-december-26-2025","title":"v0.8.1 (December 26, 2025)","text":""},{"location":"changelog/#bug-fixes-improvements","title":"\ud83d\udc1b Bug Fixes &amp; Improvements","text":"<ul> <li>Documentation: Updated README with \"What's New\" and PyPI links.</li> <li>Coverage: Increased test coverage &gt;61% (OpenAI/Langdock tests).</li> <li>Docs: Added <code>docs/caching.md</code>.</li> </ul>"},{"location":"changelog/#v080-december-26-2025","title":"v0.8.0 (December 26, 2025)","text":""},{"location":"changelog/#new-features","title":"\ud83d\ude80 New Features","text":"<p>Core Processing Enhancements</p> <ul> <li>Async Support: <code>aprocess()</code> on <code>DocumentProcessor</code> and all Providers for high-concurrency apps.</li> <li>Batch Processing: <code>process_batch()</code> and <code>aprocess_batch()</code> for efficient multi-document handling.</li> <li>Token &amp; Cost Tracking: Usage statistics (tokens, cost) aggregated in <code>ProcessingContext</code>.</li> <li>Hybrid Fallback: <code>HybridProvider</code> robustly falls back to local PDF text extraction if LLM fails.</li> <li>Verification: <code>verify()</code> method and <code>process(verify=True)</code> for LLM-based self-correction and auditing of results.</li> </ul> <p>Cache System</p> <ul> <li><code>MemoryCache</code> \u2014 In-memory LRU cache with TTL and thread-safety</li> <li><code>SQLiteCache</code> \u2014 Persistent SQLite-based cache with lazy cleanup</li> <li><code>FileCache</code> \u2014 Simple file-based JSON cache for debugging</li> <li><code>CacheKey</code> \u2014 Smart hashing of file content + prompt + schema + provider</li> <li>Cache statistics tracking (hits, misses, hit rate)</li> <li>Automatic expiration and cleanup</li> </ul> <p>Processing Context</p> <ul> <li><code>ProcessingContext</code> \u2014 State management for multi-step workflows</li> <li><code>BatchContext</code> \u2014 Progress tracking for batch processing</li> <li>Extraction history with timing and error tracking</li> <li>Step listeners for monitoring and logging</li> <li>Serialization for debugging and persistence</li> </ul> <p>Streaming Support</p> <ul> <li><code>StreamingProcessor</code> \u2014 Real-time response streaming</li> <li><code>StreamChunk</code> \u2014 Typed streaming chunks</li> <li><code>stream_to_string()</code> / <code>stream_with_callback()</code> utilities</li> <li>Async streaming support</li> </ul>"},{"location":"changelog/#new-files","title":"\ud83d\udcc1 New Files","text":"<ul> <li><code>strutex/extractors/pdf.py</code> \u2014 PDF Extractor (pdfplumber)</li> <li><code>strutex/providers/hybrid.py</code> \u2014 Hybrid Provider</li> <li><code>strutex/cache/__init__.py</code> \u2014 Cache module</li> <li><code>strutex/cache/base.py</code> \u2014 Cache interface and CacheKey</li> <li><code>strutex/cache/memory.py</code> \u2014 MemoryCache</li> <li><code>strutex/cache/sqlite.py</code> \u2014 SQLiteCache</li> <li><code>strutex/cache/file.py</code> \u2014 FileCache</li> <li><code>strutex/context.py</code> \u2014 ProcessingContext and BatchContext</li> <li><code>strutex/providers/streaming.py</code> \u2014 Streaming support</li> <li><code>docs/cache.md</code> \u2014 Caching documentation</li> <li><code>docs/context.md</code> \u2014 Context documentation</li> <li><code>docs/streaming.md</code> \u2014 Streaming documentation</li> <li><code>examples/caching_example.py</code></li> <li><code>examples/context_example.py</code></li> </ul>"},{"location":"changelog/#v070-december-26-2025","title":"v0.7.0 (December 26, 2025)","text":""},{"location":"changelog/#new-features_1","title":"\ud83d\ude80 New Features","text":"<p>Multi-Provider Support</p> <ul> <li><code>OpenAIProvider</code> \u2014 GPT-4o and GPT-4 Vision support</li> <li><code>AnthropicProvider</code> \u2014 Claude 3.5 Sonnet and Claude 3 Opus</li> <li><code>OllamaProvider</code> \u2014 Local models via Ollama (free, air-gapped)</li> <li><code>GroqProvider</code> \u2014 Ultra-fast inference at low cost</li> </ul> <p>Provider Chains</p> <ul> <li><code>ProviderChain</code> \u2014 Automatic fallback between providers</li> <li><code>local_first_chain()</code> \u2014 Ollama \u2192 Gemini \u2192 OpenAI</li> <li><code>cost_optimized_chain()</code> \u2014 Providers ordered by cost</li> <li><code>create_fallback_chain()</code> \u2014 Quick chain creation</li> <li>Fallback callbacks for monitoring</li> <li><code>last_provider</code> property for tracking</li> </ul> <p>Retry Infrastructure</p> <ul> <li><code>RetryConfig</code> \u2014 Configurable retry with exponential backoff</li> <li><code>with_retry()</code> decorator for sync/async functions</li> <li><code>RateLimiter</code> \u2014 Simple rate limiting for API calls</li> </ul>"},{"location":"changelog/#new-files_1","title":"\ud83d\udcc1 New Files","text":"<ul> <li><code>strutex/providers/openai.py</code> \u2014 OpenAI provider</li> <li><code>strutex/providers/anthropic.py</code> \u2014 Anthropic provider</li> <li><code>strutex/providers/ollama.py</code> \u2014 Ollama provider</li> <li><code>strutex/providers/groq.py</code> \u2014 Groq provider</li> <li><code>strutex/providers/chain.py</code> \u2014 Provider chain</li> <li><code>strutex/providers/retry.py</code> \u2014 Retry utilities</li> <li><code>docs/providers.md</code> \u2014 Updated provider documentation</li> <li><code>docs/provider-chains.md</code> \u2014 Chain documentation</li> <li><code>examples/provider_chain_example.py</code></li> </ul>"},{"location":"changelog/#v060-december-26-2025","title":"v0.6.0 (December 26, 2025)","text":""},{"location":"changelog/#new-features_2","title":"\ud83d\ude80 New Features","text":"<p>Built-in Schemas Module</p> <ul> <li>9 ready-to-use Pydantic schemas for common document types:</li> <li><code>INVOICE_GENERIC</code>, <code>INVOICE_US</code>, <code>INVOICE_EU</code></li> <li><code>RECEIPT</code>, <code>PURCHASE_ORDER</code>, <code>BILL_OF_LADING</code></li> <li><code>BANK_STATEMENT</code>, <code>RESUME</code>, <code>CONTRACT_CLAUSE</code></li> <li>One-line imports: <code>from strutex.schemas import INVOICE_US</code></li> <li>Schema inheritance for customization</li> </ul> <p>Logging Module</p> <ul> <li><code>strutex.logging</code> module with standardized logging</li> <li><code>get_logger()</code>, <code>configure_logging()</code>, <code>set_level()</code></li> <li>Environment variable support: <code>STRUTEX_LOG_LEVEL</code></li> </ul> <p>CI/CD Improvements</p> <ul> <li>pytest-cov for coverage reporting</li> <li>Codecov integration</li> <li>mypy type checking (non-blocking)</li> <li>Coverage badge in README</li> </ul>"},{"location":"changelog/#new-files_2","title":"\ud83d\udcc1 New Files","text":"<ul> <li><code>strutex/schemas/__init__.py</code> \u2014 Schema exports</li> <li><code>strutex/schemas/invoice.py</code> \u2014 Invoice schemas</li> <li><code>strutex/schemas/receipt.py</code> \u2014 Receipt schema</li> <li><code>strutex/schemas/purchase_order.py</code> \u2014 PO schema</li> <li><code>strutex/schemas/shipping.py</code> \u2014 Bill of Lading</li> <li><code>strutex/schemas/financial.py</code> \u2014 Bank Statement</li> <li><code>strutex/schemas/resume.py</code> \u2014 Resume schema</li> <li><code>strutex/schemas/legal.py</code> \u2014 Contract clauses</li> <li><code>strutex/logging.py</code> \u2014 Logging module</li> <li><code>docs/schemas.md</code> \u2014 Schema documentation</li> <li><code>examples/schemas_example.py</code></li> </ul>"},{"location":"changelog/#v030-december-23-2025","title":"v0.3.0 (December 23, 2025)","text":""},{"location":"changelog/#new-features_3","title":"\ud83d\ude80 New Features","text":"<p>Plugin System v2</p> <ul> <li>Lazy Loading: Plugins are only imported when first used via <code>PluginRegistry.get()</code>, improving startup time</li> <li>Entry Points: Register plugins via <code>pyproject.toml</code> entry points (recommended over <code>@register</code> decorator)</li> <li>API Versioning: All plugins have <code>strutex_plugin_version = \"1.0\"</code> attribute for compatibility checks</li> <li>Priority Ordering: Plugins declare <code>priority</code> (0-100) for waterfall ordering; higher = preferred</li> <li>Cost Hints: Plugins declare <code>cost</code> for optimization; lower = cheaper</li> <li>Health Checks: All base classes have <code>health_check()</code> classmethod</li> <li>Protocol Types: <code>ProviderProtocol</code>, <code>ValidatorProtocol</code>, etc. for mypy-compatible type checking</li> <li>Discovery Caching: Plugin discovery cached in <code>~/.cache/strutex/plugins.json</code>, invalidated on pip changes</li> <li>Sandboxed Probing: <code>sandbox.py</code> for safely probing untrusted plugins in subprocess</li> </ul> <p>CLI Tooling</p> <ul> <li><code>strutex plugins list</code> \u2014 Show all discovered plugins with health status</li> <li><code>strutex plugins list --type provider</code> \u2014 Filter by plugin type</li> <li><code>strutex plugins list --json</code> \u2014 JSON output for scripting</li> <li><code>strutex plugins info &lt;name&gt; --type &lt;type&gt;</code> \u2014 Detailed plugin info</li> <li><code>strutex plugins refresh</code> \u2014 Re-scan entry points and refresh cache</li> <li><code>strutex plugins cache</code> \u2014 Show/clear discovery cache</li> </ul> <p>Pluggy Hooks</p> <ul> <li><code>@hookimpl</code> decorator for pipeline extension</li> <li><code>strutex_pre_process</code> \u2014 Called before document processing</li> <li><code>strutex_post_process</code> \u2014 Called after processing, can transform results</li> <li><code>strutex_on_error</code> \u2014 Called on failure for error recovery</li> </ul> <p>Documentation</p> <ul> <li>Versioned documentation with mike</li> <li>Version selector dropdown in docs</li> <li>Automated docs deployment via GitHub Actions</li> <li>New changelog page</li> </ul>"},{"location":"changelog/#new-files_3","title":"\ud83d\udcc1 New Files","text":"<ul> <li><code>strutex/plugins/protocol.py</code> \u2014 Protocol-typed interfaces</li> <li><code>strutex/plugins/hooks.py</code> \u2014 Pluggy hook specifications</li> <li><code>strutex/plugins/discovery.py</code> \u2014 Cached plugin discovery</li> <li><code>strutex/plugins/sandbox.py</code> \u2014 Subprocess plugin probing</li> <li><code>strutex/cli.py</code> \u2014 CLI commands</li> <li><code>tests/test_plugin_contract.py</code> \u2014 Contract tests for plugins</li> <li><code>tests/test_v030_features.py</code> \u2014 v0.3.0 feature tests</li> <li><code>.github/workflows/docs.yml</code> \u2014 Automated docs deployment</li> <li><code>docs/changelog.md</code> \u2014 This changelog</li> <li><code>docs/hooks.md</code> \u2014 Hooks system documentation</li> <li><code>docs/cli.md</code> \u2014 CLI commands documentation</li> </ul>"},{"location":"changelog/#updated-files","title":"\u270f\ufe0f Updated Files","text":"<ul> <li><code>strutex/plugins/registry.py</code> \u2014 Complete rewrite for lazy loading</li> <li><code>strutex/plugins/base.py</code> \u2014 Added version, priority, cost, health_check to all base classes</li> <li><code>strutex/plugins/__init__.py</code> \u2014 Export new v2 modules</li> <li><code>strutex/providers/gemini.py</code> \u2014 Added v2 attributes, removed deprecated decorator</li> <li><code>pyproject.toml</code> \u2014 Added pluggy, click, mike; added CLI entry point</li> <li><code>mkdocs.yml</code> \u2014 Added version selector config</li> <li><code>docs/plugins.md</code> \u2014 Rewritten for v0.3.0 features</li> <li><code>examples/plugin_example.py</code> \u2014 Updated to showcase v2 features</li> </ul>"},{"location":"changelog/#deprecations","title":"\u26a0\ufe0f Deprecations","text":"<ul> <li><code>@register</code> decorator now emits <code>DeprecationWarning</code></li> <li>Use entry points in <code>pyproject.toml</code> instead:     <pre><code>[project.entry-points.\"strutex.providers\"]\nmy_provider = \"my_package:MyProvider\"\n</code></pre></li> </ul>"},{"location":"changelog/#new-dependencies","title":"\ud83d\udce6 New Dependencies","text":"<ul> <li><code>pluggy ^1.5.0</code> \u2014 Hook system (battle-tested, from pytest team)</li> <li><code>click ^8.1.0</code> \u2014 CLI framework</li> <li><code>mike ^2.1.0</code> \u2014 Documentation versioning (dev dependency)</li> </ul>"},{"location":"changelog/#v020","title":"v0.2.0","text":""},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Plugin registry system with <code>@register</code> decorator</li> <li>Security plugins: <code>InputSanitizer</code>, <code>PromptInjectionDetector</code>, <code>OutputValidator</code></li> <li>Composable <code>SecurityChain</code></li> <li>Pydantic model support for schemas</li> <li>Base classes: <code>Provider</code>, <code>Extractor</code>, <code>Validator</code>, <code>Postprocessor</code>, <code>SecurityPlugin</code></li> </ul>"},{"location":"changelog/#v010","title":"v0.1.0","text":""},{"location":"changelog/#initial-release","title":"Initial Release","text":"<ul> <li>Google Gemini provider</li> <li>Custom schema types (<code>Object</code>, <code>String</code>, <code>Number</code>, <code>Array</code>, <code>Boolean</code>)</li> <li>PDF text extraction with waterfall fallback (pypdf \u2192 pdfplumber \u2192 pdfminer \u2192 OCR)</li> <li>Excel/spreadsheet support</li> <li>MIME type detection</li> <li><code>StructuredPrompt</code> fluent builder API</li> </ul>"},{"location":"cli/","title":"CLI Commands","text":"<p>Manage plugins and inspect strutex from the command line.</p> <p>Requires cli extra</p> <p><code>bash     pip install strutex[cli]</code></p>"},{"location":"cli/#plugin-commands","title":"Plugin Commands","text":""},{"location":"cli/#list-plugins","title":"List Plugins","text":"<pre><code># List all plugins\nstrutex plugins list\n\n# Filter by type\nstrutex plugins list --type provider\n\n# JSON output for scripting\nstrutex plugins list --json\n\n# Only show loaded plugins\nstrutex plugins list --loaded-only\n</code></pre> <p>Output:</p> <pre><code>PROVIDERS\n----------------------------------------\n  \u2713 \u25cf gemini               v1.0      priority: 50\n       \u2514\u2500 capabilities: vision\n\nVALIDATORS\n----------------------------------------\n  \u2713 \u25cb invoice_validator    v1.0      priority: 60\n</code></pre> <p>Legend:</p> <ul> <li><code>\u2713</code> = healthy, <code>\u2717</code> = unhealthy, <code>?</code> = unknown</li> <li><code>\u25cf</code> = loaded, <code>\u25cb</code> = not loaded (lazy)</li> </ul>"},{"location":"cli/#plugin-info","title":"Plugin Info","text":"<pre><code># Get detailed info about a plugin\nstrutex plugins info gemini --type provider\n\n# JSON output\nstrutex plugins info gemini --type provider --json\n</code></pre> <p>Output:</p> <pre><code>Plugin: gemini\n----------------------------------------\n  version        : 1.0\n  priority       : 50\n  cost           : 1.0\n  capabilities   : vision\n  loaded         : True\n  healthy        : True\n</code></pre>"},{"location":"cli/#refresh-discovery","title":"Refresh Discovery","text":"<pre><code># Re-scan entry points and refresh cache\nstrutex plugins refresh\n</code></pre> <p>Use after:</p> <ul> <li>Installing new plugins with pip</li> <li>Updating plugin packages</li> <li>Modifying entry points</li> </ul>"},{"location":"cli/#cache-management","title":"Cache Management","text":"<pre><code># Show cache status\nstrutex plugins cache\n\n# Clear the cache\nstrutex plugins cache --clear\n</code></pre> <p>Output:</p> <pre><code>Cache file: /home/user/.cache/strutex/plugins.json\nCache valid: True\nCached plugins: 5\n</code></pre>"},{"location":"cli/#examples","title":"Examples","text":""},{"location":"cli/#find-all-providers","title":"Find All Providers","text":"<pre><code>strutex plugins list --type provider --json | jq '.provider[].name'\n</code></pre>"},{"location":"cli/#check-plugin-health","title":"Check Plugin Health","text":"<pre><code>strutex plugins info gemini -t provider --json | jq '.healthy'\n</code></pre>"},{"location":"cli/#list-high-priority-plugins","title":"List High-Priority Plugins","text":"<pre><code>strutex plugins list --json | jq '.provider | sort_by(.priority) | reverse'\n</code></pre>"},{"location":"cli/#programmatic-equivalent","title":"Programmatic Equivalent","text":"<p>Every CLI command has a Python equivalent:</p> CLI Python <code>strutex plugins list</code> <code>PluginRegistry.list_names(\"provider\")</code> <code>strutex plugins info X</code> <code>PluginRegistry.get_plugin_info(\"provider\", \"X\")</code> <code>strutex plugins refresh</code> <code>PluginRegistry.discover(force=True)</code> <code>strutex plugins cache --clear</code> <code>PluginDiscovery.clear_cache()</code> <pre><code>from strutex.plugins import PluginRegistry\nfrom strutex.plugins.discovery import PluginDiscovery\n\n# List all providers\nfor name in PluginRegistry.list_names(\"provider\"):\n    info = PluginRegistry.get_plugin_info(\"provider\", name)\n    print(f\"{name}: priority={info['priority']}\")\n\n# Clear cache\nPluginDiscovery.clear_cache()\n</code></pre>"},{"location":"context/","title":"Processing Context","text":"<p>Share state across multi-step document workflows with <code>ProcessingContext</code>.</p>"},{"location":"context/#quick-start","title":"Quick Start","text":"<pre><code>from strutex import DocumentProcessor, ProcessingContext\nfrom strutex.schemas import INVOICE_US, RECEIPT\n\nprocessor = DocumentProcessor(provider=\"gemini\")\nctx = ProcessingContext()\n\n# First extraction\ninvoice = ctx.extract(processor, \"invoice.pdf\", \"Extract invoice\", INVOICE_US)\n\n# Store state for use in next step\nctx.set(\"expected_total\", invoice.total)\n\n# Second extraction using stored state\nreceipt = ctx.extract(\n    processor,\n    \"receipt.jpg\",\n    f\"Verify receipt total matches {ctx.get('expected_total')}\",\n    RECEIPT\n)\n\n# Check results\nprint(f\"Processed {len(ctx.history)} documents\")\nprint(f\"Total time: {ctx.total_duration_ms:.0f}ms\")\n</code></pre>"},{"location":"context/#state-management","title":"State Management","text":"<p>Store and retrieve values across extraction steps:</p> <pre><code>ctx = ProcessingContext()\n\n# Store values\nctx.set(\"vendor_id\", \"ACME-001\")\nctx.set(\"items\", [\"item1\", \"item2\"])\n\n# Retrieve values\nvendor = ctx.get(\"vendor_id\")\nitems = ctx.get(\"items\", default=[])\n\n# Check if key exists\nif ctx.has(\"vendor_id\"):\n    print(\"Vendor ID found\")\n\n# Update multiple values\nctx.update({\n    \"total\": 1500.00,\n    \"currency\": \"USD\"\n})\n\n# Get all state\nstate = ctx.state  # Returns copy\n</code></pre>"},{"location":"context/#extraction-history","title":"Extraction History","text":"<p>Every extraction is recorded:</p> <pre><code># Perform extractions\nctx.extract(processor, \"doc1.pdf\", \"Extract\", schema1)\nctx.extract(processor, \"doc2.pdf\", \"Extract\", schema2)\n\n# Access history\nfor step in ctx.history:\n    print(f\"Step {step.step_id}:\")\n    print(f\"  File: {step.file_path}\")\n    print(f\"  Provider: {step.provider}\")\n    print(f\"  Duration: {step.duration_ms:.0f}ms\")\n    print(f\"  Success: {step.result is not None}\")\n</code></pre>"},{"location":"context/#extractionstep-fields","title":"ExtractionStep Fields","text":"Field Type Description <code>step_id</code> str Unique step identifier <code>file_path</code> str Document path <code>prompt</code> str Extraction prompt (truncated) <code>provider</code> str Provider class name <code>result</code> Any Extraction result (or None) <code>error</code> str Error message (or None) <code>duration_ms</code> float Processing time <code>timestamp</code> str ISO timestamp"},{"location":"context/#metrics","title":"Metrics","text":"<pre><code># Aggregate metrics\nprint(f\"Total duration: {ctx.total_duration_ms:.0f}ms\")\nprint(f\"Success count: {ctx.success_count}\")\nprint(f\"Error count: {ctx.error_count}\")\n\n# Get last result\nlast = ctx.last_result\nprint(f\"Last result: {last}\")\n\n# Get all successful results\nall_results = ctx.get_results()\n</code></pre>"},{"location":"context/#step-listeners","title":"Step Listeners","text":"<p>Get notified after each extraction:</p> <pre><code>def log_step(step):\n    if step.error:\n        print(f\"\u274c {step.file_path} failed: {step.error}\")\n    else:\n        print(f\"\u2705 {step.file_path} completed in {step.duration_ms:.0f}ms\")\n\nctx = ProcessingContext()\nctx.on_step(log_step)\n\n# Listener called after each extraction\nctx.extract(processor, \"doc.pdf\", \"Extract\", schema)\n# Output: \u2705 doc.pdf completed in 2150ms\n</code></pre>"},{"location":"context/#batch-processing","title":"Batch Processing","text":"<p>For processing multiple documents, use <code>BatchContext</code>:</p> <pre><code>from strutex import BatchContext\nimport os\n\n# Get list of files\npdf_files = [f for f in os.listdir(\".\") if f.endswith(\".pdf\")]\n\n# Create batch context\nctx = BatchContext(total_documents=len(pdf_files))\n\nfor pdf in pdf_files:\n    try:\n        result = ctx.extract(processor, pdf, \"Extract invoice\", INVOICE_US)\n        ctx.set(pdf, result.invoice_number)\n    except Exception as e:\n        print(f\"Failed: {pdf}\")\n\n    # Progress tracking\n    print(f\"Progress: {ctx.progress}/{ctx.total_documents} ({ctx.progress_percent:.1f}%)\")\n    print(f\"Success rate: {ctx.success_rate:.1f}%\")\n    print(f\"Avg time: {ctx.average_duration_ms:.0f}ms\")\n    print(f\"ETA: {ctx.estimated_remaining_ms / 1000:.0f}s\")\n\n# Final summary\nprint(f\"\\nCompleted: {ctx.success_count}/{ctx.total_documents}\")\n</code></pre>"},{"location":"context/#batchcontext-properties","title":"BatchContext Properties","text":"Property Description <code>progress</code> Documents processed so far <code>progress_percent</code> Progress as percentage <code>success_rate</code> Success rate as percentage <code>average_duration_ms</code> Average time per document <code>estimated_remaining_ms</code> Estimated time remaining"},{"location":"context/#async-support","title":"Async Support","text":"<pre><code>import asyncio\n\nasync def batch_extract():\n    ctx = ProcessingContext()\n\n    for pdf in pdf_files:\n        result = await ctx.aextract(\n            processor, pdf, \"Extract\", INVOICE_US\n        )\n        print(f\"Extracted: {result.invoice_number}\")\n\n    return ctx.get_results()\n\nresults = asyncio.run(batch_extract())\n</code></pre>"},{"location":"context/#serialization","title":"Serialization","text":"<p>Export context for logging/persistence:</p> <pre><code># Serialize to dict\ndata = ctx.to_dict()\n\n# Contains:\n# - context_id\n# - metadata\n# - state\n# - history (list of steps)\n# - created_at\n# - total_duration_ms\n# - success_count\n# - error_count\n\nimport json\nprint(json.dumps(data, indent=2, default=str))\n</code></pre>"},{"location":"context/#best-practices","title":"Best Practices","text":"<ol> <li>Use meaningful context IDs:</li> </ol> <pre><code>ctx = ProcessingContext(context_id=\"invoice-batch-2024-01\")\n</code></pre> <ol> <li>Store intermediate results:</li> </ol> <pre><code>ctx.set(\"step1_result\", result1)\n# Use in later steps\nprevious = ctx.get(\"step1_result\")\n</code></pre> <ol> <li>Add listeners for monitoring:</li> </ol> <pre><code>ctx.on_step(lambda s: log_to_monitoring(s))\n</code></pre> <ol> <li> <p>Use BatchContext for multiple documents:</p> </li> <li> <p>Get progress tracking for free</p> </li> <li> <p>Estimate completion time</p> </li> <li> <p>Export history for debugging: <pre><code>with open(\"context.json\", \"w\") as f:\n    json.dump(ctx.to_dict(), f, default=str)\n</code></pre></p> </li> </ol>"},{"location":"extractors/","title":"Extractors","text":"<p>Extract text from documents for LLM processing.</p>"},{"location":"extractors/#overview","title":"Overview","text":"<p>Extractors convert document files (PDF, images, spreadsheets) into text that can be sent to an LLM.</p> <pre><code>from strutex import PDFExtractor, get_extractor\n\n# Direct usage\nextractor = PDFExtractor()\ntext = extractor.extract(\"invoice.pdf\")\n\n# Auto-select by MIME type\nextractor = get_extractor(\"application/pdf\")\ntext = extractor.extract(\"invoice.pdf\")\n</code></pre>"},{"location":"extractors/#built-in-extractors","title":"Built-in Extractors","text":""},{"location":"extractors/#pdfextractor","title":"PDFExtractor","text":"<p>Uses a waterfall strategy: pypdf \u2192 pdfplumber \u2192 pdfminer \u2192 OCR.</p> <pre><code>from strutex import PDFExtractor\n\nextractor = PDFExtractor()\ntext = extractor.extract(\"document.pdf\")\n</code></pre>"},{"location":"extractors/#imageextractor","title":"ImageExtractor","text":"<p>Uses Tesseract OCR. Requires <code>pytesseract</code> and <code>PIL</code>.</p> <pre><code>from strutex import ImageExtractor\n\nextractor = ImageExtractor()\ntext = extractor.extract(\"scan.png\")\n</code></pre> <p>OCR Dependencies</p> <p>Install with: <code>pip install strutex[ocr]</code></p>"},{"location":"extractors/#excelextractor","title":"ExcelExtractor","text":"<p>Converts spreadsheets to CSV text representation.</p> <pre><code>from strutex import ExcelExtractor\n\nextractor = ExcelExtractor()\ntext = extractor.extract(\"data.xlsx\")\n</code></pre>"},{"location":"extractors/#auto-selection","title":"Auto-Selection","text":"<p>Use <code>get_extractor()</code> to automatically select based on MIME type:</p> <pre><code>from strutex import get_extractor\nfrom strutex.documents import get_mime_type\n\nmime_type = get_mime_type(\"file.pdf\")\nextractor = get_extractor(mime_type)\ntext = extractor.extract(\"file.pdf\")\n</code></pre>"},{"location":"extractors/#creating-custom-extractors","title":"Creating Custom Extractors","text":"<pre><code>from strutex.plugins import Extractor\n\nclass XMLExtractor(Extractor, name=\"xml\"):\n    mime_types = [\"application/xml\", \"text/xml\"]\n\n    def extract(self, file_path: str) -&gt; str:\n        import xml.etree.ElementTree as ET\n        tree = ET.parse(file_path)\n        return ET.tostring(tree.getroot(), encoding=\"unicode\")\n\n    def can_handle(self, mime_type: str) -&gt; bool:\n        return mime_type in self.mime_types\n</code></pre>"},{"location":"extractors/#api-reference","title":"API Reference","text":"<p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p>"},{"location":"extractors/#strutex.extractors.PDFExtractor","title":"<code>PDFExtractor</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extracts text from PDF files using pdfplumber.</p> <p>Robust fallback when multimodal LLM processing fails.</p>"},{"location":"extractors/#strutex.extractors.PDFExtractor.extract","title":"<code>extract(file_path: str) -&gt; str</code>","text":"<p>Extract text from a PDF file.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>Path to the PDF file</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Extracted text content from all pages</p> Source code in <code>strutex/extractors/pdf.py</code> <pre><code>def extract(self, file_path: str) -&gt; str:\n    \"\"\"\n    Extract text from a PDF file.\n\n    Args:\n        file_path: Path to the PDF file\n\n    Returns:\n        Extracted text content from all pages\n    \"\"\"\n    if not PDFPLUMBER_AVAILABLE:\n        raise ImportError(\"pdfplumber is required for PDFExtractor. Install with: pip install pdfplumber\")\n\n    text_content = []\n    try:\n        with pdfplumber.open(file_path) as pdf:\n            for i, page in enumerate(pdf.pages):\n                page_text = page.extract_text()\n                if page_text:\n                    text_content.append(f\"--- Page {i+1} ---\\n{page_text}\")\n\n        return \"\\n\\n\".join(text_content)\n\n    except Exception as e:\n        logger.error(f\"Failed to extract text from {file_path}: {e}\")\n        raise RuntimeError(f\"PDF extraction failed: {e}\") from e\n</code></pre>"},{"location":"extractors/#strutex.extractors.ImageExtractor","title":"<code>ImageExtractor</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Image extractor using Tesseract OCR.</p> <p>Requires pytesseract and PIL to be installed. Install with: pip install strutex[ocr]</p> ATTRIBUTE DESCRIPTION <code>mime_types</code> <p>MIME types this extractor handles</p> <p> </p> <code>priority</code> <p>Extraction priority</p> <p> </p>"},{"location":"extractors/#strutex.extractors.ImageExtractor.can_handle","title":"<code>can_handle(mime_type: str) -&gt; bool</code>","text":"<p>Check if this extractor can handle the given MIME type.</p> Source code in <code>strutex/extractors/image.py</code> <pre><code>def can_handle(self, mime_type: str) -&gt; bool:\n    \"\"\"Check if this extractor can handle the given MIME type.\"\"\"\n    return mime_type in self.mime_types\n</code></pre>"},{"location":"extractors/#strutex.extractors.ImageExtractor.extract","title":"<code>extract(file_path: str) -&gt; str</code>","text":"<p>Extract text from an image using OCR.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>Path to the image file</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Extracted text content</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If OCR dependencies are not installed</p> Source code in <code>strutex/extractors/image.py</code> <pre><code>def extract(self, file_path: str) -&gt; str:\n    \"\"\"\n    Extract text from an image using OCR.\n\n    Args:\n        file_path: Path to the image file\n\n    Returns:\n        Extracted text content\n\n    Raises:\n        RuntimeError: If OCR dependencies are not installed\n    \"\"\"\n    if not _OCR_AVAILABLE:\n        raise RuntimeError(\n            \"OCR dependencies not installed. \"\n            \"Install with: pip install strutex[ocr]\"\n        )\n\n    try:\n        image = Image.open(file_path)\n        text = pytesseract.image_to_string(image)\n        return text.strip()\n    except Exception as e:\n        logger.error(f\"OCR extraction failed for {file_path}: {e}\")\n        raise RuntimeError(f\"Failed to extract text from image: {e}\")\n</code></pre>"},{"location":"extractors/#strutex.extractors.ImageExtractor.health_check","title":"<code>health_check() -&gt; bool</code>  <code>classmethod</code>","text":"<p>Check if OCR dependencies are available.</p> Source code in <code>strutex/extractors/image.py</code> <pre><code>@classmethod\ndef health_check(cls) -&gt; bool:\n    \"\"\"Check if OCR dependencies are available.\"\"\"\n    return _OCR_AVAILABLE\n</code></pre>"},{"location":"extractors/#strutex.extractors.ExcelExtractor","title":"<code>ExcelExtractor</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Excel and spreadsheet extractor.</p> <p>Converts spreadsheet data to a text representation suitable for LLM processing.</p> ATTRIBUTE DESCRIPTION <code>mime_types</code> <p>MIME types this extractor handles</p> <p> </p> <code>priority</code> <p>Extraction priority</p> <p> </p>"},{"location":"extractors/#strutex.extractors.ExcelExtractor.can_handle","title":"<code>can_handle(mime_type: str) -&gt; bool</code>","text":"<p>Check if this extractor can handle the given MIME type.</p> Source code in <code>strutex/extractors/excel.py</code> <pre><code>def can_handle(self, mime_type: str) -&gt; bool:\n    \"\"\"Check if this extractor can handle the given MIME type.\"\"\"\n    return mime_type in self.mime_types\n</code></pre>"},{"location":"extractors/#strutex.extractors.ExcelExtractor.extract","title":"<code>extract(file_path: str) -&gt; str</code>","text":"<p>Extract text from a spreadsheet file.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>Path to the spreadsheet file</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Text representation of the spreadsheet data</p> Source code in <code>strutex/extractors/excel.py</code> <pre><code>def extract(self, file_path: str) -&gt; str:\n    \"\"\"\n    Extract text from a spreadsheet file.\n\n    Args:\n        file_path: Path to the spreadsheet file\n\n    Returns:\n        Text representation of the spreadsheet data\n    \"\"\"\n    from ..documents.spreadsheet import spreadsheet_to_text\n    return spreadsheet_to_text(file_path)\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>pip install strutex\n</code></pre>"},{"location":"getting-started/#optional-dependencies","title":"Optional Dependencies","text":"OCR SupportAll Features <pre><code>pip install strutex[ocr]\n</code></pre> <pre><code>pip install strutex[ocr] pydantic\n</code></pre>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/#1-define-your-schema","title":"1. Define Your Schema","text":"<pre><code>from strutex import Object, String, Number, Array\n\nschema = Object(\n    description=\"Invoice data\",\n    properties={\n        \"invoice_number\": String(description=\"The invoice ID\"),\n        \"date\": String(description=\"Invoice date\"),\n        \"total\": Number(description=\"Total amount\"),\n        \"items\": Array(\n            items=Object(\n                properties={\n                    \"description\": String(),\n                    \"amount\": Number()\n                }\n            )\n        )\n    }\n)\n</code></pre>"},{"location":"getting-started/#2-create-a-processor","title":"2. Create a Processor","text":"<pre><code>from strutex import DocumentProcessor\n\nprocessor = DocumentProcessor(\n    provider=\"gemini\",\n    model_name=\"gemini-2.5-flash\"\n    # api_key=\"...\"  # Or set GOOGLE_API_KEY env var\n)\n</code></pre>"},{"location":"getting-started/#3-process-a-document","title":"3. Process a Document","text":"<pre><code>result = processor.process(\n    file_path=\"invoice.pdf\",\n    prompt=\"Extract all invoice data.\",\n    schema=schema\n)\n\nprint(f\"Invoice: {result['invoice_number']}\")\nprint(f\"Total: ${result['total']}\")\n</code></pre>"},{"location":"getting-started/#environment-variables","title":"Environment Variables","text":"Variable Description <code>GOOGLE_API_KEY</code> Google Gemini API key <code>OPENAI_API_KEY</code> OpenAI API key (future)"},{"location":"getting-started/#supported-file-types","title":"Supported File Types","text":"Format Extensions Notes PDF <code>.pdf</code> Native support, OCR fallback Images <code>.png</code>, <code>.jpg</code>, <code>.tiff</code> Vision-capable model Excel <code>.xlsx</code>, <code>.xls</code> Converted to text Text <code>.txt</code>, <code>.csv</code> Direct input"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Schema Types \u2014 Learn all available types</li> <li>Prompt Builder \u2014 Build structured prompts</li> <li>Plugin System \u2014 Extend with custom plugins</li> <li>Security \u2014 Add input/output protection</li> </ul>"},{"location":"hooks/","title":"Hooks System","text":"<p>Extend the strutex processing pipeline without modifying core components.</p> <p>New in v0.4.2</p> <p>Callback and decorator hooks \u2014 No pluggy knowledge required! Use simple callbacks or decorators directly on <code>DocumentProcessor</code>.</p>"},{"location":"hooks/#plugins-vs-hooks","title":"Plugins vs Hooks","text":"<p>Before diving in, understand the distinction:</p> Plugins (Provider, Validator, etc.) Hooks (pre_process, post_process) Role core components \u2014 do the actual work Monitors \u2014 observe without replacing Pattern Strategy (replace engine) Observer (wrap engine) Quantity One at a time Many simultaneously Use case \"Use OpenAI instead of Gemini\" \"Log every request and add timestamps\" <p>Rule of thumb:</p> <ul> <li>Changing what runs? \u2192 Plugin</li> <li>Observing when things run? \u2192 Hook</li> </ul>"},{"location":"hooks/#quick-start-recommended","title":"Quick Start (Recommended)","text":"CallbacksDecorators <pre><code>from strutex import DocumentProcessor\n\nprocessor = DocumentProcessor(\n    on_pre_process=lambda fp, prompt, schema, mime, ctx: {\n        \"prompt\": prompt + \"\\nBe precise.\"\n    },\n    on_post_process=lambda result, ctx: {\n        **result, \"processed\": True\n    },\n    on_error=lambda error, fp, ctx: {\n        \"status\": \"error\", \"message\": str(error)\n    }\n)\n</code></pre> <pre><code>from strutex import DocumentProcessor\nfrom datetime import datetime\n\nprocessor = DocumentProcessor()\n\n@processor.on_post_process\ndef add_timestamp(result, context):\n    result[\"processed_at\"] = datetime.now().isoformat()\n    return result\n\n@processor.on_pre_process\ndef add_instructions(file_path, prompt, schema, mime_type, context):\n    return {\"prompt\": prompt + \"\\nExtract all values precisely.\"}\n\n@processor.on_error\ndef handle_rate_limit(error, file_path, context):\n    if \"rate limit\" in str(error).lower():\n        return {\"error\": \"Rate limited, please retry later\"}\n    return None  # Propagate other errors\n</code></pre>"},{"location":"hooks/#hook-types","title":"Hook Types","text":"Hook Called Receives Returns <code>on_pre_process</code> Before processing <code>(file_path, prompt, schema, mime_type, context)</code> <code>{\"prompt\": ...}</code> or <code>None</code> <code>on_post_process</code> After processing <code>(result, context)</code> Modified result or <code>None</code> <code>on_error</code> On exception <code>(error, file_path, context)</code> Fallback result or <code>None</code>"},{"location":"hooks/#callbacks-vs-decorators","title":"Callbacks vs Decorators","text":"Approach Best For Callbacks Quick, inline transformations; lambda functions Decorators Reusable, named functions; complex logic <p>You can use both together \u2014 they execute in order:</p> <pre><code>processor = DocumentProcessor(\n    on_post_process=lambda r, c: {**r, \"via_callback\": True}\n)\n\n@processor.on_post_process\ndef via_decorator(result, context):\n    result[\"via_decorator\"] = True\n    return result\n\n# Result will have both keys\n</code></pre>"},{"location":"hooks/#complete-example","title":"Complete Example","text":"<pre><code>from strutex import DocumentProcessor, Object, String, Number\nfrom datetime import datetime\nimport time\n\nprocessor = DocumentProcessor(provider=\"gemini\")\n\n@processor.on_pre_process\ndef start_timer(file_path, prompt, schema, mime_type, context):\n    context[\"start_time\"] = time.time()\n    print(f\"Processing: {file_path}\")\n    return None\n\n@processor.on_post_process\ndef add_metadata(result, context):\n    result[\"_processed_at\"] = datetime.now().isoformat()\n    result[\"_elapsed_seconds\"] = time.time() - context[\"start_time\"]\n    return result\n\n@processor.on_error\ndef fallback_handler(error, file_path, context):\n    print(f\"Error processing {file_path}: {error}\")\n    return {\"error\": str(error), \"file\": file_path}\n\nschema = Object(properties={\"invoice_number\": String(), \"total\": Number()})\nresult = processor.process(\"invoice.pdf\", \"Extract invoice data\", schema)\n</code></pre>"},{"location":"hooks/#hook-execution-order","title":"Hook Execution Order","text":"<ol> <li>Pre-process hooks run in registration order</li> <li>Security validation (input sanitization)</li> <li>Provider processing (LLM extraction)</li> <li>Security validation (output validation)</li> <li>Post-process hooks run in registration order</li> <li>Pydantic validation (if model was provided)</li> </ol> <p>If an error occurs at step 3, error hooks run until one returns a fallback.</p>"},{"location":"hooks/#advanced-pluggy-integration","title":"Advanced: Pluggy Integration","text":"<p>Callback/decorator hooks are automatically integrated with pluggy. This means:</p> <ul> <li>Your callbacks work alongside global pluggy plugins</li> <li>Third-party packages can register hooks via entry points</li> <li>All hooks execute through the same pipeline</li> </ul>"},{"location":"hooks/#global-pluggy-hooks","title":"Global Pluggy Hooks","text":"<p>For distributed plugins or complex scenarios:</p> <pre><code>from strutex.plugins import hookimpl, register_hook_plugin\n\nclass MetricsPlugin:\n    @hookimpl\n    def pre_process(self, file_path, prompt, schema, mime_type, context):\n        context[\"start_time\"] = time.time()\n\n    @hookimpl\n    def post_process(self, result, context):\n        elapsed = time.time() - context[\"start_time\"]\n        metrics.record(\"extraction_time\", elapsed)\n\nregister_hook_plugin(MetricsPlugin())\n</code></pre>"},{"location":"hooks/#how-it-works","title":"How It Works","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  processor.process() calls call_hook(\"post_process\", ...)       \u2502\n\u2502                              \u2502                                   \u2502\n\u2502                              \u25bc                                   \u2502\n\u2502              pluggy.PluginManager.hook.post_process()           \u2502\n\u2502                              \u2502                                   \u2502\n\u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u2502\n\u2502     \u25bc                        \u25bc                        \u25bc         \u2502\n\u2502  Callback       Decorator       Global Pluggy                   \u2502\n\u2502  Hooks          Hooks           Plugins                         \u2502\n\u2502  (wrapped in    (wrapped in     (registered via                 \u2502\n\u2502  _CallbackHook) _CallbackHook)  register_hook_plugin)           \u2502\n\u2502                                                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"hooks/#api-reference","title":"API Reference","text":"<p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p>"},{"location":"hooks/#strutex.plugins.hooks.register_hook_plugin","title":"<code>register_hook_plugin(plugin: Any) -&gt; None</code>","text":"<p>Register a plugin with hook implementations.</p> PARAMETER DESCRIPTION <code>plugin</code> <p>An object with @hookimpl decorated methods</p> <p> TYPE: <code>Any</code> </p> RAISES DESCRIPTION <code>RuntimeError</code> <p>If pluggy is not installed</p> Source code in <code>strutex/plugins/hooks.py</code> <pre><code>def register_hook_plugin(plugin: Any) -&gt; None:\n    \"\"\"\n    Register a plugin with hook implementations.\n\n    Args:\n        plugin: An object with @hookimpl decorated methods\n\n    Raises:\n        RuntimeError: If pluggy is not installed\n    \"\"\"\n    pm = get_plugin_manager()\n    if pm is None:\n        raise RuntimeError(\"pluggy is required for hook plugins. Install with: pip install pluggy\")\n\n    pm.register(plugin)\n</code></pre>"},{"location":"hooks/#strutex.plugins.hooks.unregister_hook_plugin","title":"<code>unregister_hook_plugin(plugin: Any) -&gt; None</code>","text":"<p>Unregister a previously registered hook plugin.</p> PARAMETER DESCRIPTION <code>plugin</code> <p>The plugin object to unregister</p> <p> TYPE: <code>Any</code> </p> Source code in <code>strutex/plugins/hooks.py</code> <pre><code>def unregister_hook_plugin(plugin: Any) -&gt; None:\n    \"\"\"\n    Unregister a previously registered hook plugin.\n\n    Args:\n        plugin: The plugin object to unregister\n    \"\"\"\n    pm = get_plugin_manager()\n    if pm is not None:\n        pm.unregister(plugin)\n</code></pre>"},{"location":"integrations/","title":"Framework Integrations","text":"<p>Strutex integrates with popular AI/ML frameworks, allowing you to use its structured extraction capabilities within existing pipelines.</p>"},{"location":"integrations/#installation","title":"Installation","text":"<p>Install with integration extras:</p> <pre><code># LangChain\npip install strutex[langchain]\n\n# LlamaIndex\npip install strutex[llamaindex]\n\n# Haystack\npip install strutex[haystack]\n\n# Unstructured.io fallback\npip install strutex[fallback]\n\n# All integrations\npip install strutex[all]\n</code></pre>"},{"location":"integrations/#langchain","title":"LangChain","text":""},{"location":"integrations/#strutexloader","title":"StrutexLoader","text":"<p>Use Strutex as a LangChain document loader for structured extraction:</p> <pre><code>from strutex.integrations import StrutexLoader\nfrom strutex.schemas import INVOICE_US\n\n# Load and extract structured data\nloader = StrutexLoader(\n    file_path=\"invoice.pdf\",\n    schema=INVOICE_US,\n    provider=\"gemini\"\n)\ndocuments = loader.load()\n\n# Use in LangChain pipeline\nprint(documents[0].page_content)  # JSON string\nprint(documents[0].metadata)       # {\"source\": \"invoice.pdf\", \"extractor\": \"strutex\", ...}\n</code></pre>"},{"location":"integrations/#strutexoutputparser","title":"StrutexOutputParser","text":"<p>Validate LLM output against schemas:</p> <pre><code>from strutex.integrations import StrutexOutputParser\nfrom pydantic import BaseModel\n\nclass InvoiceData(BaseModel):\n    vendor: str\n    total: float\n    date: str\n\nparser = StrutexOutputParser(\n    schema=InvoiceData,\n    validators=[\"schema\", \"sum\", \"date\"]  # Use strutex validators\n)\n\n# Parse LLM response\nresult = parser.parse(llm_response_text)\nprint(result.vendor)  # Validated Pydantic model\n\n# Get format instructions for prompts\ninstructions = parser.get_format_instructions()\n</code></pre>"},{"location":"integrations/#llamaindex","title":"LlamaIndex","text":""},{"location":"integrations/#strutexreader","title":"StrutexReader","text":"<p>Use Strutex as a LlamaIndex document reader:</p> <pre><code>from strutex.integrations import StrutexReader\nfrom strutex.schemas import INVOICE_GENERIC\n\nreader = StrutexReader(\n    schema=INVOICE_GENERIC,\n    provider=\"openai\"\n)\n\ndocuments = reader.load_data(\"invoice.pdf\")\n\n# Use with LlamaIndex index\nfrom llama_index.core import VectorStoreIndex\nindex = VectorStoreIndex.from_documents(documents)\n</code></pre>"},{"location":"integrations/#strutexnodeparser","title":"StrutexNodeParser","text":"<p>Keep structured documents as single nodes (prevents chunking):</p> <pre><code>from strutex.integrations import StrutexReader, StrutexNodeParser\n\nreader = StrutexReader(schema=MySchema)\ndocs = reader.load_data(\"complex_doc.pdf\")\n\n# Don't chunk structured JSON\nparser = StrutexNodeParser()\nnodes = parser.get_nodes_from_documents(docs)\n</code></pre>"},{"location":"integrations/#haystack","title":"Haystack","text":""},{"location":"integrations/#strutexconverter","title":"StrutexConverter","text":"<p>Use Strutex in Haystack pipelines (coming soon):</p> <pre><code>from strutex.integrations import StrutexConverter\nfrom strutex.schemas import INVOICE_US\n\nconverter = StrutexConverter(schema=INVOICE_US)\ndocuments = converter.run(file_path=\"invoice.pdf\")\n</code></pre>"},{"location":"integrations/#unstructured-fallback","title":"Unstructured Fallback","text":""},{"location":"integrations/#unstructuredfallbackprocessor","title":"UnstructuredFallbackProcessor","text":"<p>Hybrid mode: use Strutex first, fall back to Unstructured.io if extraction fails:</p> <pre><code>from strutex.integrations import UnstructuredFallbackProcessor\nfrom strutex.schemas import INVOICE_US\n\nprocessor = UnstructuredFallbackProcessor(\n    schema=INVOICE_US,\n    provider=\"gemini\"\n)\n\n# Tries strutex first, falls back to unstructured.partition()\nresult = processor.process(\"messy_doc.pdf\")\n</code></pre>"},{"location":"integrations/#documentinput","title":"DocumentInput","text":"<p>Handle both file paths and BytesIO (e.g., from HTTP uploads):</p> <pre><code>from strutex import DocumentInput, DocumentProcessor\nimport io\n\n# From file path\ndoc = DocumentInput(\"invoice.pdf\")\n\n# From in-memory bytes (e.g., HTTP request)\npdf_bytes = request.files['document'].read()\ndoc = DocumentInput(io.BytesIO(pdf_bytes), filename=\"upload.pdf\")\n\n# Use with processor\nprocessor = DocumentProcessor(provider=\"gemini\")\nwith doc.as_file_path() as path:\n    result = processor.process(path, schema=MySchema)\n\n# Or get raw bytes\ncontent = doc.get_bytes()\nmime = doc.get_mime_type()  # \"application/pdf\"\n</code></pre>"},{"location":"integrations/#example-full-rag-pipeline","title":"Example: Full RAG Pipeline","text":"<p>Combine Strutex with LangChain for a complete RAG system:</p> <pre><code>from strutex.integrations import StrutexLoader\nfrom strutex.schemas import INVOICE_US\nfrom langchain_community.vectorstores import Chroma\nfrom langchain_openai import OpenAIEmbeddings\nfrom langchain.chains import RetrievalQA\nfrom langchain_openai import ChatOpenAI\n\n# 1. Load and extract invoices\nloader = StrutexLoader(\"invoices/*.pdf\", schema=INVOICE_US)\ndocs = loader.load()\n\n# 2. Create vector store\nvectorstore = Chroma.from_documents(docs, OpenAIEmbeddings())\n\n# 3. Build QA chain\nqa = RetrievalQA.from_chain_type(\n    llm=ChatOpenAI(),\n    retriever=vectorstore.as_retriever()\n)\n\n# 4. Query\nanswer = qa.invoke(\"Which invoice had the highest total?\")\n</code></pre>"},{"location":"plugins/","title":"Plugin System","text":"<p>Everything in strutex is pluggable. Use defaults or register your own implementations.</p> <p>New in v0.3.0</p> <p>Plugin System v2 introduces auto-registration via inheritance, lazy loading, entry points, priority-based ordering, and CLI tooling.</p>"},{"location":"plugins/#architecture-plugins-vs-hooks","title":"Architecture: Plugins vs Hooks","text":"<p>Strutex has two extension mechanisms that serve different purposes:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     DocumentProcessor.process()                  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                                                                  \u2502\n\u2502  \u250c\u2500\u2500\u2500 HOOKS (Observers) \u2500\u2500\u2500\u2510                                     \u2502\n\u2502  \u2502 \u2022 pre_process           \u2502 \u25c4\u2500\u2500 Logging, timing, prompt mods   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                     \u2502\n\u2502              \u2502                                                   \u2502\n\u2502              \u25bc                                                   \u2502\n\u2502  \u250c\u2500\u2500\u2500 PLUGINS (Components) \u2500\u2510                                    \u2502\n\u2502  \u2502 \u2022 SecurityPlugin         \u2502 \u25c4\u2500\u2500 Validates input               \u2502\n\u2502  \u2502 \u2022 Extractor              \u2502 \u25c4\u2500\u2500 PDF \u2192 text                    \u2502\n\u2502  \u2502 \u2022 Provider               \u2502 \u25c4\u2500\u2500 LLM call                      \u2502\n\u2502  \u2502 \u2022 Validator              \u2502 \u25c4\u2500\u2500 Validates output              \u2502\n\u2502  \u2502 \u2022 Postprocessor          \u2502 \u25c4\u2500\u2500 Transforms result             \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                    \u2502\n\u2502              \u2502                                                   \u2502\n\u2502              \u25bc                                                   \u2502\n\u2502  \u250c\u2500\u2500\u2500 HOOKS (Observers) \u2500\u2500\u2500\u2510                                     \u2502\n\u2502  \u2502 \u2022 post_process          \u2502 \u25c4\u2500\u2500 Add metadata, notifications    \u2502\n\u2502  \u2502 \u2022 on_error              \u2502 \u25c4\u2500\u2500 Fallbacks, alerting            \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                     \u2502\n\u2502                                                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"plugins/#when-to-use-which","title":"When to Use Which?","text":"Feature Plugins (Base Classes) Hooks System Pattern Strategy Pattern Observer/Middleware Pattern Role Drivers \u2014 define how a step is performed Observers \u2014 react to pipeline events Cardinality 1:1 \u2014 one Provider, one Extractor per run 1:N \u2014 many hooks can run simultaneously Complexity Higher \u2014 implement interface methods Lower \u2014 just a function or decorator Goal Interchangeability \u2014 replace the engine Cross-cutting concerns \u2014 add without touching engine <p>Use a Plugin when:</p> <ul> <li>Changing the fundamental logic (e.g., \"use OCR instead of text extraction\")</li> <li>Replacing a core component (different LLM provider)</li> </ul> <p>Use a Hook when:</p> <ul> <li>Observing events (logging, timing, metrics)</li> <li>Modifying data generically (add metadata to all results)</li> <li>Handling errors (fallbacks, alerting)</li> </ul>"},{"location":"plugins/#plugin-types","title":"Plugin Types","text":"Type Purpose Built-in Examples <code>provider</code> LLM backends Gemini, OpenAI <code>security</code> Input/output protection InputSanitizer, PromptInjectionDetector <code>extractor</code> Document parsing PDF, Image, Excel <code>validator</code> Output validation Schema, business rules <code>postprocessor</code> Data transformation DateNormalizer <p>The <code>PluginType</code> enum provides type-safe access:</p> <pre><code>from strutex.plugins import PluginType\n\nPluginType.PROVIDER      # \"provider\"\nPluginType.EXTRACTOR     # \"extractor\"\nPluginType.VALIDATOR     # \"validator\"\nPluginType.POSTPROCESSOR # \"postprocessor\"\nPluginType.SECURITY      # \"security\"\n</code></pre>"},{"location":"plugins/#quick-start","title":"Quick Start","text":""},{"location":"plugins/#auto-registration-via-inheritance","title":"Auto-Registration via Inheritance","text":"<p>Simply inherit from a base class and your plugin is automatically registered:</p> <pre><code>from strutex.plugins import Provider\n\nclass MyProvider(Provider):\n    \"\"\"Auto-registered as 'myprovider'\"\"\"\n    capabilities = [\"vision\"]\n\n    def process(self, file_path, prompt, schema, mime_type, **kwargs):\n        return {\"result\": \"data\"}\n</code></pre> <p>That's it! No decorators or manual registration needed.</p>"},{"location":"plugins/#customizing-registration","title":"Customizing Registration","text":"<p>Use class arguments to customize the name:</p> <pre><code>class FastProvider(Provider, name=\"fast\"):\n    \"\"\"Registered as 'fast' with high priority\"\"\"\n    priority = 90  # Priority is a class attribute\n    cost = 0.5\n    capabilities = [\"vision\", \"batch\"]\n\n    def process(self, *args, **kwargs):\n        ...\n</code></pre>"},{"location":"plugins/#opting-out-of-auto-registration","title":"Opting Out of Auto-Registration","text":"<p>For intermediate base classes:</p> <pre><code>class BasePdfProvider(Provider, register=False):\n    \"\"\"NOT registered - abstract base class\"\"\"\n    def common_pdf_logic(self):\n        ...\n\nclass AdobeProvider(BasePdfProvider):\n    \"\"\"Registered as 'adobeprovider'\"\"\"\n    def process(self, *args, **kwargs):\n        ...\n</code></pre> <p>Tip</p> <p>Classes with unimplemented <code>@abstractmethod</code>s are automatically skipped.</p>"},{"location":"plugins/#plugin-attributes","title":"Plugin Attributes","text":"Attribute Type Default Description <code>strutex_plugin_version</code> <code>str</code> <code>\"1.0\"</code> API version for compatibility <code>priority</code> <code>int</code> <code>50</code> Order in waterfall (0-100, higher = preferred) <code>cost</code> <code>float</code> <code>1.0</code> Cost hint (lower = cheaper) <code>capabilities</code> <code>list</code> <code>[]</code> Features this plugin supports"},{"location":"plugins/#registration-methods","title":"Registration Methods","text":""},{"location":"plugins/#1-auto-registration-recommended","title":"1. Auto-Registration (Recommended)","text":"<p>Just inherit from a base class:</p> <pre><code>class MyProvider(Provider):\n    def process(self, ...): ...\n# \u2192 Registered as \"myprovider\"\n\nclass MyProvider(Provider, name=\"custom\"):\n    def process(self, ...): ...\n# \u2192 Registered as \"custom\"\n</code></pre>"},{"location":"plugins/#2-entry-points-for-packages","title":"2. Entry Points (For Packages)","text":"<p>For distributable packages, register in <code>pyproject.toml</code>:</p> <pre><code>[project.entry-points.\"strutex.providers\"]\nmy_provider = \"my_package:MyProvider\"\n\n[project.entry-points.\"strutex.validators\"]\nmy_validator = \"my_package:MyValidator\"\n</code></pre> <p>Plugins are lazy loaded \u2014 only imported when first used.</p>"},{"location":"plugins/#3-manual-registration","title":"3. Manual Registration","text":"<pre><code>from strutex.plugins import PluginRegistry\n\nPluginRegistry.register(\"provider\", \"my_provider\", MyProvider)\n</code></pre>"},{"location":"plugins/#cli-commands","title":"CLI Commands","text":"<pre><code># List all plugins\nstrutex plugins list\n\n# Filter by type\nstrutex plugins list --type provider\n\n# JSON output\nstrutex plugins list --json\n\n# Plugin details\nstrutex plugins info gemini --type provider\n\n# Refresh discovery cache\nstrutex plugins refresh\n</code></pre>"},{"location":"plugins/#creating-custom-plugins","title":"Creating Custom Plugins","text":""},{"location":"plugins/#custom-provider","title":"Custom Provider","text":"<pre><code>from strutex.plugins import Provider\n\nclass OllamaProvider(Provider):\n    priority = 60\n    capabilities = [\"local\", \"vision\"]\n\n    def __init__(self, model=\"llama3\"):\n        self.model = model\n\n    def process(self, file_path, prompt, schema, mime_type, **kwargs):\n        # Your implementation\n        ...\n</code></pre>"},{"location":"plugins/#custom-validator","title":"Custom Validator","text":"<pre><code>from strutex.plugins import Validator, ValidationResult\n\nclass SumValidator(Validator):\n    \"\"\"Verify line items sum to total.\"\"\"\n    priority = 70\n\n    def validate(self, data, schema=None):\n        items_sum = sum(i.get(\"amount\", 0) for i in data.get(\"items\", []))\n        total = data.get(\"total\", 0)\n\n        if abs(items_sum - total) &gt; 0.01:\n            return ValidationResult(\n                valid=False,\n                data=data,\n                issues=[f\"Sum mismatch: {items_sum} != {total}\"]\n            )\n        return ValidationResult(valid=True, data=data)\n</code></pre>"},{"location":"plugins/#custom-postprocessor","title":"Custom Postprocessor","text":"<pre><code>from strutex.plugins import Postprocessor\nimport re\n\nclass DateNormalizer(Postprocessor):\n    \"\"\"Convert DD.MM.YYYY to YYYY-MM-DD.\"\"\"\n\n    def process(self, data):\n        result = data.copy()\n        if \"date\" in result:\n            match = re.match(r'(\\d{2})\\.(\\d{2})\\.(\\d{4})', result[\"date\"])\n            if match:\n                d, m, y = match.groups()\n                result[\"date\"] = f\"{y}-{m}-{d}\"\n        return result\n</code></pre>"},{"location":"plugins/#api-reference","title":"API Reference","text":"<p>options: show_root_heading: true members: - register - get - list - discover</p> <p>options: show_root_heading: true</p>"},{"location":"plugins/#strutex.plugins.PluginRegistry","title":"<code>PluginRegistry</code>","text":"<p>Central registry for all plugin types with lazy loading.</p> <p>Plugins are stored as EntryPoint objects and only loaded when first accessed via get(). This improves startup time and avoids importing unused dependencies.</p> Usage"},{"location":"plugins/#strutex.plugins.PluginRegistry--get-a-plugin-loads-on-first-access","title":"Get a plugin (loads on first access)","text":"<p>cls = PluginRegistry.get(\"provider\", \"gemini\")</p>"},{"location":"plugins/#strutex.plugins.PluginRegistry--list-all-plugins-does-not-load-them","title":"List all plugins (does not load them)","text":"<p>all_providers = PluginRegistry.list(\"provider\")</p>"},{"location":"plugins/#strutex.plugins.PluginRegistry--force-discovery-from-entry-points","title":"Force discovery from entry points","text":"<p>count = PluginRegistry.discover()</p>"},{"location":"plugins/#strutex.plugins.PluginRegistry.clear","title":"<code>clear(plugin_type: Optional[str] = None) -&gt; None</code>  <code>classmethod</code>","text":"<p>Clear registered plugins.</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>If provided, only clear this type. Otherwise clear all.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef clear(cls, plugin_type: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Clear registered plugins.\n\n    Args:\n        plugin_type: If provided, only clear this type. Otherwise clear all.\n    \"\"\"\n    if plugin_type:\n        cls._entry_points.pop(plugin_type, None)\n        cls._loaded.pop(plugin_type, None)\n        cls._manual.pop(plugin_type, None)\n    else:\n        cls._entry_points.clear()\n        cls._loaded.clear()\n        cls._manual.clear()\n        cls._discovered = False\n</code></pre>"},{"location":"plugins/#strutex.plugins.PluginRegistry.discover","title":"<code>discover(group_prefix: str = 'strutex', force: bool = False) -&gt; int</code>  <code>classmethod</code>","text":"<p>Discover and register plugins from entry points.</p> <p>Scans for entry points matching the pattern: - strutex.providers - strutex.validators - strutex.postprocessors - strutex.security - etc.</p> <p>Entry points are stored for lazy loading - they are not imported until first use via get().</p> PARAMETER DESCRIPTION <code>group_prefix</code> <p>Entry point group prefix (default: \"strutex\")</p> <p> TYPE: <code>str</code> DEFAULT: <code>'strutex'</code> </p> <code>force</code> <p>Force re-discovery even if already discovered</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>int</code> <p>Number of entry points discovered</p> <p>Example pyproject.toml:     [project.entry-points.\"strutex.providers\"]     my_provider = \"my_package:MyProvider\"</p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef discover(cls, group_prefix: str = \"strutex\", force: bool = False) -&gt; int:\n    \"\"\"\n    Discover and register plugins from entry points.\n\n    Scans for entry points matching the pattern:\n    - strutex.providers\n    - strutex.validators\n    - strutex.postprocessors\n    - strutex.security\n    - etc.\n\n    Entry points are stored for lazy loading - they are not imported\n    until first use via get().\n\n    Args:\n        group_prefix: Entry point group prefix (default: \"strutex\")\n        force: Force re-discovery even if already discovered\n\n    Returns:\n        Number of entry points discovered\n\n    Example pyproject.toml:\n        [project.entry-points.\"strutex.providers\"]\n        my_provider = \"my_package:MyProvider\"\n    \"\"\"\n    if cls._discovered and not force:\n        return sum(len(eps) for eps in cls._entry_points.values())\n\n    discovered = 0\n\n    # Get entry_points function\n    if sys.version_info &gt;= (3, 10):\n        from importlib.metadata import entry_points\n    else:\n        try:\n            from importlib_metadata import entry_points\n        except ImportError:\n            cls._discovered = True\n            return 0\n\n    # Get all entry point groups\n    try:\n        all_eps = entry_points()\n\n        # Get group names that match our prefix\n        if hasattr(all_eps, 'groups'):\n            # Python 3.12+ style\n            groups = [g for g in all_eps.groups if g.startswith(f\"{group_prefix}.\")]\n        elif hasattr(all_eps, 'keys'):\n            # Python 3.9-3.11 style (dict-like)\n            groups = [g for g in all_eps.keys() if g.startswith(f\"{group_prefix}.\")]\n        else:\n            groups = []\n    except Exception:\n        cls._discovered = True\n        return 0\n\n    for group in groups:\n        # Extract plugin type from group name\n        # e.g., \"strutex.providers\" -&gt; \"provider\"\n        plugin_type = group.replace(f\"{group_prefix}.\", \"\").rstrip(\"s\")\n\n        if plugin_type not in cls._entry_points:\n            cls._entry_points[plugin_type] = {}\n\n        try:\n            # Get entry points for this group\n            if hasattr(all_eps, 'select'):\n                eps = all_eps.select(group=group)\n            else:\n                eps = all_eps.get(group, [])\n\n            for ep in eps:\n                # Store entry point for lazy loading\n                cls._entry_points[plugin_type][ep.name.lower()] = ep\n                discovered += 1\n\n        except Exception:\n            pass\n\n    cls._discovered = True\n    return discovered\n</code></pre>"},{"location":"plugins/#strutex.plugins.PluginRegistry.get","title":"<code>get(plugin_type: str, name: str) -&gt; Optional[Type]</code>  <code>classmethod</code>","text":"<p>Get a registered plugin class by type and name.</p> <p>If the plugin is registered via entry point and not yet loaded, it will be loaded on first access (lazy loading).</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>Type of plugin</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name of the plugin</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Optional[Type]</code> <p>The plugin class, or None if not found</p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef get(cls, plugin_type: str, name: str) -&gt; Optional[Type]:\n    \"\"\"\n    Get a registered plugin class by type and name.\n\n    If the plugin is registered via entry point and not yet loaded,\n    it will be loaded on first access (lazy loading).\n\n    Args:\n        plugin_type: Type of plugin\n        name: Name of the plugin\n\n    Returns:\n        The plugin class, or None if not found\n    \"\"\"\n    name_lower = name.lower()\n\n    # Ensure discovery has run\n    if not cls._discovered:\n        cls.discover()\n\n    # Check loaded cache first\n    if name_lower in cls._loaded.get(plugin_type, {}):\n        return cls._loaded[plugin_type][name_lower]\n\n    # Check manual registrations\n    if name_lower in cls._manual.get(plugin_type, {}):\n        return cls._manual[plugin_type][name_lower]\n\n    # Try to lazy load from entry point\n    ep = cls._entry_points.get(plugin_type, {}).get(name_lower)\n    if ep is not None:\n        plugin_cls = cls._load_entry_point(ep, plugin_type, name_lower)\n        if plugin_cls is not None:\n            return plugin_cls\n\n    return None\n</code></pre>"},{"location":"plugins/#strutex.plugins.PluginRegistry.get_plugin_info","title":"<code>get_plugin_info(plugin_type: str, name: str) -&gt; Optional[Dict[str, Any]]</code>  <code>classmethod</code>","text":"<p>Get metadata about a plugin without necessarily loading it.</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>Type of plugin</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Name of the plugin</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Optional[Dict[str, Any]]</code> <p>Dict with plugin info, or None if not found</p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef get_plugin_info(cls, plugin_type: str, name: str) -&gt; Optional[Dict[str, Any]]:\n    \"\"\"\n    Get metadata about a plugin without necessarily loading it.\n\n    Args:\n        plugin_type: Type of plugin\n        name: Name of the plugin\n\n    Returns:\n        Dict with plugin info, or None if not found\n    \"\"\"\n    name_lower = name.lower()\n\n    if not cls._discovered:\n        cls.discover()\n\n    # Check if loaded\n    if name_lower in cls._loaded.get(plugin_type, {}):\n        plugin_cls = cls._loaded[plugin_type][name_lower]\n        return {\n            \"name\": name_lower,\n            \"version\": getattr(plugin_cls, \"strutex_plugin_version\", \"unknown\"),\n            \"priority\": getattr(plugin_cls, \"priority\", 50),\n            \"cost\": getattr(plugin_cls, \"cost\", 1.0),\n            \"capabilities\": getattr(plugin_cls, \"capabilities\", []),\n            \"loaded\": True,\n            \"healthy\": cls._check_health(plugin_cls),\n        }\n\n    # Check entry point\n    ep = cls._entry_points.get(plugin_type, {}).get(name_lower)\n    if ep is not None:\n        return {\n            \"name\": name_lower,\n            \"entry_point\": f\"{ep.group}:{ep.name}\",\n            \"loaded\": False,\n            \"healthy\": None,  # Unknown until loaded\n        }\n\n    return None\n</code></pre>"},{"location":"plugins/#strutex.plugins.PluginRegistry.get_sorted","title":"<code>get_sorted(plugin_type: str, reverse: bool = True) -&gt; List[Tuple[str, Type]]</code>  <code>classmethod</code>","text":"<p>Get all plugins of a type sorted by priority.</p> <p>Useful for waterfall selection where you want to try higher-priority plugins first.</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>Type of plugin</p> <p> TYPE: <code>str</code> </p> <code>reverse</code> <p>If True (default), higher priority first</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>List[Tuple[str, Type]]</code> <p>List of (name, class) tuples sorted by priority</p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef get_sorted(cls, plugin_type: str, reverse: bool = True) -&gt; List[Tuple[str, Type]]:\n    \"\"\"\n    Get all plugins of a type sorted by priority.\n\n    Useful for waterfall selection where you want to try\n    higher-priority plugins first.\n\n    Args:\n        plugin_type: Type of plugin\n        reverse: If True (default), higher priority first\n\n    Returns:\n        List of (name, class) tuples sorted by priority\n    \"\"\"\n    plugins = cls.list(plugin_type)\n    return sorted(\n        plugins.items(),\n        key=lambda x: getattr(x[1], 'priority', 50),\n        reverse=reverse\n    )\n</code></pre>"},{"location":"plugins/#strutex.plugins.PluginRegistry.list","title":"<code>list(plugin_type: str) -&gt; Dict[str, Type]</code>  <code>classmethod</code>","text":"<p>List all plugins of a given type.</p> <p>Note: This loads all plugins of the type. Use list_names() for a lightweight listing without loading.</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>Type of plugin</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Dict[str, Type]</code> <p>Dictionary mapping names to plugin classes</p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef list(cls, plugin_type: str) -&gt; Dict[str, Type]:\n    \"\"\"\n    List all plugins of a given type.\n\n    Note: This loads all plugins of the type. Use list_names()\n    for a lightweight listing without loading.\n\n    Args:\n        plugin_type: Type of plugin\n\n    Returns:\n        Dictionary mapping names to plugin classes\n    \"\"\"\n    if not cls._discovered:\n        cls.discover()\n\n    result = {}\n\n    # Get all names from entry points and manual registrations\n    all_names = set()\n    all_names.update(cls._entry_points.get(plugin_type, {}).keys())\n    all_names.update(cls._manual.get(plugin_type, {}).keys())\n    all_names.update(cls._loaded.get(plugin_type, {}).keys())\n\n    # Load each plugin\n    for name in all_names:\n        plugin_cls = cls.get(plugin_type, name)\n        if plugin_cls is not None:\n            result[name] = plugin_cls\n\n    return result\n</code></pre>"},{"location":"plugins/#strutex.plugins.PluginRegistry.list_names","title":"<code>list_names(plugin_type: str) -&gt; List[str]</code>  <code>classmethod</code>","text":"<p>List names of all plugins of a given type without loading them.</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>Type of plugin</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>List[str]</code> <p>List of plugin names</p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef list_names(cls, plugin_type: str) -&gt; List[str]:\n    \"\"\"\n    List names of all plugins of a given type without loading them.\n\n    Args:\n        plugin_type: Type of plugin\n\n    Returns:\n        List of plugin names\n    \"\"\"\n    if not cls._discovered:\n        cls.discover()\n\n    names = set()\n    names.update(cls._entry_points.get(plugin_type, {}).keys())\n    names.update(cls._manual.get(plugin_type, {}).keys())\n    names.update(cls._loaded.get(plugin_type, {}).keys())\n\n    return sorted(names)\n</code></pre>"},{"location":"plugins/#strutex.plugins.PluginRegistry.list_types","title":"<code>list_types() -&gt; List[str]</code>  <code>classmethod</code>","text":"<p>List all registered plugin types.</p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef list_types(cls) -&gt; List[str]:\n    \"\"\"List all registered plugin types.\"\"\"\n    if not cls._discovered:\n        cls.discover()\n\n    types = set()\n    types.update(cls._entry_points.keys())\n    types.update(cls._manual.keys())\n    types.update(cls._loaded.keys())\n\n    return sorted(types)\n</code></pre>"},{"location":"plugins/#strutex.plugins.PluginRegistry.register","title":"<code>register(plugin_type: str, name: str, plugin_cls: Type) -&gt; None</code>  <code>classmethod</code>","text":"<p>Register a plugin class manually.</p> <p>This is used by the @register decorator for backwards compatibility. Prefer using entry points in pyproject.toml for new plugins.</p> PARAMETER DESCRIPTION <code>plugin_type</code> <p>Type of plugin (e.g., \"provider\", \"security\", \"validator\")</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>Unique name for this plugin</p> <p> TYPE: <code>str</code> </p> <code>plugin_cls</code> <p>The plugin class to register</p> <p> TYPE: <code>Type</code> </p> Source code in <code>strutex/plugins/registry.py</code> <pre><code>@classmethod\ndef register(cls, plugin_type: str, name: str, plugin_cls: Type) -&gt; None:\n    \"\"\"\n    Register a plugin class manually.\n\n    This is used by the @register decorator for backwards compatibility.\n    Prefer using entry points in pyproject.toml for new plugins.\n\n    Args:\n        plugin_type: Type of plugin (e.g., \"provider\", \"security\", \"validator\")\n        name: Unique name for this plugin\n        plugin_cls: The plugin class to register\n    \"\"\"\n    if plugin_type not in cls._manual:\n        cls._manual[plugin_type] = {}\n\n    cls._manual[plugin_type][name.lower()] = plugin_cls\n\n    # Also add to loaded cache\n    if plugin_type not in cls._loaded:\n        cls._loaded[plugin_type] = {}\n    cls._loaded[plugin_type][name.lower()] = plugin_cls\n</code></pre>"},{"location":"plugins/#strutex.plugins.Provider","title":"<code>Provider</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for LLM providers.</p> <p>All providers must implement the process method to handle document extraction via their specific LLM API.</p> <p>Subclassing auto-registers the plugin. Use class arguments to customize:</p> <pre><code>class MyProvider(Provider, name=\"custom\", priority=90):\n    ...\n</code></pre> ATTRIBUTE DESCRIPTION <code>strutex_plugin_version</code> <p>API version for compatibility checks</p> <p> TYPE: <code>str</code> </p> <code>priority</code> <p>Ordering priority (0-100, higher = preferred)</p> <p> TYPE: <code>int</code> </p> <code>cost</code> <p>Cost hint for optimization (lower = cheaper)</p> <p> TYPE: <code>float</code> </p> <code>capabilities</code> <p>List of supported features</p> <p> TYPE: <code>List[str]</code> </p>"},{"location":"plugins/#strutex.plugins.Provider.aprocess","title":"<code>aprocess(file_path: str, prompt: str, schema: Schema, mime_type: str, **kwargs) -&gt; Any</code>  <code>async</code>","text":"<p>Async version of process. Override for true async support. Default implementation calls sync version.</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>async def aprocess(\n    self,\n    file_path: str,\n    prompt: str,\n    schema: Schema,\n    mime_type: str,\n    **kwargs\n) -&gt; Any:\n    \"\"\"\n    Async version of process. Override for true async support.\n    Default implementation calls sync version.\n    \"\"\"\n    return self.process(file_path, prompt, schema, mime_type, **kwargs)\n</code></pre>"},{"location":"plugins/#strutex.plugins.Provider.has_capability","title":"<code>has_capability(capability: str) -&gt; bool</code>","text":"<p>Check if this provider has a specific capability.</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>def has_capability(self, capability: str) -&gt; bool:\n    \"\"\"Check if this provider has a specific capability.\"\"\"\n    return capability.lower() in [c.lower() for c in self.capabilities]\n</code></pre>"},{"location":"plugins/#strutex.plugins.Provider.health_check","title":"<code>health_check() -&gt; bool</code>  <code>classmethod</code>","text":"<p>Check if this provider is healthy and ready to use.</p> <p>Override in subclasses for custom health checks (e.g., API connectivity).</p> RETURNS DESCRIPTION <code>bool</code> <p>True if healthy, False otherwise</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>@classmethod\ndef health_check(cls) -&gt; bool:\n    \"\"\"\n    Check if this provider is healthy and ready to use.\n\n    Override in subclasses for custom health checks (e.g., API connectivity).\n\n    Returns:\n        True if healthy, False otherwise\n    \"\"\"\n    return True\n</code></pre>"},{"location":"plugins/#strutex.plugins.Provider.process","title":"<code>process(file_path: str, prompt: str, schema: Schema, mime_type: str, **kwargs) -&gt; Any</code>  <code>abstractmethod</code>","text":"<p>Process a document and extract structured data.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>Path to the document file</p> <p> TYPE: <code>str</code> </p> <code>prompt</code> <p>Extraction prompt/instructions</p> <p> TYPE: <code>str</code> </p> <code>schema</code> <p>Expected output schema</p> <p> TYPE: <code>Schema</code> </p> <code>mime_type</code> <p>MIME type of the file</p> <p> TYPE: <code>str</code> </p> <code>**kwargs</code> <p>Provider-specific options</p> <p> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>Extracted data matching the schema</p> Source code in <code>strutex/plugins/base.py</code> <pre><code>@abstractmethod\ndef process(\n    self,\n    file_path: str,\n    prompt: str,\n    schema: Schema,\n    mime_type: str,\n    **kwargs\n) -&gt; Any:\n    \"\"\"\n    Process a document and extract structured data.\n\n    Args:\n        file_path: Path to the document file\n        prompt: Extraction prompt/instructions\n        schema: Expected output schema\n        mime_type: MIME type of the file\n        **kwargs: Provider-specific options\n\n    Returns:\n        Extracted data matching the schema\n    \"\"\"\n    pass\n</code></pre>"},{"location":"prompt-builder/","title":"Prompt Builder","text":"<p>Build structured, organized prompts with the <code>StructuredPrompt</code> fluent API.</p>"},{"location":"prompt-builder/#basic-usage","title":"Basic Usage","text":"<pre><code>from strutex import StructuredPrompt\n\nprompt = (\n    StructuredPrompt()\n    .add_general_rule(\"Extract data exactly as shown\")\n    .add_field_rule(\"invoice_number\", \"Look for 'Invoice No'\")\n    .add_output_guideline(\"Return valid JSON only\")\n    .compile()\n)\n</code></pre> <p>Output:</p> <pre><code>You are a highly accurate AI Data Extraction Assistant.\n\n### 1. General Principles\n- Extract data exactly as shown\n\n### 2. Field Rules\n\n**invoice_number**:\n- Look for 'Invoice No'\n\n### 3. Output Format\n- Return valid JSON only\n</code></pre>"},{"location":"prompt-builder/#multiple-rules","title":"Multiple Rules","text":"<p>Use variadic arguments for cleaner code:</p> <pre><code>prompt = (\n    StructuredPrompt()\n    .add_general_rule(\n        \"Extract all visible data exactly as shown\",\n        \"Use null for missing values\",\n        \"Dates must be in YYYY-MM-DD format\",\n        \"Numbers use dot as decimal separator\"\n    )\n    .compile()\n)\n</code></pre>"},{"location":"prompt-builder/#critical-fields","title":"Critical Fields","text":"<p>Mark important fields as critical:</p> <pre><code>prompt = (\n    StructuredPrompt()\n    .add_field_rule(\n        \"total\",\n        \"Final payable amount\",\n        \"Usually labeled 'Total' or 'Grand Total'\",\n        critical=True\n    )\n    .compile()\n)\n</code></pre> <p>Output:</p> <pre><code>**total**:\n- **CRITICAL**: Final payable amount\n- **CRITICAL**: Usually labeled 'Total' or 'Grand Total'\n</code></pre>"},{"location":"prompt-builder/#custom-persona","title":"Custom Persona","text":"<pre><code>prompt = StructuredPrompt(\n    persona=\"You are an expert German invoice analyst.\"\n)\n</code></pre>"},{"location":"prompt-builder/#complete-example","title":"Complete Example","text":"<pre><code>from strutex import StructuredPrompt\n\nprompt = (\n    StructuredPrompt(\n        persona=\"You are a precise invoice extraction specialist.\"\n    )\n    .add_general_rule(\n        \"Extract all data exactly as shown in the document\",\n        \"Do not invent missing values - use null\",\n        \"Ignore handwritten annotations\"\n    )\n    .add_field_rule(\n        \"invoice_number\",\n        \"Look for 'Invoice No', 'Invoice #', 'Inv-'\",\n        critical=True\n    )\n    .add_field_rule(\n        \"date\",\n        \"Invoice date, convert to YYYY-MM-DD format\"\n    )\n    .add_field_rule(\n        \"total\",\n        \"Final amount including tax\",\n        \"May be labeled 'Total', 'Amount Due', 'Grand Total'\",\n        critical=True\n    )\n    .add_output_guideline(\n        \"Return valid JSON only\",\n        \"No markdown code blocks\",\n        \"Match the provided schema exactly\"\n    )\n    .compile()\n)\n</code></pre>"},{"location":"prompt-builder/#using-with-processor","title":"Using with Processor","text":"<pre><code>from strutex import DocumentProcessor, StructuredPrompt\n\nprompt = (\n    StructuredPrompt()\n    .add_general_rule(\"Extract invoice data\")\n    .add_field_rule(\"total\", \"Total amount\", critical=True)\n    .compile()\n)\n\nprocessor = DocumentProcessor(provider=\"gemini\")\nresult = processor.process(\"invoice.pdf\", prompt, schema)\n</code></pre>"},{"location":"provider-chains/","title":"Provider Chains","text":"<p>Provider chains allow automatic fallback between multiple providers for reliability and cost optimization.</p>"},{"location":"provider-chains/#quick-start","title":"Quick Start","text":"<pre><code>from strutex import DocumentProcessor, ProviderChain, local_first_chain\n\n# Use a pre-built chain\nprocessor = DocumentProcessor(provider=local_first_chain())\n\n# Or create a custom chain\nfrom strutex import GeminiProvider, OllamaProvider, OpenAIProvider\n\nchain = ProviderChain([\n    OllamaProvider(model=\"llama3.2-vision\"),  # Try local first\n    GeminiProvider(),                          # Then Gemini\n    OpenAIProvider()                           # Finally OpenAI\n])\n\nprocessor = DocumentProcessor(provider=chain)\n</code></pre>"},{"location":"provider-chains/#how-it-works","title":"How It Works","text":"<p>When you call <code>process()</code> on a ProviderChain:</p> <ol> <li>The first provider attempts the extraction</li> <li>If it fails (any exception), the chain moves to the next provider</li> <li>Process continues until one succeeds or all fail</li> <li>If all fail, raises <code>ProviderChainError</code> with details</li> </ol> <pre><code>graph LR\n    A[Request] --&gt; B[Provider 1]\n    B --&gt;|Success| C[Return Result]\n    B --&gt;|Fail| D[Provider 2]\n    D --&gt;|Success| C\n    D --&gt;|Fail| E[Provider 3]\n    E --&gt;|Success| C\n    E --&gt;|Fail| F[ProviderChainError]</code></pre>"},{"location":"provider-chains/#pre-built-chains","title":"Pre-built Chains","text":""},{"location":"provider-chains/#local_first_chain","title":"local_first_chain()","text":"<p>Prefers local/free providers:</p> <pre><code>from strutex import local_first_chain\n\nchain = local_first_chain()\n# Order: Ollama \u2192 Gemini \u2192 OpenAI\n</code></pre>"},{"location":"provider-chains/#cost_optimized_chain","title":"cost_optimized_chain()","text":"<p>Ordered by cost (cheapest first):</p> <pre><code>from strutex import cost_optimized_chain\n\nchain = cost_optimized_chain()\n# Order: Ollama (free) \u2192 Gemini \u2192 Anthropic \u2192 OpenAI\n</code></pre>"},{"location":"provider-chains/#custom-chains","title":"Custom Chains","text":""},{"location":"provider-chains/#using-provider-instances","title":"Using Provider Instances","text":"<pre><code>from strutex import ProviderChain, OllamaProvider, GeminiProvider\n\nchain = ProviderChain([\n    OllamaProvider(model=\"llama3.2-vision\", timeout=30),\n    GeminiProvider(model=\"gemini-2.5-flash\")\n])\n</code></pre>"},{"location":"provider-chains/#using-provider-names","title":"Using Provider Names","text":"<pre><code>from strutex.providers import create_fallback_chain\n\n# Resolves provider names automatically\nchain = create_fallback_chain(\"ollama\", \"gemini\", \"openai\")\n</code></pre>"},{"location":"provider-chains/#fallback-callbacks","title":"Fallback Callbacks","text":"<p>Get notified when fallback occurs:</p> <pre><code>def on_fallback(provider, error):\n    print(f\"Provider {provider.__class__.__name__} failed: {error}\")\n    # Log, send alert, etc.\n\nchain = ProviderChain(\n    providers=[\"ollama\", \"gemini\"],\n    on_fallback=on_fallback\n)\n</code></pre>"},{"location":"provider-chains/#tracking-which-provider-succeeded","title":"Tracking Which Provider Succeeded","text":"<pre><code>chain = ProviderChain([\"ollama\", \"gemini\", \"openai\"])\n\nresult = chain.process(file_path, prompt, schema, mime_type)\n\n# Check which provider was used\nprint(f\"Used: {chain.last_provider.__class__.__name__}\")\n</code></pre>"},{"location":"provider-chains/#async-support","title":"Async Support","text":"<pre><code>import asyncio\n\nasync def extract():\n    chain = ProviderChain([\"ollama\", \"gemini\"])\n    result = await chain.aprocess(file_path, prompt, schema, mime_type)\n    return result\n\nresult = asyncio.run(extract())\n</code></pre>"},{"location":"provider-chains/#error-handling","title":"Error Handling","text":"<pre><code>from strutex.providers import ProviderChain, ProviderChainError\n\nchain = ProviderChain([\"ollama\", \"gemini\"])\n\ntry:\n    result = chain.process(...)\nexcept ProviderChainError as e:\n    print(f\"All providers failed: {e}\")\n\n    # Access individual errors\n    for provider, error in e.errors:\n        print(f\"  - {provider.__class__.__name__}: {error}\")\n</code></pre>"},{"location":"provider-chains/#available-providers","title":"Available Providers","text":"Provider Cost Priority Capabilities <code>OllamaProvider</code> 0.0 40 vision, local <code>GroqProvider</code> 0.3 45 fast, vision <code>GeminiProvider</code> 1.0 50 vision <code>AnthropicProvider</code> 1.5 55 vision, large_context <code>OpenAIProvider</code> 2.0 60 vision, function_calling"},{"location":"provider-chains/#best-practices","title":"Best Practices","text":"<ol> <li>Put cheapest/fastest providers first for cost optimization</li> <li>Put most reliable providers last as final fallback</li> <li>Set appropriate timeouts on each provider</li> <li>Use callbacks to log/alert on failures</li> <li>Check <code>last_provider</code> to understand usage patterns</li> </ol>"},{"location":"providers/","title":"Providers","text":"<p>LLM providers handle the actual document processing via their respective APIs.</p>"},{"location":"providers/#built-in-providers","title":"Built-in Providers","text":"<p>strutex includes 6 production-ready providers:</p> Provider Cost Priority Capabilities Env Variable <code>GeminiProvider</code> 1.0 50 vision <code>GOOGLE_API_KEY</code> <code>OpenAIProvider</code> 2.0 60 vision, function_calling <code>OPENAI_API_KEY</code> <code>AnthropicProvider</code> 1.5 55 vision, large_context <code>ANTHROPIC_API_KEY</code> <code>OllamaProvider</code> 0.0 40 vision, local <code>OLLAMA_HOST</code> <code>GroqProvider</code> 0.3 45 fast, vision <code>GROQ_API_KEY</code> <code>LangdockProvider</code> 1.0 55 enterprise, multi_model <code>LANGDOCK_API_KEY</code>"},{"location":"providers/#geminiprovider","title":"GeminiProvider","text":"<p>Google's Gemini models (default provider).</p> <pre><code>from strutex import DocumentProcessor, GeminiProvider\n\n# Via string\nprocessor = DocumentProcessor(provider=\"gemini\")\n\n# Via instance (more control)\nprovider = GeminiProvider(\n    api_key=\"...\",  # or set GOOGLE_API_KEY\n    model=\"gemini-2.5-flash\"\n)\nprocessor = DocumentProcessor(provider=provider)\n</code></pre> <p>Features:</p> <ul> <li>Native PDF/image processing (vision)</li> <li>Structured JSON output</li> <li>Fast and cost-effective</li> </ul>"},{"location":"providers/#openaiprovider","title":"OpenAIProvider","text":"<p>OpenAI GPT-4o and GPT-4 Vision.</p> <pre><code>from strutex import OpenAIProvider\n\nprovider = OpenAIProvider(\n    api_key=\"...\",  # or set OPENAI_API_KEY\n    model=\"gpt-4o\",\n    base_url=None,  # Custom endpoint (Azure, proxy)\n    timeout=120.0\n)\n</code></pre> <p>Features:</p> <ul> <li>Vision (GPT-4o, GPT-4 Vision)</li> <li>JSON response format</li> <li>Function calling support</li> <li>Custom base URL for Azure/proxies</li> </ul> <p>Models:</p> <ul> <li><code>gpt-4o</code> (recommended)</li> <li><code>gpt-4-turbo</code></li> <li><code>gpt-4-vision-preview</code></li> </ul>"},{"location":"providers/#anthropicprovider","title":"AnthropicProvider","text":"<p>Claude 3.5 Sonnet and Claude 3 Opus.</p> <pre><code>from strutex import AnthropicProvider\n\nprovider = AnthropicProvider(\n    api_key=\"...\",  # or set ANTHROPIC_API_KEY\n    model=\"claude-3-5-sonnet-20241022\",\n    timeout=120.0\n)\n</code></pre> <p>Features:</p> <ul> <li>Vision support (Claude 3+)</li> <li>Large context window (100k+ tokens)</li> <li>Excellent at following instructions</li> </ul> <p>Models:</p> <ul> <li><code>claude-3-5-sonnet-20241022</code> (recommended)</li> <li><code>claude-3-opus-20240229</code></li> <li><code>claude-3-haiku-20240307</code></li> </ul>"},{"location":"providers/#ollamaprovider","title":"OllamaProvider","text":"<p>Local models via Ollama (free, air-gapped).</p> <pre><code>from strutex import OllamaProvider\n\nprovider = OllamaProvider(\n    host=\"http://localhost:11434\",  # or set OLLAMA_HOST\n    model=\"llama3.2-vision\",\n    timeout=120.0\n)\n</code></pre> <p>Features:</p> <ul> <li>Free (no API costs)</li> <li>Air-gapped/offline support</li> <li>Vision with multimodal models</li> <li>Respects <code>OLLAMA_HOST</code> env var</li> </ul> <p>Models:</p> <ul> <li><code>llama3.2-vision</code> (recommended for vision)</li> <li><code>llama3.2</code></li> <li><code>llava</code></li> <li><code>bakllava</code></li> </ul> <p>Local-first Development</p> <p>Use Ollama for development to avoid API costs, then switch to cloud providers for production.</p>"},{"location":"providers/#groqprovider","title":"GroqProvider","text":"<p>Ultra-fast inference at low cost.</p> <pre><code>from strutex import GroqProvider\n\nprovider = GroqProvider(\n    api_key=\"...\",  # or set GROQ_API_KEY\n    model=\"llama-3.3-70b-versatile\",\n    timeout=60.0\n)\n</code></pre> <p>Features:</p> <ul> <li>Extremely fast inference (100+ tokens/sec)</li> <li>Very low cost</li> <li>JSON mode support</li> <li>Vision with specific models</li> </ul> <p>Models:</p> <ul> <li><code>llama-3.3-70b-versatile</code> (recommended)</li> <li><code>llama-3.2-90b-vision-preview</code> (vision)</li> <li><code>llama-3.2-11b-vision-preview</code> (vision)</li> <li><code>mixtral-8x7b-32768</code></li> </ul>"},{"location":"providers/#langdockprovider","title":"LangdockProvider","text":"<p>Enterprise-grade access to multiple LLM models via a unified API.</p> <pre><code>from strutex import LangdockProvider\n\nprovider = LangdockProvider(\n    api_key=\"...\",  # or set LANGDOCK_API_KEY\n    model=\"gemini-2.5-flash\",\n    temperature=0.0\n)\n</code></pre> <p>Features:</p> <ul> <li>Enterprise-grade API access</li> <li>Multiple model support (Gemini, GPT-4, Claude)</li> <li>Document upload with attachment handling</li> <li>Structured JSON output via inline assistant</li> </ul> <p>Models:</p> <ul> <li><code>gemini-2.5-flash</code> (recommended)</li> <li><code>gemini-2.5-pro</code></li> <li><code>gpt-4o</code></li> <li><code>gpt-4-turbo</code></li> <li><code>claude-3-5-sonnet</code></li> <li><code>claude-3-opus</code></li> </ul> <p>Enterprise Usage</p> <p>Langdock is ideal for enterprise environments where you need access to multiple LLM providers through a single API.</p>"},{"location":"providers/#retry-configuration","title":"Retry Configuration","text":"<p>All providers support retry with exponential backoff:</p> <pre><code>from strutex.providers import RetryConfig, OpenAIProvider\n\nretry = RetryConfig(\n    max_retries=3,\n    base_delay=1.0,\n    max_delay=60.0,\n    exponential_base=2.0\n)\n\nprovider = OpenAIProvider(retry_config=retry)\n</code></pre>"},{"location":"providers/#health-checks","title":"Health Checks","text":"<p>Check if a provider is available:</p> <pre><code>from strutex import GeminiProvider, OllamaProvider\n\n# Check if package installed and API key set\nprint(f\"Gemini: {GeminiProvider.health_check()}\")\nprint(f\"Ollama: {OllamaProvider.health_check()}\")  # Checks if server running\n</code></pre>"},{"location":"providers/#custom-providers","title":"Custom Providers","text":"<p>Create your own provider:</p> <pre><code>from strutex.providers import Provider\n\nclass MyProvider(Provider, name=\"myprovider\"):\n    \"\"\"Custom provider implementation.\"\"\"\n\n    strutex_plugin_version = \"1.0\"\n    priority = 50\n    cost = 1.0\n    capabilities = [\"vision\"]\n\n    def __init__(self, api_key=None, model=\"default\"):\n        self.api_key = api_key\n        self.model = model\n\n    def process(self, file_path, prompt, schema, mime_type, **kwargs):\n        # Your implementation here\n        ...\n        return {\"extracted\": \"data\"}\n\n    @classmethod\n    def health_check(cls):\n        # Check if provider is ready\n        return True\n</code></pre> <p>Usage:</p> <pre><code>processor = DocumentProcessor(provider=\"myprovider\")\n</code></pre>"},{"location":"providers/#provider-selection","title":"Provider Selection","text":"<p>Choose the right provider for your needs:</p> Use Case Recommended Provider Development/Testing <code>OllamaProvider</code> (free) Production (cost-sensitive) <code>GroqProvider</code> or <code>GeminiProvider</code> Production (quality) <code>OpenAIProvider</code> or <code>AnthropicProvider</code> Air-gapped environments <code>OllamaProvider</code> Large documents <code>AnthropicProvider</code> (large context) Speed-critical <code>GroqProvider</code>"},{"location":"providers/#see-also","title":"See Also","text":"<ul> <li>Provider Chains - Automatic fallback</li> <li>Caching - Reduce API costs</li> </ul>"},{"location":"pydantic/","title":"Pydantic Support","text":"<p>Use Pydantic models for type-safe document extraction with automatic validation.</p>"},{"location":"pydantic/#quick-start","title":"Quick Start","text":"<pre><code>from pydantic import BaseModel, Field\nfrom strutex import DocumentProcessor\n\nclass Invoice(BaseModel):\n    invoice_number: str = Field(description=\"Unique ID\")\n    total: float = Field(description=\"Total amount\")\n\nprocessor = DocumentProcessor(provider=\"gemini\")\nresult = processor.process(\n    \"invoice.pdf\",\n    \"Extract invoice data\",\n    model=Invoice  # Use model= instead of schema=\n)\n\n# result is a validated Invoice instance!\nprint(result.invoice_number)\nprint(result.total)\n</code></pre>"},{"location":"pydantic/#nested-models","title":"Nested Models","text":"<pre><code>from typing import List, Optional\n\nclass LineItem(BaseModel):\n    description: str\n    quantity: int\n    unit_price: float\n    total: float\n\nclass Vendor(BaseModel):\n    name: str\n    address: Optional[str] = None\n\nclass Invoice(BaseModel):\n    invoice_number: str\n    date: str = Field(description=\"YYYY-MM-DD format\")\n    vendor: Vendor\n    items: List[LineItem]\n    subtotal: float\n    tax: Optional[float] = None\n    total: float\n</code></pre>"},{"location":"pydantic/#field-descriptions","title":"Field Descriptions","text":"<p>Use <code>Field(description=...)</code> to guide the LLM:</p> <pre><code>class Invoice(BaseModel):\n    invoice_number: str = Field(\n        description=\"The unique invoice identifier, e.g. INV-2024-001\"\n    )\n    date: str = Field(\n        description=\"Invoice date in YYYY-MM-DD format\"\n    )\n    total: float = Field(\n        description=\"Final payable amount including tax\"\n    )\n</code></pre>"},{"location":"pydantic/#manual-conversion","title":"Manual Conversion","text":"<p>You can also convert Pydantic models to strutex schemas manually:</p> <pre><code>from strutex import pydantic_to_schema, validate_with_pydantic\n\n# Convert model to schema\nschema = pydantic_to_schema(Invoice)\n\n# Later, validate dict data\ndata = {\"invoice_number\": \"INV-001\", \"total\": 100.0}\ninvoice = validate_with_pydantic(data, Invoice)\n</code></pre>"},{"location":"pydantic/#validation-errors","title":"Validation Errors","text":"<p>Pydantic validation runs after LLM extraction:</p> <pre><code>from pydantic import ValidationError\n\ntry:\n    result = processor.process(file, prompt, model=Invoice)\nexcept ValidationError as e:\n    print(f\"Output didn't match schema: {e}\")\n</code></pre>"},{"location":"schema-types/","title":"Schema Types","text":"<p>Define your expected output structure using strutex's schema types.</p>"},{"location":"schema-types/#basic-types","title":"Basic Types","text":""},{"location":"schema-types/#string","title":"String","text":"<pre><code>from strutex import String\n\nname = String(description=\"Customer name\")\noptional_name = String(description=\"Middle name\", nullable=True)\n</code></pre>"},{"location":"schema-types/#number","title":"Number","text":"<p>For floating-point values:</p> <pre><code>from strutex import Number\n\nprice = Number(description=\"Item price\")\n</code></pre>"},{"location":"schema-types/#integer","title":"Integer","text":"<p>For whole numbers:</p> <pre><code>from strutex import Integer\n\nquantity = Integer(description=\"Item count\")\n</code></pre>"},{"location":"schema-types/#boolean","title":"Boolean","text":"<pre><code>from strutex import Boolean\n\nis_paid = Boolean(description=\"Payment status\")\n</code></pre>"},{"location":"schema-types/#complex-types","title":"Complex Types","text":""},{"location":"schema-types/#array","title":"Array","text":"<pre><code>from strutex import Array, String, Object\n\n# Array of strings\ntags = Array(items=String(), description=\"Item tags\")\n\n# Array of objects\nitems = Array(\n    items=Object(\n        properties={\n            \"name\": String(),\n            \"price\": Number()\n        }\n    )\n)\n</code></pre>"},{"location":"schema-types/#object","title":"Object","text":"<pre><code>from strutex import Object, String\n\naddress = Object(\n    description=\"Shipping address\",\n    properties={\n        \"street\": String(),\n        \"city\": String(),\n        \"zip\": String()\n    }\n)\n</code></pre>"},{"location":"schema-types/#required-vs-optional","title":"Required vs Optional","text":"<p>By default, all properties are required. To make fields optional:</p> Explicit RequiredNullable Fields <pre><code>schema = Object(\n    properties={\n        \"name\": String(),\n        \"email\": String()\n    },\n    required=[\"name\"]  # Only name is required\n)\n</code></pre> <pre><code>schema = Object(\n    properties={\n        \"name\": String(),\n        \"notes\": String(nullable=True)\n    }\n)\n</code></pre>"},{"location":"schema-types/#complete-example","title":"Complete Example","text":"<pre><code>from strutex import Object, String, Number, Integer, Array, Boolean\n\ninvoice_schema = Object(\n    description=\"Complete invoice\",\n    properties={\n        \"invoice_number\": String(description=\"Unique ID\"),\n        \"date\": String(description=\"YYYY-MM-DD\"),\n        \"vendor\": Object(\n            properties={\n                \"name\": String(),\n                \"address\": String(nullable=True)\n            }\n        ),\n        \"items\": Array(\n            items=Object(\n                properties={\n                    \"description\": String(),\n                    \"quantity\": Integer(),\n                    \"price\": Number()\n                }\n            )\n        ),\n        \"total\": Number(),\n        \"paid\": Boolean()\n    }\n)\n</code></pre>"},{"location":"schemas/","title":"Built-in Schemas","text":"<p>strutex includes ready-to-use Pydantic schemas for common document types. Use these directly with <code>DocumentProcessor</code> for instant structured extraction.</p>"},{"location":"schemas/#quick-start","title":"Quick Start","text":"<pre><code>from strutex import DocumentProcessor\nfrom strutex.schemas import INVOICE_US\n\nprocessor = DocumentProcessor(provider=\"gemini\")\ninvoice = processor.process(\n    \"invoice.pdf\",\n    \"Extract invoice details\",\n    model=INVOICE_US\n)\n\nprint(f\"Invoice #{invoice.invoice_number}\")\nprint(f\"Total: ${invoice.total}\")\nprint(f\"Items: {len(invoice.line_items)}\")\n</code></pre>"},{"location":"schemas/#available-schemas","title":"Available Schemas","text":""},{"location":"schemas/#invoices","title":"Invoices","text":"Schema Description Key Fields <code>INVOICE_GENERIC</code> Universal invoice format invoice_number, vendor, customer, line_items, total <code>INVOICE_US</code> US-style with sales tax + sales_tax, state_tax_rate, ein <code>INVOICE_EU</code> EU-style with VAT + vat_number, vat_rate, reverse_charge <pre><code>from strutex.schemas import INVOICE_GENERIC, INVOICE_US, INVOICE_EU\n</code></pre>"},{"location":"schemas/#receipts","title":"Receipts","text":"Schema Description Key Fields <code>RECEIPT</code> Retail/restaurant receipts merchant_name, items, subtotal, tax, total, payment_method <pre><code>from strutex.schemas import RECEIPT\n\nreceipt = processor.process(\"receipt.jpg\", \"Extract receipt\", model=RECEIPT)\nprint(f\"Store: {receipt.merchant_name}, Total: ${receipt.total}\")\n</code></pre>"},{"location":"schemas/#purchase-orders","title":"Purchase Orders","text":"Schema Description Key Fields <code>PURCHASE_ORDER</code> B2B purchase orders po_number, vendor_name, line_items, ship_to, payment_terms <pre><code>from strutex.schemas import PURCHASE_ORDER\n</code></pre>"},{"location":"schemas/#shipping-documents","title":"Shipping Documents","text":"Schema Description Key Fields <code>BILL_OF_LADING</code> Ocean freight B/L bl_number, shipper, consignee, containers, cargo, port_of_loading, port_of_discharge <pre><code>from strutex.schemas import BILL_OF_LADING\n\nbol = processor.process(\"bl.pdf\", \"Extract B/L\", model=BILL_OF_LADING)\nprint(f\"{bol.port_of_loading} \u2192 {bol.port_of_discharge}\")\n</code></pre>"},{"location":"schemas/#financial-documents","title":"Financial Documents","text":"Schema Description Key Fields <code>BANK_STATEMENT</code> Bank account statements account_number, opening_balance, closing_balance, transactions <pre><code>from strutex.schemas import BANK_STATEMENT\n</code></pre>"},{"location":"schemas/#resumescvs","title":"Resumes/CVs","text":"Schema Description Key Fields <code>RESUME</code> Professional resumes name, email, skills, work_experience, education, certifications <pre><code>from strutex.schemas import RESUME\n\nresume = processor.process(\"resume.pdf\", \"Extract resume\", model=RESUME)\nprint(f\"{resume.name}: {len(resume.work_experience)} positions\")\n</code></pre>"},{"location":"schemas/#legal-documents","title":"Legal Documents","text":"Schema Description Key Fields <code>CONTRACT_CLAUSE</code> Contract key terms title, parties, effective_date, payment_terms, governing_law <pre><code>from strutex.schemas import CONTRACT_CLAUSE\n</code></pre>"},{"location":"schemas/#extending-schemas","title":"Extending Schemas","text":"<p>Create custom schemas by inheriting from built-in ones:</p> <pre><code>from strutex.schemas import InvoiceGeneric\nfrom pydantic import Field\n\nclass MyInvoice(InvoiceGeneric):\n    \"\"\"Custom invoice with company-specific fields.\"\"\"\n    internal_code: str = Field(..., description=\"Internal tracking code\")\n    department: str = Field(None, description=\"Department to charge\")\n\n# Use your custom schema\nresult = processor.process(\"invoice.pdf\", \"Extract invoice\", model=MyInvoice)\n</code></pre>"},{"location":"schemas/#schema-reference","title":"Schema Reference","text":""},{"location":"schemas/#invoicegeneric-fields","title":"InvoiceGeneric Fields","text":"Field Type Description <code>invoice_number</code> str Invoice number/ID <code>invoice_date</code> str? Invoice date <code>due_date</code> str? Payment due date <code>vendor</code> Party? Seller information <code>customer</code> Party? Buyer information <code>line_items</code> list List of line items <code>subtotal</code> float? Subtotal before tax <code>tax_amount</code> float? Tax amount <code>total</code> float Grand total <code>payment_terms</code> str? Payment terms"},{"location":"schemas/#receipt-fields","title":"Receipt Fields","text":"Field Type Description <code>merchant_name</code> str Store name <code>receipt_number</code> str? Receipt/transaction number <code>date</code> str? Transaction date <code>items</code> list Purchased items <code>subtotal</code> float? Before tax <code>tax</code> float? Tax amount <code>total</code> float Total paid <code>payment_method</code> str? Cash, Card, etc."},{"location":"schemas/#billoflading-fields","title":"BillOfLading Fields","text":"Field Type Description <code>bl_number</code> str B/L number <code>shipper</code> str? Shipper name/address <code>consignee</code> str? Consignee name/address <code>carrier</code> str? Shipping line <code>vessel_name</code> str? Ship name <code>port_of_loading</code> str? POL <code>port_of_discharge</code> str? POD <code>containers</code> list Container details <code>cargo</code> list Cargo details"},{"location":"schemas/#best-practices","title":"Best Practices","text":"<ol> <li>Use specific schemas when possible - <code>INVOICE_US</code> over <code>INVOICE_GENERIC</code> for better accuracy</li> <li>Extend for custom fields - Inherit and add company-specific fields</li> <li>Validate after extraction - Use Pydantic's validation:</li> </ol> <pre><code>try:\n    invoice = processor.process(\"doc.pdf\", \"Extract\", model=INVOICE_US)\nexcept ValidationError as e:\n    print(f\"Extraction incomplete: {e}\")\n</code></pre>"},{"location":"security/","title":"Security Layer","text":"<p>Protect against prompt injection and data leaks with strutex's pluggable security layer.</p> <p>Security is Opt-In</p> <p>Security features are not enabled by default. You must explicitly enable them.</p>"},{"location":"security/#quick-start","title":"Quick Start","text":"Default ChainPer-Request <pre><code>from strutex import DocumentProcessor\nfrom strutex.security import default_security_chain\n\nprocessor = DocumentProcessor(\n    provider=\"gemini\",\n    security=default_security_chain()\n)\n</code></pre> <pre><code>processor = DocumentProcessor(provider=\"gemini\")\n\n# Enable for specific request\nresult = processor.process(file, prompt, schema, security=True)\n</code></pre>"},{"location":"security/#built-in-plugins","title":"Built-in Plugins","text":""},{"location":"security/#inputsanitizer","title":"InputSanitizer","text":"<p>Cleans and normalizes input text.</p> <pre><code>from strutex.security import InputSanitizer\n\nsanitizer = InputSanitizer(\n    collapse_whitespace=True,   # \"Hello   World\" \u2192 \"Hello World\"\n    normalize_unicode=True,     # NFKC normalization\n    remove_invisible=True,      # Remove zero-width chars\n    max_length=50000            # Reject if too long\n)\n</code></pre>"},{"location":"security/#promptinjectiondetector","title":"PromptInjectionDetector","text":"<p>Detects common prompt injection patterns.</p> <pre><code>from strutex.security import PromptInjectionDetector\n\ndetector = PromptInjectionDetector()\n\nresult = detector.validate_input(\"Ignore previous instructions\")\nprint(result.valid)   # False\nprint(result.reason)  # \"Potential prompt injection detected\"\n</code></pre> <p>Detected patterns:</p> <ul> <li><code>\"Ignore previous instructions\"</code></li> <li><code>\"You are now X\"</code></li> <li><code>\"Show me your system prompt\"</code></li> <li>XML/HTML delimiter attacks</li> </ul>"},{"location":"security/#outputvalidator","title":"OutputValidator","text":"<p>Checks LLM output for sensitive data.</p> <pre><code>from strutex.security import OutputValidator\n\nvalidator = OutputValidator(check_secrets=True)\n\nresult = validator.validate_output({\"key\": \"sk-1234...\"})\nprint(result.valid)   # False\nprint(result.reason)  # \"Potential API key detected\"\n</code></pre>"},{"location":"security/#security-chain","title":"Security Chain","text":"<p>Combine multiple plugins:</p> <pre><code>from strutex.security import SecurityChain, InputSanitizer, PromptInjectionDetector\n\nchain = SecurityChain([\n    InputSanitizer(collapse_whitespace=True),\n    PromptInjectionDetector(),\n])\n\nresult = chain.validate_input(\"Ignore    all   instructions\")\nprint(result.valid)   # False (injection detected)\nprint(result.text)    # \"Ignore all instructions\" (sanitized)\n</code></pre>"},{"location":"security/#custom-security-plugin","title":"Custom Security Plugin","text":"<pre><code>from strutex.plugins import SecurityPlugin, SecurityResult, register\nimport re\n\n@register(\"security\")\nclass PIIRedactor(SecurityPlugin):\n    \"\"\"Redact emails from output.\"\"\"\n\n    def validate_output(self, data):\n        def redact(obj):\n            if isinstance(obj, str):\n                return re.sub(r'\\S+@\\S+', '[EMAIL]', obj)\n            if isinstance(obj, dict):\n                return {k: redact(v) for k, v in obj.items()}\n            if isinstance(obj, list):\n                return [redact(i) for i in obj]\n            return obj\n\n        return SecurityResult(valid=True, data=redact(data))\n</code></pre>"},{"location":"security/#handling-security-errors","title":"Handling Security Errors","text":"<pre><code>from strutex.processor import SecurityError\n\ntry:\n    result = processor.process(file, prompt, schema, security=True)\nexcept SecurityError as e:\n    print(f\"Security check failed: {e}\")\n</code></pre>"},{"location":"streaming/","title":"Streaming","text":"<p>Stream extraction results in real-time for responsive applications.</p>"},{"location":"streaming/#quick-start","title":"Quick Start","text":"<pre><code>from strutex import DocumentProcessor, StreamingProcessor\nfrom strutex.schemas import INVOICE_US\n\nprocessor = DocumentProcessor(provider=\"gemini\")\nstreamer = StreamingProcessor(processor)\n\n# Stream extraction\nfor chunk in streamer.stream(\"invoice.pdf\", \"Extract invoice\", INVOICE_US):\n    print(chunk.content, end=\"\", flush=True)\n</code></pre>"},{"location":"streaming/#streamingprocessor","title":"StreamingProcessor","text":"<p>Wrap any processor for streaming:</p> <pre><code>from strutex import StreamingProcessor\n\nstreamer = StreamingProcessor(processor)\n\n# Sync streaming\nfor chunk in streamer.stream(file_path, prompt, schema):\n    print(chunk.content, end=\"\")\n\n    if chunk.is_complete:\n        print(\"\\n--- Complete ---\")\n</code></pre>"},{"location":"streaming/#streamchunk","title":"StreamChunk","text":"<p>Each chunk contains:</p> Field Type Description <code>content</code> str New content in this chunk <code>is_complete</code> bool Whether this is the final chunk <code>accumulated</code> str All content received so far <code>metadata</code> dict Optional metadata <pre><code>for chunk in streamer.stream(...):\n    # Current chunk\n    print(f\"Content: {chunk.content}\")\n\n    # Running total\n    print(f\"So far: {chunk.accumulated}\")\n\n    # Check if done\n    if chunk.is_complete:\n        final_result = json.loads(chunk.accumulated)\n</code></pre>"},{"location":"streaming/#async-streaming","title":"Async Streaming","text":"<pre><code>import asyncio\n\nasync def stream_extract():\n    async for chunk in streamer.astream(file_path, prompt, schema):\n        print(chunk.content, end=\"\", flush=True)\n\nasyncio.run(stream_extract())\n</code></pre>"},{"location":"streaming/#utility-functions","title":"Utility Functions","text":""},{"location":"streaming/#stream_to_string","title":"stream_to_string","text":"<p>Consume entire stream and return final result:</p> <pre><code>from strutex.providers import stream_to_string\n\nresult_str = stream_to_string(streamer.stream(...))\nresult = json.loads(result_str)\n</code></pre>"},{"location":"streaming/#stream_with_callback","title":"stream_with_callback","text":"<p>Stream with callbacks:</p> <pre><code>from strutex.providers import stream_with_callback\n\ndef on_chunk(chunk):\n    print(chunk.content, end=\"\", flush=True)\n\ndef on_complete(result):\n    print(f\"\\n\\nDone! {len(result)} characters\")\n\nresult = stream_with_callback(\n    streamer.stream(...),\n    on_chunk=on_chunk,\n    on_complete=on_complete\n)\n</code></pre>"},{"location":"streaming/#async-helpers","title":"Async Helpers","text":"<pre><code>from strutex.providers.streaming import astream_to_string\n\nasync def get_result():\n    result_str = await astream_to_string(streamer.astream(...))\n    return json.loads(result_str)\n</code></pre>"},{"location":"streaming/#provider-streaming-support","title":"Provider Streaming Support","text":"<p>Default Behavior</p> <p>By default, StreamingProcessor falls back to non-streaming mode by calling <code>process()</code> and yielding a single complete chunk.</p> <p>Providers can implement native streaming by adding a <code>stream()</code> method:</p> <pre><code>from strutex.providers import Provider\nfrom strutex.providers.streaming import StreamingMixin, StreamChunk\n\nclass MyProvider(Provider, StreamingMixin):\n    def stream(self, file_path, prompt, schema, mime_type, **kwargs):\n        # Implement native streaming\n        for partial in self.api.stream_generate(...):\n            yield StreamChunk(\n                content=partial,\n                is_complete=False,\n                accumulated=self._accumulated\n            )\n\n        yield StreamChunk(\n            content=\"\",\n            is_complete=True,\n            accumulated=self._accumulated\n        )\n</code></pre>"},{"location":"streaming/#use-cases","title":"Use Cases","text":""},{"location":"streaming/#progress-indication","title":"Progress Indication","text":"<pre><code>import sys\n\nfor chunk in streamer.stream(...):\n    sys.stdout.write(f\"\\rReceived {len(chunk.accumulated)} chars...\")\n    sys.stdout.flush()\n\nprint(\"\\nDone!\")\n</code></pre>"},{"location":"streaming/#real-time-ui-updates","title":"Real-time UI Updates","text":"<pre><code># In a web framework (pseudo-code)\nasync def stream_endpoint(file_path, prompt, schema):\n    async for chunk in streamer.astream(file_path, prompt, schema):\n        yield f\"data: {json.dumps({'content': chunk.content})}\\n\\n\"\n</code></pre>"},{"location":"streaming/#timeout-with-partial-results","title":"Timeout with Partial Results","text":"<pre><code>import signal\n\nclass TimeoutError(Exception):\n    pass\n\ndef timeout_handler(signum, frame):\n    raise TimeoutError()\n\nsignal.signal(signal.SIGALRM, timeout_handler)\nsignal.alarm(30)  # 30 second timeout\n\ntry:\n    result = \"\"\n    for chunk in streamer.stream(...):\n        result = chunk.accumulated\n    signal.alarm(0)  # Cancel timeout\nexcept TimeoutError:\n    print(f\"Timed out! Partial result: {result[:100]}...\")\n</code></pre>"},{"location":"streaming/#best-practices","title":"Best Practices","text":"<ol> <li>Use <code>flush=True</code> when printing streaming output</li> <li>Handle incomplete streams gracefully</li> <li>Parse JSON only after <code>is_complete=True</code></li> <li>Use async streaming in async applications</li> <li>Implement proper error handling for network issues</li> </ol>"},{"location":"validators/","title":"Validators","text":"<p>Validate LLM output for correctness and data quality.</p>"},{"location":"validators/#overview","title":"Overview","text":"<p>Validators check extracted data against rules and can be composed into chains.</p> <pre><code>from strutex import SchemaValidator, SumValidator, ValidationChain\n\nchain = ValidationChain([\n    SchemaValidator(),\n    SumValidator(tolerance=0.01),\n])\n\nresult = chain.validate(data, schema)\nif not result.valid:\n    print(result.issues)\n</code></pre>"},{"location":"validators/#built-in-validators","title":"Built-in Validators","text":""},{"location":"validators/#schemavalidator","title":"SchemaValidator","text":"<p>Ensures output structure matches expected schema.</p> <pre><code>from strutex import SchemaValidator, Object, String, Number\n\nschema = Object(properties={\n    \"invoice_number\": String(),\n    \"total\": Number(),\n})\n\nvalidator = SchemaValidator()\nresult = validator.validate(data, schema)\n</code></pre> <p>Checks:</p> <ul> <li>Required fields are present</li> <li>Field types match (string, number, boolean, array, object)</li> <li>Nested objects validated recursively</li> </ul>"},{"location":"validators/#sumvalidator","title":"SumValidator","text":"<p>Verifies line items sum to stated total.</p> <pre><code>from strutex import SumValidator\n\nvalidator = SumValidator(\n    items_field=\"line_items\",\n    amount_field=\"price\",\n    total_field=\"grand_total\",\n    tolerance=0.01\n)\n\nresult = validator.validate({\n    \"line_items\": [{\"price\": 10.00}, {\"price\": 20.00}],\n    \"grand_total\": 30.00\n})\n# result.valid == True\n</code></pre>"},{"location":"validators/#datevalidator","title":"DateValidator","text":"<p>Validates date formats and ranges.</p> <pre><code>from strutex import DateValidator\n\nvalidator = DateValidator(\n    date_fields=[\"invoice_date\", \"due_date\"],\n    min_year=2020,\n    max_year=2030\n)\n\nresult = validator.validate({\n    \"invoice_date\": \"2024-01-15\",\n    \"due_date\": \"2024-02-15\"\n})\n</code></pre> <p>Accepted formats: ISO, European (DD.MM.YYYY), US (MM/DD/YYYY)</p>"},{"location":"validators/#validation-chains","title":"Validation Chains","text":"<p>Compose multiple validators:</p> <pre><code>from strutex import ValidationChain, SchemaValidator, SumValidator, DateValidator\n\nchain = ValidationChain([\n    SchemaValidator(strict=True),\n    SumValidator(tolerance=0.01),\n    DateValidator(),\n], strict=True)  # Stop on first failure\n\nresult = chain.validate(data, schema)\n\nprint(result.valid)   # True/False\nprint(result.issues)  # List of error messages\nprint(result.data)    # Possibly modified data\n</code></pre> <p>Modes:</p> <ul> <li><code>strict=True</code> \u2014 Stop on first failure</li> <li><code>strict=False</code> \u2014 Collect all issues</li> </ul>"},{"location":"validators/#creating-custom-validators","title":"Creating Custom Validators","text":"<pre><code>from strutex.plugins import Validator, ValidationResult\n\nclass EmailValidator(Validator, name=\"email\"):\n    priority = 50\n\n    def validate(self, data, schema=None):\n        issues = []\n        email = data.get(\"email\", \"\")\n\n        if email and \"@\" not in email:\n            issues.append(f\"Invalid email: {email}\")\n\n        return ValidationResult(\n            valid=len(issues) == 0,\n            data=data,\n            issues=issues\n        )\n</code></pre>"},{"location":"validators/#api-reference","title":"API Reference","text":"<p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p> <p>options: show_root_heading: true</p>"},{"location":"validators/#strutex.validators.SchemaValidator","title":"<code>SchemaValidator(strict: bool = False)</code>","text":"<p>               Bases: <code>Validator</code></p> <p>Validates that extracted data matches the expected schema structure.</p> <p>Checks: - Required fields are present - Field types match (string, number, boolean, array, object) - Nested objects are validated recursively</p> ATTRIBUTE DESCRIPTION <code>strict</code> <p>If True, fail on extra fields not in schema</p> <p> </p> <p>Initialize the schema validator.</p> PARAMETER DESCRIPTION <code>strict</code> <p>If True, reject data with fields not in schema</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>strutex/validators/schema.py</code> <pre><code>def __init__(self, strict: bool = False):\n    \"\"\"\n    Initialize the schema validator.\n\n    Args:\n        strict: If True, reject data with fields not in schema\n    \"\"\"\n    self.strict = strict\n</code></pre>"},{"location":"validators/#strutex.validators.SchemaValidator.validate","title":"<code>validate(data: Dict[str, Any], schema: Optional[Schema] = None) -&gt; ValidationResult</code>","text":"<p>Validate data against a schema.</p> PARAMETER DESCRIPTION <code>data</code> <p>The extracted data to validate</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>schema</code> <p>The expected schema structure</p> <p> TYPE: <code>Optional[Schema]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValidationResult</code> <p>ValidationResult with validation status and any issues</p> Source code in <code>strutex/validators/schema.py</code> <pre><code>def validate(self, data: Dict[str, Any], schema: Optional[Schema] = None) -&gt; ValidationResult:\n    \"\"\"\n    Validate data against a schema.\n\n    Args:\n        data: The extracted data to validate\n        schema: The expected schema structure\n\n    Returns:\n        ValidationResult with validation status and any issues\n    \"\"\"\n    if schema is None:\n        return ValidationResult(valid=True, data=data)\n\n    issues = []\n    self._validate_value(data, schema, \"\", issues)\n\n    return ValidationResult(\n        valid=len(issues) == 0,\n        data=data,\n        issues=issues\n    )\n</code></pre>"},{"location":"validators/#strutex.validators.SumValidator","title":"<code>SumValidator(items_field: str = 'items', amount_field: str = 'amount', total_field: str = 'total', tolerance: float = 0.01)</code>","text":"<p>               Bases: <code>Validator</code></p> <p>Validates that line item amounts sum to the stated total.</p> <p>Common use case: Invoice validation where item totals should  match the invoice total.</p> ATTRIBUTE DESCRIPTION <code>items_field</code> <p>Field name containing the list of items</p> <p> </p> <code>amount_field</code> <p>Field name in each item containing the amount</p> <p> </p> <code>total_field</code> <p>Field name containing the expected total</p> <p> </p> <code>tolerance</code> <p>Acceptable difference (for floating point comparison)</p> <p> </p> <p>Initialize the sum validator.</p> PARAMETER DESCRIPTION <code>items_field</code> <p>Name of the field containing line items</p> <p> TYPE: <code>str</code> DEFAULT: <code>'items'</code> </p> <code>amount_field</code> <p>Name of the amount field in each item</p> <p> TYPE: <code>str</code> DEFAULT: <code>'amount'</code> </p> <code>total_field</code> <p>Name of the total field</p> <p> TYPE: <code>str</code> DEFAULT: <code>'total'</code> </p> <code>tolerance</code> <p>Maximum acceptable difference</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.01</code> </p> Source code in <code>strutex/validators/sum.py</code> <pre><code>def __init__(\n    self,\n    items_field: str = \"items\",\n    amount_field: str = \"amount\",\n    total_field: str = \"total\",\n    tolerance: float = 0.01\n):\n    \"\"\"\n    Initialize the sum validator.\n\n    Args:\n        items_field: Name of the field containing line items\n        amount_field: Name of the amount field in each item\n        total_field: Name of the total field\n        tolerance: Maximum acceptable difference\n    \"\"\"\n    self.items_field = items_field\n    self.amount_field = amount_field\n    self.total_field = total_field\n    self.tolerance = tolerance\n</code></pre>"},{"location":"validators/#strutex.validators.SumValidator.validate","title":"<code>validate(data: Dict[str, Any], schema=None) -&gt; ValidationResult</code>","text":"<p>Validate that line items sum to the total.</p> PARAMETER DESCRIPTION <code>data</code> <p>The extracted data to validate</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>schema</code> <p>Not used by this validator</p> <p> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValidationResult</code> <p>ValidationResult indicating if sums match</p> Source code in <code>strutex/validators/sum.py</code> <pre><code>def validate(self, data: Dict[str, Any], schema=None) -&gt; ValidationResult:\n    \"\"\"\n    Validate that line items sum to the total.\n\n    Args:\n        data: The extracted data to validate\n        schema: Not used by this validator\n\n    Returns:\n        ValidationResult indicating if sums match\n    \"\"\"\n    issues = []\n\n    # Get items and total\n    items = data.get(self.items_field, [])\n    total = data.get(self.total_field)\n\n    # Skip if required fields are missing\n    if not items or total is None:\n        return ValidationResult(valid=True, data=data)\n\n    # Calculate sum of items\n    try:\n        items_sum = sum(\n            float(item.get(self.amount_field, 0)) \n            for item in items \n            if isinstance(item, dict)\n        )\n    except (TypeError, ValueError) as e:\n        issues.append(f\"Could not calculate sum: {e}\")\n        return ValidationResult(valid=False, data=data, issues=issues)\n\n    # Compare with tolerance\n    try:\n        total_float = float(total)\n    except (TypeError, ValueError):\n        issues.append(f\"Total field is not a number: {total}\")\n        return ValidationResult(valid=False, data=data, issues=issues)\n\n    difference = abs(items_sum - total_float)\n\n    if difference &gt; self.tolerance:\n        issues.append(\n            f\"Sum mismatch: items sum to {items_sum:.2f}, \"\n            f\"but total is {total_float:.2f} \"\n            f\"(difference: {difference:.2f})\"\n        )\n        return ValidationResult(valid=False, data=data, issues=issues)\n\n    return ValidationResult(valid=True, data=data)\n</code></pre>"},{"location":"validators/#strutex.validators.DateValidator","title":"<code>DateValidator(date_fields: Optional[List[str]] = None, formats: Optional[List[str]] = None, min_year: int = 1900, max_year: int = 2100)</code>","text":"<p>               Bases: <code>Validator</code></p> <p>Validates date fields for format and range.</p> <p>Checks: - Date strings match expected formats - Dates are within acceptable range - Optional normalization to ISO format</p> ATTRIBUTE DESCRIPTION <code>date_fields</code> <p>List of field names to validate</p> <p> </p> <code>formats</code> <p>Accepted date formats (strptime patterns)</p> <p> </p> <code>min_date</code> <p>Minimum acceptable date</p> <p> </p> <code>max_date</code> <p>Maximum acceptable date</p> <p> </p> <p>Initialize the date validator.</p> PARAMETER DESCRIPTION <code>date_fields</code> <p>Field names to validate (None = auto-detect)</p> <p> TYPE: <code>Optional[List[str]]</code> DEFAULT: <code>None</code> </p> <code>formats</code> <p>Accepted date formats</p> <p> TYPE: <code>Optional[List[str]]</code> DEFAULT: <code>None</code> </p> <code>min_year</code> <p>Minimum acceptable year</p> <p> TYPE: <code>int</code> DEFAULT: <code>1900</code> </p> <code>max_year</code> <p>Maximum acceptable year</p> <p> TYPE: <code>int</code> DEFAULT: <code>2100</code> </p> Source code in <code>strutex/validators/date.py</code> <pre><code>def __init__(\n    self,\n    date_fields: Optional[List[str]] = None,\n    formats: Optional[List[str]] = None,\n    min_year: int = 1900,\n    max_year: int = 2100,\n):\n    \"\"\"\n    Initialize the date validator.\n\n    Args:\n        date_fields: Field names to validate (None = auto-detect)\n        formats: Accepted date formats\n        min_year: Minimum acceptable year\n        max_year: Maximum acceptable year\n    \"\"\"\n    self.date_fields = date_fields\n    self.formats = formats or self.DEFAULT_FORMATS\n    self.min_year = min_year\n    self.max_year = max_year\n</code></pre>"},{"location":"validators/#strutex.validators.DateValidator.validate","title":"<code>validate(data: Dict[str, Any], schema=None) -&gt; ValidationResult</code>","text":"<p>Validate date fields in the data.</p> PARAMETER DESCRIPTION <code>data</code> <p>The extracted data to validate</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>schema</code> <p>Not used by this validator</p> <p> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValidationResult</code> <p>ValidationResult with validation status</p> Source code in <code>strutex/validators/date.py</code> <pre><code>def validate(self, data: Dict[str, Any], schema=None) -&gt; ValidationResult:\n    \"\"\"\n    Validate date fields in the data.\n\n    Args:\n        data: The extracted data to validate\n        schema: Not used by this validator\n\n    Returns:\n        ValidationResult with validation status\n    \"\"\"\n    issues = []\n\n    # Determine which fields to check\n    if self.date_fields:\n        fields_to_check = self.date_fields\n    else:\n        # Auto-detect: look for fields with \"date\" in the name\n        fields_to_check = [\n            k for k in data.keys() \n            if \"date\" in k.lower()\n        ]\n\n    for field in fields_to_check:\n        value = data.get(field)\n        if value is None or value == \"\":\n            continue\n\n        if not isinstance(value, str):\n            continue\n\n        # Try to parse the date\n        parsed_date = None\n        for fmt in self.formats:\n            try:\n                parsed_date = datetime.strptime(value, fmt)\n                break\n            except ValueError:\n                continue\n\n        if parsed_date is None:\n            issues.append(f\"{field}: invalid date format '{value}'\")\n            continue\n\n        # Check year range\n        if parsed_date.year &lt; self.min_year:\n            issues.append(f\"{field}: year {parsed_date.year} is before {self.min_year}\")\n        elif parsed_date.year &gt; self.max_year:\n            issues.append(f\"{field}: year {parsed_date.year} is after {self.max_year}\")\n\n    return ValidationResult(\n        valid=len(issues) == 0,\n        data=data,\n        issues=issues\n    )\n</code></pre>"},{"location":"validators/#strutex.validators.ValidationChain","title":"<code>ValidationChain(validators: List[Validator], strict: bool = True)</code>","text":"<p>Composes multiple validators into a sequential chain.</p> <p>Validators run in order. If any validator fails (in strict mode), the chain stops and returns the failure. In lenient mode, all validators run and issues are collected.</p> Example <pre><code>chain = ValidationChain([\n    SchemaValidator(),\n    SumValidator(tolerance=0.01),\n    DateValidator(date_fields=[\"invoice_date\"]),\n])\n\nresult = chain.validate(data, schema)\nif not result.valid:\n    print(result.issues)\n</code></pre> <p>Initialize the validation chain.</p> PARAMETER DESCRIPTION <code>validators</code> <p>List of validators to run in order</p> <p> TYPE: <code>List[Validator]</code> </p> <code>strict</code> <p>If True, stop on first failure. If False, collect all issues.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> Source code in <code>strutex/validators/chain.py</code> <pre><code>def __init__(\n    self,\n    validators: List[Validator],\n    strict: bool = True\n):\n    \"\"\"\n    Initialize the validation chain.\n\n    Args:\n        validators: List of validators to run in order\n        strict: If True, stop on first failure. If False, collect all issues.\n    \"\"\"\n    self.validators = validators\n    self.strict = strict\n</code></pre>"},{"location":"validators/#strutex.validators.ValidationChain.add","title":"<code>add(validator: Validator) -&gt; ValidationChain</code>","text":"<p>Add a validator to the chain.</p> PARAMETER DESCRIPTION <code>validator</code> <p>The validator to add</p> <p> TYPE: <code>Validator</code> </p> RETURNS DESCRIPTION <code>ValidationChain</code> <p>Self for method chaining</p> Source code in <code>strutex/validators/chain.py</code> <pre><code>def add(self, validator: Validator) -&gt; \"ValidationChain\":\n    \"\"\"\n    Add a validator to the chain.\n\n    Args:\n        validator: The validator to add\n\n    Returns:\n        Self for method chaining\n    \"\"\"\n    self.validators.append(validator)\n    return self\n</code></pre>"},{"location":"validators/#strutex.validators.ValidationChain.validate","title":"<code>validate(data: Dict[str, Any], schema=None) -&gt; ValidationResult</code>","text":"<p>Run all validators in the chain.</p> PARAMETER DESCRIPTION <code>data</code> <p>The data to validate</p> <p> TYPE: <code>Dict[str, Any]</code> </p> <code>schema</code> <p>Optional schema to pass to validators</p> <p> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>ValidationResult</code> <p>Combined ValidationResult from all validators</p> Source code in <code>strutex/validators/chain.py</code> <pre><code>def validate(\n    self,\n    data: Dict[str, Any],\n    schema=None\n) -&gt; ValidationResult:\n    \"\"\"\n    Run all validators in the chain.\n\n    Args:\n        data: The data to validate\n        schema: Optional schema to pass to validators\n\n    Returns:\n        Combined ValidationResult from all validators\n    \"\"\"\n    all_issues: List[str] = []\n    current_data = data\n\n    for validator in self.validators:\n        result = validator.validate(current_data, schema)\n\n        if not result.valid:\n            all_issues.extend(result.issues)\n\n            if self.strict:\n                return ValidationResult(\n                    valid=False,\n                    data=current_data,\n                    issues=all_issues\n                )\n\n        # Use possibly modified data for next validator\n        current_data = result.data\n\n    return ValidationResult(\n        valid=len(all_issues) == 0,\n        data=current_data,\n        issues=all_issues\n    )\n</code></pre>"},{"location":"verification/","title":"Verification &amp; Self-Correction","text":"<p>Strutex v0.8.0 introduces Verification, a powerful mechanism to improve extraction accuracy by using the LLM to audit and correct its own work.</p>"},{"location":"verification/#overview","title":"Overview","text":"<p>Extraction errors can happen, especially with complex documents. The Verification feature runs a two-step workflow:</p> <ol> <li>Extraction: The document is processed normally to generate structured JSON.</li> <li>Audit: The result from step 1 is fed back to the LLM (or a different model) along with the original document. The model acts as a \"strict auditor\" to check for discrepancies and fix them.</li> </ol> <p>This \"Reflexion\" pattern significantly reduces hallucinations and missing fields.</p>"},{"location":"verification/#usage","title":"Usage","text":""},{"location":"verification/#automatic-verification","title":"Automatic Verification","text":"<p>The simplest way to use verification is to pass <code>verify=True</code> to the <code>process</code> (or <code>aprocess</code>) method.</p> <pre><code>from strutex import DocumentProcessor\nfrom strutex.schemas import INVOICE_US\n\nprocessor = DocumentProcessor()\n\nresult = processor.process(\n    file_path=\"invoice.pdf\",\n    prompt=\"Extract invoice data\",\n    schema=INVOICE_US,\n    verify=True  # \ud83d\udc48 Enables self-correction loop\n)\n</code></pre>"},{"location":"verification/#manual-verification","title":"Manual Verification","text":"<p>You can also run verification on a result you already have (e.g., from a previous run or a different system).</p> <pre><code>previous_result = {\n    \"invoice_number\": \"INV-001\",\n    \"total\": 500.00  # Suspicious value\n}\n\nverified_result = processor.verify(\n    file_path=\"invoice.pdf\",\n    result=previous_result,\n    schema=INVOICE_US\n)\n</code></pre>"},{"location":"verification/#async-support","title":"Async Support","text":"<p>Verification is fully supported in async workflows:</p> <pre><code>result = await processor.aprocess(\n    ...,\n    verify=True\n)\n\n# Or manually:\nresult = await processor.averify(...)\n</code></pre>"},{"location":"verification/#configuration","title":"Configuration","text":""},{"location":"verification/#custom-verification-prompt","title":"Custom Verification Prompt","text":"<p>By default, Strutex uses a generic \"strict auditor\" system prompt. You can customize this to look for specific errors.</p> <pre><code>result = processor.process(\n    ...,\n    verify=True,\n    verify_prompt=\"Check strictly that the 'total' matches the sum of line items.\"\n)\n</code></pre>"},{"location":"verification/#performance-cost","title":"Performance &amp; Cost","text":"<p>Enabling verification doubles the number of LLM calls (1 extraction + 1 verification). This increases:</p> <ul> <li>Latency: Expect roughly 2x processing time.</li> <li>Cost: Expect roughly 2x token usage.</li> </ul> <p>Usage Tracking</p> <p>With <code>verify=True</code>, usage statistics (tokens/cost) in the returned result only reflect the verification pass. If you need total cost tracking, ensure you are logging usage from your quota manager or provider dashboard.</p>"},{"location":"verification/#best-practices","title":"Best Practices","text":"<ul> <li>Use <code>verify=True</code> for critical data fields where accuracy is paramount (e.g. financial totals).</li> <li>For high-volume low-value documents, you might skip verification to save costs.</li> <li>Consider using a faster/cheaper model for extraction and a stronger model for verification (currently requires manual 2-step calls).</li> </ul>"}]}